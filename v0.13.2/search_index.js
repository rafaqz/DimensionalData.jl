var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To use the functionality of DimensionalData in your module, dispatch on AbstractDimArray and AbstractDimension.","category":"page"},{"location":"api/#Arrays","page":"API","title":"Arrays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimArray\r\nDimArray","category":"page"},{"location":"api/#DimensionalData.AbstractDimArray","page":"API","title":"DimensionalData.AbstractDimArray","text":"Supertype for all \"dim\" arrays.\n\nThese arrays return a Tuple of Dimension from a dims method, and can be rebuilt using rebuild.\n\nparent must return the source array.\n\nThey should have metadata, name and refdims methods, although these are optional.\n\nA rebuild method for AbstractDimArray must accept data, dims, refdims, name, metadata arguments.\n\nIndexing AbstractDimArray with non-range AbstractArray has undefined effects  on the Dimension index. Use forward-ordered arrays only\"\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimArray","page":"API","title":"DimensionalData.DimArray","text":"DimArray(data, dims, refdims, name)\nDimArray(data, dims::Tuple [, name::Symbol]; refdims=(), metadata=nothing)\n\nThe main concrete subtype of AbstractDimArray.\n\nDimArray maintains and updates its Dimensions through transformations and  moves dimensions to reference dimension refdims after reducing operations  (like e.g. mean).\n\nArguments/Fields\n\ndata: An AbstractArray.\ndims: A Tuple of Dimension\nname: A string name for the array. Shows in plots and tables.\nrefdims: refence dimensions. Usually set programmatically to track past  slices and reductions of dimension for labelling and reconstruction.\nmetadata: Array metadata, or nothing\n\nIndexing can be done with all regular indices, or with Dimensions  and/or Selectors. Indexing AbstractDimArray with non-range AbstractArray  has undefined effects on the Dimension index. Use forward-ordered arrays only\"\n\nExample:\n\nusing Dates, DimensionalData\n\nti = (Ti(DateTime(2001):Month(1):DateTime(2001,12)),\nx = X(10:10:100))\nA = DimArray(rand(12,10), (ti, x), \"example\")\n\njulia> A[X(Near([12, 35])), Ti(At(DateTime(2001,5)))];\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)];\n\n\n\n\n\n","category":"type"},{"location":"api/#Multi-array-datasets","page":"API","title":"Multi-array datasets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimDataset\r\nDimDataset","category":"page"},{"location":"api/#DimensionalData.AbstractDimDataset","page":"API","title":"DimensionalData.AbstractDimDataset","text":"Supertype for dimensional datasets.\n\nThese have multiple layers of data, but share dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimDataset","page":"API","title":"DimensionalData.DimDataset","text":"DimDataset(data::AbstractDimArray...)\nDimDataset(data::Tuple{Vararg{<:AbstractDimArray}})\nDimDataset(data::NamedTuple{Keys,Vararg{<:AbstractDimArray}}) \nDimDataset(data::NamedTuple, dims::DimTuple; metadata=nothing)\n\nDimDataset holds multiple objects with the same dimensions, in a NamedTuple. Indexing operates as for AbstractDimArray, except it occurs for all data layers of the dataset simulataneously. Layer objects can hold values of any type.\n\nDimDataset can be constructed from multiple AbstractDimArray or a NamedTuple of AbstractArray and a matching dims Tuple. If AbstractDimArrays have the same name they will be given the name :layer1, substitiuting the actual layer number for 1.\n\ngetindex with Int or Dimensions or Selectors that resolve to Int will return a NamedTuple of values from each layer in the dataset. This has very good performace, and usually takes less time than the sum of indexing each array  separately.\n\nIndexing with a Vector or Colon will return another DimDataset where all data layers have been sliced.  setindex! must pass a Tuple or NamedTuple maching  the layers.\n\nMost Base and Statistics methods that apply gto AbstractArray can be used on  all layers of the dataset simulataneously. The result is a DimDataset, or a NamedTuple if methods like mean are used without dims arguments, and  return a single non-array value.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0];\n\njulia> dimz = (X([:a, :b]), Y(10.0:10.0:30.0))\n(X (type X): Symbol[a, b] (AutoMode), Y (type Y): 10.0:10.0:30.0 (AutoMode))\n\njulia> da1 = DimArray(1A, dimz, :one);\n\n\n\njulia> da2 = DimArray(2A, dimz, :two);\n\n\n\njulia> da3 = DimArray(3A, dimz, :three);\n\n\n\njulia> ds = DimDataset(da1, da2, da3)\nDimDataset{NamedTuple{(:one, :two, :three),Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}},2,Tuple{X{Array{Symbol,1},Categorical{Unordered{ForwardRelation}},Nothing},Y{StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Sampled{Ordered{ForwardIndex,ForwardArray,ForwardRelation},Regular{Float64},Points},Nothing}},Tuple{},NamedTuple{(:one, :two, :three),Tuple{Nothing,Nothing,Nothing}}}((one = [1.0 2.0 3.0; 4.0 5.0 6.0], two = [2.0 4.0 6.0; 8.0 10.0 12.0], three = [3.0 6.0 9.0; 12.0 15.0 18.0]), (X (type X): Symbol[a, b] (Categorical: Unordered), Y (type Y): 10.0:10.0:30.0 (Sampled: Ordered Regular Points)), (), (one = nothing, two = nothing, three = nothing))\n\njulia> ds[:b, 10.0]\n(one = 4.0, two = 8.0, three = 12.0)\n\njulia> ds[X(:a)]\nDimDataset{NamedTuple{(:one, :two, :three),Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}},1,Tuple{Y{StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Sampled{Ordered{ForwardIndex,ForwardArray,ForwardRelation},Regular{Float64},Points},Nothing}},Tuple{X{Symbol,Categorical{Unordered{ForwardRelation}},Nothing}},NamedTuple{(:one, :two, :three),Tuple{Nothing,Nothing,Nothing}}}((one = [1.0, 2.0, 3.0], two = [2.0, 4.0, 6.0], three = [3.0, 6.0, 9.0]), (Y (type Y): 10.0:10.0:30.0 (Sampled: Ordered Regular Points),), (X (type X): a (Categorical: Unordered),), (one = nothing, two = nothing, three = nothing))\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-types","page":"API","title":"Core types","text":"","category":"section"},{"location":"api/#Dimensions:","page":"API","title":"Dimensions:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Dimension\r\nDependentDim\r\nIndependentDim\r\nXDim\r\nYDim\r\nZDim\r\nTimeDim\r\nX\r\nY\r\nZ\r\nTi\r\nParametricDimension\r\nDim\r\nAnonDim\r\n@dim","category":"page"},{"location":"api/#DimensionalData.Dimension","page":"API","title":"DimensionalData.Dimension","text":"Supertype of all dimension types.\n\nExample concrete implementations are X, Y, Z,  Ti (Time), and the custom [Dim]@ref) dimension.\n\nDimensions label the axes of an AbstractDimArray,  or other dimensional objects, and are used to index into the array.\n\nThey may also provide an alternate index to lookup for each array axis. This may be any AbstractVector matching the array axis length, or a Val holding a tuple for compile-time index lookups.\n\nDimensions also have mode and metadata fields. \n\nmode gives more details about the dimension, such as that it is  Categorical or Sampled as Points or  Intervals along some transect. DimensionalData will attempt to guess the mode from the passed-in index value.\n\nmetadata can hold any metadata object adding more information about  the array axis - useful for extending DimensionalData for specific  contexts, like geospatial data in GeoData.jl. By default it is nothing.\n\nExample:\n\nusing DimensionalData, Dates\n\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimArray(zeros(3, 5, 12), (y, x, ti))\n\n# output\n\nDimArray with dimensions:\n Y (type Y): Char[a, b, c] (Categorical: Unordered)\n X (type X): 2:2:10 (Sampled: Ordered Regular Points)\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand data: 3×5×12 Array{Float64,3}\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n[and 11 more slices...]\n\nFor simplicity, the same Dimension types are also used as wrappers  in getindex, like:\n\nx = A[X(2), Y(3)]\n\n# output\n\nDimArray with dimensions:\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Y (type Y): c (Categorical: Unordered)\n X (type X): 4 (Sampled: Ordered Regular Points)\nand data: 12-element Array{Float64,1}\n[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\nA Dimension can also wrap Selector.\n\nx = A[X(Between(3, 4)), Y(At('b'))]\n\n# output\n\nDimArray with dimensions:\n X (type X): 4:2:4 (Sampled: Ordered Regular Points)\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Y (type Y): b (Categorical: Unordered)\nand data: 1×12 Array{Float64,2}\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\nDimension objects may have mode and metadata fields to track additional information about the data and the index, and their relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DependentDim","page":"API","title":"DimensionalData.DependentDim","text":"Supertype for Dependent dimensions. These will plot on the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndependentDim","page":"API","title":"DimensionalData.IndependentDim","text":"Supertype for independent dimensions. Thise will plot on the X axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.XDim","page":"API","title":"DimensionalData.XDim","text":"Supertype for all X dimensions. \n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.YDim","page":"API","title":"DimensionalData.YDim","text":"Supertype for all Y dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ZDim","page":"API","title":"DimensionalData.ZDim","text":"Supertype for all Z dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.TimeDim","page":"API","title":"DimensionalData.TimeDim","text":"Supertype for all time dimensions.\n\nIn a TimeDime with Interval sampling the locus will automatically  be set to Start(). Dates and times generally refer to the start of a  month, hour, second etc., not the central point as is more common with spatial data. `\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.X","page":"API","title":"DimensionalData.X","text":"X(val=:; mode=AutoMode(), metadata=nothing)\n\nX Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nxdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Y","page":"API","title":"DimensionalData.Y","text":"Y(val=:; mode=AutoMode(), metadata=nothing)\n\nY Dimension. Y <: YDim <: DependentDim\n\nExample:\n\nydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Z","page":"API","title":"DimensionalData.Z","text":"Z(val=:; mode=AutoMode(), metadata=nothing)\n\nZ Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nzdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ti","page":"API","title":"DimensionalData.Ti","text":"Ti(val=:; mode=AutoMode(), metadata=nothing)\n\nTime Dimension. Ti <: TimeDim <: IndependentDim\n\nTime is already used by Dates, and T is a common type parameter,  We use Ti to avoid clashes.\n\nExample:\n\ntimedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n# Or\nval = A[Ti(1)]\n# Or\nmean(A; dims=Ti)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ParametricDimension","page":"API","title":"DimensionalData.ParametricDimension","text":"Supertype for Dimensions with user-set type paremeters\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dim","page":"API","title":"DimensionalData.Dim","text":"Dim{S}()\nDim{S}(val=:; mode=AutoMode(), metadata=nothing)\nDim{S}(val, mode, metadata=nothing)\n\nA generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.\n\nDimension types take precedence over same named Dim types when indexing  with symbols, or e.g. creating Tables.jl keys.\n\nusing DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\ndimension custom (type Dim):\nval: Char[a, b, c]\nmode: AutoMode\nmetadata: nothing\ntype: Dim{:custom,Array{Char,1},AutoMode{AutoOrder},Nothing}\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AnonDim","page":"API","title":"DimensionalData.AnonDim","text":"AnonDim()\n\nAnonymous dimension. Used when extra dimensions are created,  such as during transpose of a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.@dim","page":"API","title":"DimensionalData.@dim","text":"@dim typ [supertype=Dimension] [name::String=typ]\n\nMacro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply YourDim <: Dimension. Making a Dimesion inherit from XDim, YDim, ZDim or TimeDim will affect  automatic plot layout and other methods that dispatch on these types. <: YDim are plotted on the Y axis, <: XDim on the X axis, etc.\n\nExample:\n\n@dim Lat \"Lattitude\" \"lat\"\n@dim Lon XDim \"Longitude\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#Selectors","page":"API","title":"Selectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Selector\r\nAt\r\nNear\r\nBetween\r\nContains\r\nWhere","category":"page"},{"location":"api/#DimensionalData.Selector","page":"API","title":"DimensionalData.Selector","text":"Selectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as DateTime objects for a Ti dimension.\n\nSelectors provided in DimensionalData are:\n\nAt\nBetween\nNear\nWhere\nContains\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.At","page":"API","title":"DimensionalData.At","text":"At(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Near","page":"API","title":"DimensionalData.Near","text":"Near(x)\n\nSelector that selects the nearest index to x.\n\nWith Points this is simply the index values nearest to the x, however with Intervals it is the interval center nearest to x. This will be offset from the index value for Start and End loci.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n\n4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Between","page":"API","title":"DimensionalData.Between","text":"Between(a, b)\n\nSelector that retreive all indices located between 2 values, evaluated with >= for the lower value, and < for the upper value. This means the same value will not be counted twice in 2 adjacent  Between selections.\n\nFor Intervals the whole interval must be lie between the values. For Points the points must fall between the values. Different Sampling types may give different results with the same input - this is the intended behaviour.\n\nBetween for Irregular intervals is a little complicated. The interval is the distance between a value and the next (for Start locus) or previous (for End locus) value.\n\nFor Center, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use Between with Irregular Intervals(Center()) with caution.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Between(15, 25)), Y(Between(4, 6.5))]\n\n# output\n\nDimArray with dimensions:\n X (type X): 20:10:20 (Sampled: Ordered Regular Points)\n Y (type Y): 5:6 (Sampled: Ordered Regular Points)\nand data: 1×2 Array{Int64,2}\n 4  5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Contains","page":"API","title":"DimensionalData.Contains","text":"Contains(x)\n\nSelector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.\n\nCan only be used for Intervals or Categorical.\n\nExample\n\nusing DimensionalData\n\ndims_ = X(10:10:20; mode=Sampled(sampling=Intervals())),\n        Y(5:7; mode=Sampled(sampling=Intervals()))\nA = DimArray([1 2 3; 4 5 6], dims_)\nA[X(Contains(8)), Y(Contains(6.8))]\n\n# output\n\n3\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Where","page":"API","title":"DimensionalData.Where","text":"Where(f::Function)\n\nSelector that filters a dimension by any function that accepts a single value from the index and returns a Bool.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))\nA[X(Where(x -> x > 15)), Y(Where(x -> x in (19, 21)))]\n\n# output\n\nDimArray with dimensions:\n X (type X): Int64[20] (Sampled: Ordered Regular Points)\n Y (type Y): Int64[19, 21] (Sampled: Ordered Regular Points)\nand data: 1×2 Array{Int64,2}\n 4  6\n\n\n\n\n\n","category":"type"},{"location":"api/#Modes","page":"API","title":"Modes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Mode\r\nIndexMode\r\nAligned\r\nAbstractSampled\r\nSampled\r\nAbstractCategorical\r\nCategorical\r\nUnaligned\r\nTransformed\r\nNoIndex\r\nAutoMode","category":"page"},{"location":"api/#DimensionalData.Mode","page":"API","title":"DimensionalData.Mode","text":"Supertype for all Dimension modes. Defines or modifies dimension behaviour.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndexMode","page":"API","title":"DimensionalData.IndexMode","text":"Types defining the behaviour of a dimension index, how it is plotted  and how Selectors like Between work.\n\nAn IndexMode may be a simple type like NoIndex indicating that the index is just the underlying array axis. It could also be a Categorical index indicating the index is ordered or unordered categories, or a Sampled index indicating sampling along some transect.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Aligned","page":"API","title":"DimensionalData.Aligned","text":"Supertype for IndexModes where the index is aligned with the array axes. This is by far the most common case.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractSampled","page":"API","title":"DimensionalData.AbstractSampled","text":"Abstract supertype for IndexModes where the index is aligned with the array, and is independent of other dimensions. Sampled is provided by this package, Projected in GeoData.jl also extends AbstractSampled, adding crs projections.\n\nAbstractSampled must have  order, span and sampling fields, or a rebuild method that accpts them as keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Sampled","page":"API","title":"DimensionalData.Sampled","text":"Sampled(order::Order, span::Span, sampling::Sampling)\nSampled(; order=AutoOrder(), span=AutoSpan(), sampling=Points())\n\nA concrete implementation of the IndexMode AbstractSampled. It can be used to represent Points or Intervals.\n\nIt is capable of representing gridded data from a wide range of sources, allowing correct bounds and Selectors for points or intervals of regular, irregular, forward and reverse indexes.\n\nThe Sampled mode is assigned for all indexes of AbstractRange not assigned to Categorical.\n\nFields\n\norder indicating array and index order (in Order), detected from the range order.\nspan indicates the size of intervals or distance between points, and will be set to Regular for AbstractRange and Irregular for AbstractArray, unless assigned manually.\nsampling is assigned to Points, unless set to Intervals manually. Using Intervals will change the behaviour of bounds and Selectorss to take account for the full size of the interval, rather than the point alone.\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\ndims_ = (X(100:-10:10; mode=Sampled(sampling=Intervals())),\n         Y([1, 4, 7, 10]; mode=Sampled(span=Regular(2), sampling=Intervals())))\nA = DimArray(rand(10, 4), dims_)\nmap(mode, dims(A))\n\n# output\n\n(Sampled: Ordered Regular Intervals, Sampled: Ordered Regular Intervals)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractCategorical","page":"API","title":"DimensionalData.AbstractCategorical","text":"IndexModes for dimensions where the values are categories.\n\nCategorical is the provided concrete implementation.\n\nAbstractCategorical must have an order field or a rebuild method with an order keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Categorical","page":"API","title":"DimensionalData.Categorical","text":"Categorical(o::Order)\nCategorical(; order=Unordered())\n\nAn IndexMode where the values are categories.\n\nThis will be automatically assigned if the index contains AbstractString, Symbol or Char. Otherwise it can be assigned manually.\n\nOrder will not be determined automatically for Categorical, it instead defaults to [Unordered].\n\nFields\n\norder: Order indicating array and index order.\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\ndims_ = X([\"one\", \"two\", \"thee\"]), Y([:a, :b, :c, :d])\nA = DimArray(rand(3, 4), dims_)\nmap(mode, dims(A))\n\n# output\n\n(Categorical: Unordered, Categorical: Unordered)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unaligned","page":"API","title":"DimensionalData.Unaligned","text":"Supertype for IndexMode where the Dimension index is not aligned to the grid.\n\nIndexing with an Unaligned dimension with Selectors must provide all other Unaligned dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Transformed","page":"API","title":"DimensionalData.Transformed","text":"Transformed(f, dim::Dimension)\n\nIndexMode that uses an affine transformation to convert dimensions from dims(mode) to dims(array). This can be useful when the dimensions are e.g. rotated from a more commonly used axis.\n\nAny function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.\n\nFields\n\nf: transformation function\ndims: a tuple containing dimenension types or symbols matching the order needed by the transform function.\n\nExample\n\nusing DimensionalData, CoordinateTransformations\n\nm = LinearMap([0.5 0.0; 0.0 0.5])\nA = [1 2  3  4\n     5 6  7  8\n     9 10 11 12];\ndimz = Dim{:t1}(mode=Transformed(m, X)),\n              Dim{:t2}(mode=Transformed(m, Y))\nda = DimArray(A, dimz)\n\nda[X(At(6)), Y(At(2))]\n\n# output\n\n9\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoIndex","page":"API","title":"DimensionalData.NoIndex","text":"NoIndex()\n\nAn IndexMode that is identical to the array axis.\n\nExample\n\nDefining a DimArray without passing an index to the dimension, the IndexMode will be NoIndex:\n\nusing DimensionalData\n\nA = DimArray(rand(3, 3), (X, Y))\nmap(mode, dims(A))\n\n# output\n\n(NoIndex, NoIndex)\n\nIs identical to:\n\nA = DimArray(rand(3, 3), (X(; mode=NoIndex()), Y(; mode=NoIndex())))\nmap(mode, dims(A))\n\n# output\n\n(NoIndex, NoIndex)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoMode","page":"API","title":"DimensionalData.AutoMode","text":"AutoMode()\n\nAutomatic IndexMode, the default mode. It will be converted automatically to another IndexMode when it is possible to detect it from the index.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Order of arrays and indices:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Order\r\nUnordered\r\nOrdered\r\nAutoOrder\r\nUnknownOrder\r\nIndexOrder\r\nForwardIndex\r\nReverseIndex\r\nArrayOrder\r\nForwardArray\r\nReverseArray\r\nRelation\r\nForwardRelation\r\nReverseRelation","category":"page"},{"location":"api/#DimensionalData.Order","page":"API","title":"DimensionalData.Order","text":"Traits for the order of the array, index and the relation between them.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unordered","page":"API","title":"DimensionalData.Unordered","text":"Unordered(relation=ForwardRelation())\n\nTrait indicating that the array or dimension has no order. This means the index cannot be searched with searchsortedfirst, or similar methods, and that plotting order does not matter.\n\nIt still has a relation between the array axis and the dimension index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ordered","page":"API","title":"DimensionalData.Ordered","text":"Ordered(index, array, relation)\nOrdered(; index=ForwardIndex(), array=ForwardArray(), relation=ForwardRelation())\n\nContainer object for dimension and array ordering.\n\nFields\n\nEach can have a value of  ForwardX or ReverseX.\n\nindex: The order of the dimension index\narray: The order of array axis, in terms of how you would want to plot it\nrelation: The relation between the index and the array.\n\nAll combinations of forward and reverse order for data and index seem to occurr in real datasets, as strange as that seems. We cover these possibilities by specifying the order of both explicitly, and the direction of the relationship between them.\n\nKnowing the order of indices is important for using methods like searchsortedfirst() to find indices in sorted lists of values. Knowing the order of the data is then required to map to the actual indices. It's also used to plot the data later.\n\nThe default is Ordered(ForwardIndex(), ForwardArray(), ForwardRelation())\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoOrder","page":"API","title":"DimensionalData.AutoOrder","text":"AutoOrder()\n\nOrder will be found automatically where possible.\n\nThis will fail for all dim eltypes without isless methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.UnknownOrder","page":"API","title":"DimensionalData.UnknownOrder","text":"UnknownOrder()\n\nSpecifies that Order is not known and can't be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndexOrder","page":"API","title":"DimensionalData.IndexOrder","text":"Supertype for dim index order\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ForwardIndex","page":"API","title":"DimensionalData.ForwardIndex","text":"ForwardIndex()\n\nIndicates that the dimension index is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ReverseIndex","page":"API","title":"DimensionalData.ReverseIndex","text":"ReverseIndex()\n\nIndicates that the dimension index is in reverse order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ArrayOrder","page":"API","title":"DimensionalData.ArrayOrder","text":"Supertype for array ordering\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ForwardArray","page":"API","title":"DimensionalData.ForwardArray","text":"ForwardArray()\n\nIndicates that the array axis is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ReverseArray","page":"API","title":"DimensionalData.ReverseArray","text":"ReverseArray()\n\nIndicates that the array axis is in reverse order.\n\nIt will be plotted backwards.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Relation","page":"API","title":"DimensionalData.Relation","text":"Supertype for index/array relationship\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ForwardRelation","page":"API","title":"DimensionalData.ForwardRelation","text":"ForwardRelation()\n\nIndicates that the relationship between the index and the array is int the normal forward direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ReverseRelation","page":"API","title":"DimensionalData.ReverseRelation","text":"ReverseRelation()\n\nIndicates that the relationship between the index and the array is reversed.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Index modes for Intervals","category":"page"},{"location":"api/#Span","page":"API","title":"Span","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Span\r\nRegular\r\nIrregular\r\nAutoSpan","category":"page"},{"location":"api/#DimensionalData.Span","page":"API","title":"DimensionalData.Span","text":"Defines the type of span used in a Sampling index. These are Regular or Irregular.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Regular","page":"API","title":"DimensionalData.Regular","text":"Regular(step=AutoStep())\n\nIntervalss have regular size. This is passed to the constructor, although these are normally build automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Irregular","page":"API","title":"DimensionalData.Irregular","text":"Irregular(bounds::Tuple)\nIrregular(lowerbound, upperbound)\n\nIrregular have irrigular size. To enable bounds tracking and accuract selectors, the starting bounds must be provided as a 2 tuple, or 2 arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoSpan","page":"API","title":"DimensionalData.AutoSpan","text":"AutoSpan()\n\nSpan will be guessed and replaced by a constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Sampling\r\nPoints\r\nIntervals","category":"page"},{"location":"api/#DimensionalData.Sampling","page":"API","title":"DimensionalData.Sampling","text":"Indicates the sampling method used by the index: Points or Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Points","page":"API","title":"DimensionalData.Points","text":"Points()\n\nSampling mode where single samples at exact points.\n\nThese are always plotted at the center of array cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Intervals","page":"API","title":"DimensionalData.Intervals","text":"Intervals(locus::Locus)\n\nSampling mode where samples are the mean (or similar) value over an interval.\n\nIntervals require a Locus of Start, Center or End to define where in the interval the index values refer to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Loci","page":"API","title":"Loci","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Sampling positions for Intervals","category":"page"},{"location":"api/","page":"API","title":"API","text":"Locus\r\nCenter\r\nStart\r\nEnd\r\nAutoLocus","category":"page"},{"location":"api/#DimensionalData.Locus","page":"API","title":"DimensionalData.Locus","text":"Locii indicate the position of index values in cells.\n\nThese allow for values array cells to align with the Start, Center, or End of values in the dimension index.\n\nThis means they can be plotted with correct axis markers, and allows automatic converrsions to between formats with different standards (such as NetCDF and GeoTiff).\n\nLocii are often Start for time series, but often Center for spatial data.\n\nThese are reflected in the default values: Ti dimensions with Sampled index mode will default to Start Locii. All others default to Center.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Center","page":"API","title":"DimensionalData.Center","text":"Center()\n\nIndicates a dimension value is for the center of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Start","page":"API","title":"DimensionalData.Start","text":"Start()\n\nIndicates a dimension value is for the start of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.End","page":"API","title":"DimensionalData.End","text":"End()\n\nIndicates a dimension value is for the end of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoLocus","page":"API","title":"DimensionalData.AutoLocus","text":"AutoLocus()\n\nIndicates a dimension where the index position is not yet known. This will be filled with a default on object construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.jl-interface","page":"API","title":"Tables.jl interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimTable\r\nDimensionalData.DimColumn","category":"page"},{"location":"api/#DimensionalData.DimTable","page":"API","title":"DimensionalData.DimTable","text":"DimTable(A::AbstractDimArray)\n\nConstruct a Tables.jl compatible object out of an AbstractDimArray.\n\nThis table will have a column for the array data and columns for each  Dimension index, as a [DimColumn]. These are lazy, and generated as required.\n\nColumn names are converted from the dimension types using  DimensionalData.dim2key. This means type Ti becomes the  column name :Ti, and Dim{:custom} becomes :custom.\n\nTo get dimension columns, you can index with Dimension (X()) or Dimension type (X) as well as the regular Int or Symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimColumn","page":"API","title":"DimensionalData.DimColumn","text":"DimColumn{T,D<:Dimension} <: AbstractVector{T}\n\nDimColumn(dim::Dimension, dims::Tuple{Vararg{<:DimTuple}})\nDimColumn(dim::DimColumn, length::Int, dimstride::Int)\n\nA table column based on a Dimension and it's relationship with other  Dimensions in dims. \n\nlength is the product of all dim lengths (usually the length of the corresponding  array data), while stride is the product of the preceding dimension lengths, which  may or may not be the real stride of the corresponding array depending on the data type. For A isa Array, the dimstride will match the stride.\n\nWhen the second argument is a Tuple of Dimension, the length and dimstride fields are calculated from the dimensions, relative to the column dimension dim.\n\nThis object will be returned as a column of DimTable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#Getting-basic-info","page":"API","title":"Getting basic info","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These useful functions for obtaining information from your dimensional data:","category":"page"},{"location":"api/","page":"API","title":"API","text":"dims\r\nrefdims\r\nmetadata\r\nname\r\nunits\r\nlabel","category":"page"},{"location":"api/#DimensionalData.dims","page":"API","title":"DimensionalData.dims","text":"dims(x) => Tuple{Vararg{<:Dimension}}\ndims(x, dims::Tuple) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension\n\nReturn a tuple of Dimensions for an object, in the order that matches  the axes or columns etc. of the underlying data.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nThe default is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims","page":"API","title":"DimensionalData.refdims","text":"refdims(x) => Tuple{Vararg{<:Dimension}}\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some  captions empty.\n\nThe default is to return an empty Tuple ().\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.metadata","page":"API","title":"DimensionalData.metadata","text":"metadata(dim::Dimension)\nmetadata(dims::Tuple{<:Dimension,Vararg})\nmetadata(A::AbstractDimArray, dims::Tuple)  => (Dim metadata)\nmetadata(A::AbstractDimArray) => (Array metadata)\n\nReturns the metadata for an array or the specified dimension(s). dims can be a Symbol (with Dim{X}, a Dimension, a Dimension type,  or a mixed tuple.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.name","page":"API","title":"DimensionalData.name","text":"name(x) => String\nname(xs::NTuple{N,<:Dimension}) => NTuple{N,String}\nname(A::AbstractDimArray, dims::NTuple{N}) => NTuple{N,String}\n\nGet the name of an array or Dimension, or a tuple of of either.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.units","page":"API","title":"DimensionalData.units","text":"units(x) => Union{Nothing,Any}\nunits(::NTuple{N}) => NTuple{N}\nunit(A::AbstractDimArray, dims::NTuple{N}) => NTuple{N,String}\n\nGet the units of an array or Dimension, or a tuple of of either.\n\nUnits do not have a set field, and may or may not be included in metadata. This method is to facilitate use in labels and plots when units are available,  not a guarantee that they will be. If not available, nothing is returned.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.label","page":"API","title":"DimensionalData.label","text":"label(x) => String\nlabel(dims::NTuple{N,<:Dimension}) => NTuple{N,String}\nlabel(A::AbstractDimArray, dims::NTuple{N,<:Dimension}) => NTuple{N,String}\n\nGet a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Dimesion and mode properties:","category":"page"},{"location":"api/","page":"API","title":"API","text":"val\r\nindex\r\nmode\r\nbounds\r\nsampling\r\nlocus\r\nspan\r\norder\r\nindexorder\r\narrayorder\r\nrelation","category":"page"},{"location":"api/#DimensionalData.val","page":"API","title":"DimensionalData.val","text":"val(x)\nval(dims::Tuple) => Tuple\n\nReturn the contained value of a wrapper object.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nObjects that don't define a val method are returned unaltered.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.index","page":"API","title":"DimensionalData.index","text":"index(dim::Dimension{<:Val}) => Tuple\nindex(dim::Dimension{<:AbstractArray}) => AbstractArray\nindex(dims::NTuple{N}) => Tuple{Vararg{Union{AbstractArray,Tuple},N}}\n\nReturn the contained index of a Dimension. \n\nOnly valid when a Dimension contains an AbstractArray  or a Val tuple like Val{(:a, :b)}(). The Val is unwrapped to return just the Tuple\n\ndims can be a Dimension, or a tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.mode","page":"API","title":"DimensionalData.mode","text":"mode(dim:Dimension) => IndexMode \nmode(dims::Tuple) => Tuple{Vararg{<:IndexMode,N}}\nmode(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturns the IndexMode of a dimension. This dictates properties of the dimension such as array axis and index order,  and sampling properties.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.bounds","page":"API","title":"DimensionalData.bounds","text":"bounds(dim::Dimension) => Tuple{T,T}}\nbounds(dims::Tuple{<:Dimension,Vararg}) => Tuple{Vararg{<:Tuple{T,T}}}\nbounds(A::AbstractArray, [dims]) => Tuple{Vararg{Tuple{T,T},N}}\nbounds(A::AbstractArray, dim) => Tuple{T,T}\n\nReturn the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.sampling","page":"API","title":"DimensionalData.sampling","text":"sampling(dim:Dimension) => Sampling \nsampling(dims::Tuple) => Tuple{Vararg{<:Sampling,N}}\nsampling(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Sampling for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.locus","page":"API","title":"DimensionalData.locus","text":"locus(dim:Dimension) => Locus \nlocus(dims::Tuple) => Tuple{Vararg{<:Locus,N}}\nlocus(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Locus for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.span","page":"API","title":"DimensionalData.span","text":"span(dim:Dimension) => Span \nspan(dims::Tuple) => Tuple{Vararg{<:Span,N}}\nspan(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Span for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.order","page":"API","title":"DimensionalData.order","text":"order(dim:Dimension) => Order \norder(dims::Tuple) => Tuple{Vararg{<:Order,N}}\norder(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Order for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.indexorder","page":"API","title":"DimensionalData.indexorder","text":"indexorder(dim:Dimension) => Union{Forward,Reverse}\nindexorder(dims::Tuple) => Tuple{Vararg{<:Union{Forward,Reverse},N}}\nindexorder(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Order (Forward or Reverse) of the dimension index,  for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.arrayorder","page":"API","title":"DimensionalData.arrayorder","text":"arrayorder(dim:Dimension) => Union{Forward,Reverse}\narrayorder(dims::Tuple) => Tuple{Vararg{<:Union{Forward,Reverse},N}}\narrayorder(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the Order (Forward or Reverse) of the array,  for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.relation","page":"API","title":"DimensionalData.relation","text":"relation(dim:Dimension) => Union{Forward,Reverse}\nrelation(dims::Tuple) => Tuple{Vararg{<:Union{Forward,Reverse},N}}\nrelation(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturn the relation (Forward or Reverse) between the dimension index and the array axis, for each dimension.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Dimension querying","category":"page"},{"location":"api/","page":"API","title":"API","text":"hasdim\r\ndimnum\r\notherdims\r\ncommondims","category":"page"},{"location":"api/#DimensionalData.hasdim","page":"API","title":"DimensionalData.hasdim","text":"hasdim(x, lookup::Tuple) => NTUple{Bool}\nhasdim(x, lookup) => Bool\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nCheck if an object or tuple contains an Dimension, or a tuple of dimensions.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> hasdim(A, X)\ntrue\n\njulia> hasdim(A, (Z, X, Y))\n(true, true, true)\n\njulia> hasdim(A, Ti)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimnum","page":"API","title":"DimensionalData.dimnum","text":"dimnum(x, lookup::Tuple) => NTuple{Int}\ndimnum(x, lookup) => Int\n\nGet the number(s) of Dimension(s) as ordered in the dimensions of an object.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple, Array or single Dimension or dimension Type.\n\nThe return type will be a Tuple of Int or a single Int, depending on wether lookup is a Tuple or single Dimension.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> dimnum(A, (Z, X, Y))\n(3, 1, 2)\n\njulia> dimnum(A, Y)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.otherdims","page":"API","title":"DimensionalData.otherdims","text":"otherdims(x, lookup) => Tuple{Vararg{<:Dimension,N}}\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nA tuple holding the unmatched dimensions is always returned.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> otherdims(A, X)\n(Y (type Y): Base.OneTo(10) (NoIndex), Z (type Z): Base.OneTo(10) (NoIndex))\n\njulia> otherdims(A, (Y, Z))\n(X (type X): Base.OneTo(10) (NoIndex),)\n\njulia> otherdims(A, Ti)\n(X (type X): Base.OneTo(10) (NoIndex), Y (type Y): Base.OneTo(10) (NoIndex), Z (type Z): Base.OneTo(10) (NoIndex))\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.commondims","page":"API","title":"DimensionalData.commondims","text":"commondims(x, lookup) => Tuple{Vararg{<:Dimension}}\n\nThis is basically dims(x, lookup) where the order of the original is kept,  unlike dims where the lookup tuple determines the order\n\nAlso unlike dims,commondims always returns a Tuple, no matter the input.\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> commondims(A, X)\n(X (type X): Base.OneTo(10) (NoIndex),)\n\njulia> commondims(A, (X, Z))\n(X (type X): Base.OneTo(10) (NoIndex), Z (type Z): Base.OneTo(10) (NoIndex))\n\njulia> commondims(A, Ti)\n()\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"And some utility methods for transforming DimensionalData objects:","category":"page"},{"location":"api/","page":"API","title":"API","text":"set\r\nrebuild\r\nmodify\r\ndimwise\r\ndimwise!\r\nreorder\r\nreverse","category":"page"},{"location":"api/#DimensionalData.set","page":"API","title":"DimensionalData.set","text":"Set the field matching the supertypes of values in xs and return a new object.\n\nAs DimensionalData is so strongly typed you do not need to specify what field to set - there is no ambiguity.\n\nTo set fields of dimensions you need to specify the dimension. This can be done using  Dimension => x pairs, X = x keyword arguments, Dimension wrapped arguments,  or a NamedTuple.\n\nWhen dimensions or IndexModes are passed to set to replace the existing ones,  fields that are not set will keep their original values.\n\nNotes:\n\nChanging the dimension index range will set the Sampled mode  component Regular with a new step size, and set the dimension order. \n\nSetting Order will not reverse the array or dimension to match. Use  reverse and reorder to do this.\n\nExamples\n\nda = DimArray(rand(3, 4), (Dim{:custom}(10.0:010.0:30.0), Z(-20:010.0:10.0)))\n\n# Set the array values\nset(da, zeros(3, 4))\n\n# Set the array name\nset(da, \"newname\") # Swap dimension type # Using Pairs set(da, :Z => Ti, :custom => Z) set(da, :custom => X, Z => Y)\n# Using keyword arguments\nset(da, custom = X, Z = :a)\n\n# Using Dimension wrappers\nset(da, Dim{:custom}(X), Z(Dim{:a}))\n\n# Set the dimension index\n\n# To an `AbstractArray` set(da, Z => [:a, :b, :c, :d], :custom => Val((4, 5, 6)))\n\n# To a `Val` tuple index (compile time indexing)\nset(da, Z(Val((:a, :b, :c, :d))), custom = 4:6)\n\n# Set dim modes\nset(da, Z=NoIndex(), custom=Sampled())\nset(da, :custom => Irregular(10, 12), Z => Regular(9.9))\nset(da, (Z=NoIndex(), custom=Sampled()))\nset(da, custom=Ordered(array=Reverse()), Z=Unordered())\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.rebuild","page":"API","title":"DimensionalData.rebuild","text":"rebuild(x, args...)\nrebuild(x; kwargs...)\n\nRebuild an object struct with updated field values. \n\nThis is an abstraction that alows inbuilt and custom types to be rebuilt  functionally to update them, as most objects in DimensionalData are immutable.\n\nx can be a AbstractDimArray, a Dimension, IndexMode or other custom types.\n\nThe arguments reuired are defined for the abstract type that has a rebuild method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.modify","page":"API","title":"DimensionalData.modify","text":"modify(f, A::AbstractDimArray) => AbstractDimArray\nmodify(f, ds::AbstractDimDataset) => AbstractDimDataset\nmodify(f, dim::Dimension) => Dimension\nmodify(f, x, lookupdim::Dimension) => typeof(x)\n\nModify the parent data, rebuilding the object wrapper without change. f must return a AbstractArray of the same size as the original.\n\nThis method is mostly useful as a way of swapping the parent array type of an object.\n\nExample\n\nIf we have a previously-defined DimArray, we can copy it to an Nvidia GPU with:\n\nA = DimArray(rand(100, 100), (X, Y))\nmodify(CuArray, A)\n\nThis also works for all the data layers in a DimDataset.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise","page":"API","title":"DimensionalData.dimwise","text":"dimwise(f, A::AbstractDimArray{T,N}, B::AbstractDimArray{T2,M}) => AbstractDimArray{T3,N}\n\nDimension-wise application of function f to A and B.\n\nArguments\n\na: AbstractDimArray to broacast from, along dimensions not in b.\nb: AbstractDimArray to broadcast from all dimensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is sliced by the dimensions of B.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise!","page":"API","title":"DimensionalData.dimwise!","text":"dimwise!(f, dest::AbstractDimArray{T1,N}, A::AbstractDimArray{T2,N}, B::AbstractDimArray) => dest\n\nDimension-wise application of function f.\n\nArguments\n\ndest: AbstractDimArray to update\na: AbstractDimArray to broacast from, along dimensions not in b.\nb: AbstractDimArray to broadcast from all dimensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is sliced by the dimensions of B, and storing the value in dest.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorder","page":"API","title":"DimensionalData.reorder","text":"reorder(::order, A::AbstractDimArray) => AbstractDimArray\nreorder(A::AbstractDimArray, order::Union{Order,Dimension{<:Order},Tuple}) => AbstractDimArray\nreorder(A::AbstractDimArray, order::Pair{<:Dimension,<:SubOrder}...) => AbstractDimArray\n\nReorder every dims index/array/relation to order, or reorder index for the the given dimension(s) to the Order they wrap.\n\nReorderind Relation will reverse the array, not the dimension index.\n\norder can be an Order, a single Dimension or a Tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.reverse","page":"API","title":"Base.reverse","text":"reverse(A; dims) => AbstractDimArray\nreverse(dim::Dimension) => Dimension\n\nReverse the array order, and update the dim to match.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-methods-for-developers","page":"API","title":"Non-exported methods for developers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.dim2key\r\nDimensionalData.key2dim\r\nDimensionalData.dims2indices\r\nDimensionalData.formatdims\r\nDimensionalData.reducedims\r\nDimensionalData.swapdims\r\nDimensionalData.slicedims\r\nDimensionalData.comparedims\r\nDimensionalData.sortdims\r\nDimensionalData.identify\r\nDimensionalData.basetypeof\r\nDimensionalData.setdims\r\nDimensionalData.flip","category":"page"},{"location":"api/#DimensionalData.dim2key","page":"API","title":"DimensionalData.dim2key","text":"dim2key(dim::Dimension) => Symbol\ndim2key(dims::Type{<:Dimension}) => Symbol\n\nConvert a dimension object to a simbol. X(), Y(), Ti() etc will be converted. to :X, :Y, :Ti, as with any other dims generated with the @dim macro.\n\nAll other Symbols S will generate Dim{S}() dimensions. \n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.key2dim","page":"API","title":"DimensionalData.key2dim","text":"key2dim(s::Symbol) => Dimension\nkey2dim(dims::Tuple) => Dimension\n\nConvert a symbol to a dimension object. :X, :Y, :Ti etc will be converted. to X(), Y(), Ti(), as with any other dims generated with the @dim macro.\n\nAll other Symbols S will generate Dim{S}() dimensions. \n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dims2indices","page":"API","title":"DimensionalData.dims2indices","text":"dims2indices(dim::Dimension, lookup, [emptyval=Colon()]) => NTuple{Union{Colon,AbstractArray,Int}}\n\nConvert a Dimension or Selector lookup to indices of Int, AbstractArray or Colon.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.formatdims","page":"API","title":"DimensionalData.formatdims","text":"formatdims(A, dims) => Tuple{Vararg{<:Dimension,N}}\n\nFormat the passed-in dimension(s) dims to match the array A.\n\nThis means converting indexes of Tuple to LinRange, and running identify. Errors are also thrown if dims don't match the array dims or size.\n\nIf a IndexMode hasn't been specified, an mode is chosen based on the type and element type of the index:\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reducedims","page":"API","title":"DimensionalData.reducedims","text":"reducedims(x, dimstoreduce)\n\nReplace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like mean or reduce to a length of 1, but the number of dimensions has not changed.\n\nIndexMode traits are also updated to correspond to the change in cell step, sampling type and order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.swapdims","page":"API","title":"DimensionalData.swapdims","text":"swapdims(x::T, newdims) => T\nswapdims(dims::Tuple, newdims) => Tuple{Dimension}\n\nSwap dimensions for the passed in dimensions, in the order passed.\n\nPassing in the Dimension types rewraps the dimension index,  keeping the index values and metadata, while constructed Dimension  objectes replace the original dimension. nothing leaves the original  dimension as-is.\n\nArguments\n\nx: any object with a dims method or a Tuple of Dimension.\nnewdim: Tuple of Dimension or dimension Type.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.slicedims","page":"API","title":"DimensionalData.slicedims","text":"slicedims(x, I) => Tuple{Tuple,Tuple}\n\nSlice the dimensions to match the axis values of the new array\n\nAll methods returns a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.\n\nCalled at the array level the returned tuple will also include the previous reference dims attached to the array.\n\nArguments\n\nx: An AbstractDimArray, Tuple of Dimension, or Dimension\nI: A tuple of Integer, Colon or AbstractArray\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.comparedims","page":"API","title":"DimensionalData.comparedims","text":"comparedims(A::AbstractDimArray...)\ncomparedims(A::Tuple...)\ncomparedims(a, b)\n\nCheck that dimensions or tuples of dimensions are the same, and return the first valid dimension. If AbstractDimArrays are passed as arguments their dimensions are compared.\n\nEmpty tuples and nothing dimension values are ignored, returning the Dimension value if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.sortdims","page":"API","title":"DimensionalData.sortdims","text":"sortdims(tosort, order) => Tuple\n\nSort dimensions tosort by order. Dimensions in order but missing from tosort are replaced with nothing.\n\ntosort and order can be Tuples or Vectors or Dimension or dimension type. Abstract supertypes like TimeDim can be used in order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.identify","page":"API","title":"DimensionalData.identify","text":"identify(indexmode, index)\n\nIdentify an IndexMode and its fields from the index content  and the existing IndexMode.\n\nThese methods guess which mode is most appropriate, encoding information about the index in types that can later be used for dispatch. They also let you fill in part of the information you need to specify, and guess the rest.\n\nAn example of the usefulness of identifying index traits up-front is if we  check that the index is ordered, we can be sure it remains ordered unless it is indexed with a Vector. This means we will always use the correct searchsorted method for it.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.basetypeof","page":"API","title":"DimensionalData.basetypeof","text":"basetypeof(x) => Type\n\nGet the \"base\" type of an object - the minimum required to define the object without it's fields. By default this is the full UnionAll for the type. But custom basetypeof methods can be defined for types with free type parameters.\n\nIn DimensionalData this is primariliy used for comparing Dimensions, where Dim{:x} is different from Dim{:y}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.setdims","page":"API","title":"DimensionalData.setdims","text":"setdims(A::AbstractArray, newdims) => AbstractArray\nsetdims(::Tuple, newdims) => Tuple{Vararg{<:Dimension,N}}\n\nReplaces the first dim matching <: basetypeof(newdim) with newdim,  and returns a new object or tuple with the dimension updated.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nnewdim: Tuple or single Dimension or dimension Type.\n\nExample\n\nusing DimensionalData\n\nA = DimArray(ones(10, 10), (X, Y(10:10:100)))\nB = setdims(A, Y('a':'j'))\nval(dims(B, Y))\n\n# output\n\n'a':1:'j'\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.flip","page":"API","title":"DimensionalData.flip","text":"fliparray(Order, A, dims) => AbstractDimArray\nfliparray(dim::Dimension) => Dimension\n\nFlip the array order without changing any data.\n\n\n\n\n\n","category":"function"},{"location":"developer/#For-package-developers","page":"For Developers","title":"For package developers","text":"","category":"section"},{"location":"developer/#Goals:","page":"For Developers","title":"Goals:","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated.\nFlexibility: dims and selectors are parametric types with multiple uses\nAbstraction: never dispatch on concrete types, maximum re-usability of methods\nClean, readable syntax. Minimise required parentheses, minimise of exported methods, and instead extend Base methods whenever possible.\nMinimal interface: implementing a dimension-aware type should be easy.\nFunctional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.\nLaziness. Label data correctly, and manipulate them when needed -  instead of standardising eagerly.\nLeast surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or dims=X in base, you should be able to use DimensionalData.jl dims.\nType stability: dimensional methods should be type stable more often than Base methods\nZero cost dimensional indexing a[Y(4), X(5)] of a single value.\nLow cost indexing for range getindex and views: these cant be zero cost as dim ranges have to be updated.\nPlotting is easy: data should plot sensibly and correctly with useful labels - after all transformations using dims or indices\nPrioritise spatial data: other use cases are a free bonus of the modular approach.","category":"page"},{"location":"developer/#Why-this-package","page":"For Developers","title":"Why this package","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Why not AxisArrays.jl or NamedDims.jl?","category":"page"},{"location":"developer/#Structure","page":"For Developers","title":"Structure","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Both AxisArrays and NamedDims use concrete types for dispatch on arrays, and for dimension type Axis in AxisArrays. This makes them hard to extend.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Its a little easier with DimensionalData.jl. You can inherit from AbstractDimArray, or just implement dims and rebuild methods. Dims and selectors in DimensionalData.jl are also extensible. Recursive primitive methods allow inserting whatever methods you want to add extra types. @generated is only used to match and permute arbitrary tuples of types, and contain no type-specific details. The @generated functions in AxisArrays internalise axis/index conversion behaviour preventing extension in external packages and scripts.","category":"page"},{"location":"developer/#Syntax","page":"For Developers","title":"Syntax","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"AxisArrays.jl is verbose by default: a[Axis{:y}(1)] vs a[Y(1)] used here. NamedDims.jl has concise syntax, but the dimensions are no longer types, NamedDims.jl syntax can now be replicated using Dim{:X}: ","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"A = Dimarray(rand(4, 5), (:a, :b)\r\nA[:b=5, :a=3] = 25.0","category":"page"},{"location":"developer/#Data-types-and-the-interface","page":"For Developers","title":"Data types and the interface","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"DimensionalData.jl provides the concrete DimArray type. But it's core purpose is to be easily used with other array types.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Some of the functionality in DimensionalData.jl will work without inheriting from AbstractDimArray. The main requirement define a dims method that returns a Tuple of Dimension that matches the dimension order and axis values of your data. Define rebuild, and base methods for similar and parent if you want the metadata to persist through transformations (see the DimArray and AbstractDimArray types). A refdims method returns the lost dimensions of a previous transformation, passed in to the rebuild method. refdims can be discarded, the main loss being plot labels.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Inheriting from AbstractDimArray will give nearly all the functionality of using DimArray.","category":"page"},{"location":"course/#Crash-course","page":"Crash course","title":"Crash course","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This is brief a tutorial for DimensionalData.jl.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The main functionality is explained here, but the full list of features is listed at the API page.","category":"page"},{"location":"course/#Dimensions-and-DimArrays","page":"Crash course","title":"Dimensions and DimArrays","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The core type of DimensionalData.jl is the Dimension and the types that inherit from it, such as Ti, X, Y, Z, the generic Dim{:x}, or others that you define manually using the @dim macro.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions are primarily used in DimArray, other AbstractDimArray.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can use dimensions without a value index - these simply label the axis. A DimArray with labelled dimensions is constructed by:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA = DimArray(rand(5, 5), (X, Y))\r\nA[Y(1), X(2)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Or we can use the Dim{X} dim by using Symbols:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A = DimArray(rand(5, 5), (:a, :b))\r\nA[a=3, b=5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"But often, we want to provide a lookup index for the dimension:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Dates\r\nt = DateTime(2001):Month(1):DateTime(2001,12)\r\nx = 10:10:100\r\nA = DimArray(rand(12, 10), (Ti(t), X(x)))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Here both X and Ti are dimensions from DimensionalData. The currently exported dimensions are X, Y, Z, Ti. Ti is shortening of Time - to avoid the conflict with Dates.Time.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The length of each dimension index has to match the size of the corresponding array axis. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This can also be done with Symbol, using Dim{X}:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A2 = DimArray(rand(12, 10), (time=t, distance=x))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Symbols can be more convenient than defining dims with @dim, but have some downsides. They don't inherit from a specific Dimension type, so plots will not know what axis to put them on. If you need to specify the dimension mode or metadata manually, the Dim{X} syntax becomes less beneficial. ","category":"page"},{"location":"course/#Indexing-the-array-by-name-and-index","page":"Crash course","title":"Indexing the array by name and index","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The simplest case is to select a dimension by index. Let's say every 2nd point of the Ti dimension and every 3rd point of the X dimension. This is done with the simple Ti(range) syntax like so:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:end), Ti(1:2:end)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Of course, when specifying only one dimension, all elements of the other dimensions are assumed to be included:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:10)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"info: Indexing\nIndexing AbstractDimArrays works with getindex, setindex! and view. The result is still an AbstracDimArray.","category":"page"},{"location":"course/#Selecting-by-name-and-value","page":"Crash course","title":"Selecting by name and value","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The above example is useful because one does not have to care about the ordering of the dimensions. But arguably more useful is to be able to select a dimension by its values. For example, we would like to get all values of A where the X dimension is between two values.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selecting by value in DimensionalData is done with the selectors, which are listed in the Selectors page. This avoids the ambiguity of what happens when the index values of the dimension are also integers (like the case here for the dimension X).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"For simplicity, here we use the Between selector, but  others also exist, like At, Contains, or Near.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(Between(12, 35)), Ti(Between(Date(2001, 5), Date(2001, 7)))]","category":"page"},{"location":"course/#Selecting-by-position","page":"Crash course","title":"Selecting by position","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"So far, the selection protocols we have mentioned work by specifying the name of the dimension, without worry about the order.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"However normal indexing also works by specifying dimensions by position. This functionality also covers Selectors.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Continuing to use A we defined above, you can see how this works by comparing the statements without and with names:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[:, Between(12, 35)] == A[X(Between(12, 35))]\r\nA[:, 1:5] == A[X(1:5)]\r\nA[1:5, :] == A[Ti(1:5)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Using this approach it is necessary to specify all dimensions by position. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In addition, to support as base Julia functionality single index access like in standard Array:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[1:5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This selects the first 5 entries of the underlying array. In the case that A has only one dimension, it will be retained. Multidimensional AbstracDimArray indexed this way will return a regular array.","category":"page"},{"location":"course/#Specifying-dims-keyword-arguments-with-Dimension","page":"Crash course","title":"Specifying dims keyword arguments with Dimension","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In many Julia functions like size or sum, you can specify the dimension along which to perform the operation as an Int. It is also possible to do this using Dimension types with AbstractDimArray:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"sum(A; dims=X)","category":"page"},{"location":"course/#Numeric-operations-on-dimension-arrays-and-dimensions","page":"Crash course","title":"Numeric operations on dimension arrays and dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Numeric operations on a AbstractDimArray match base Julia as much as possible. Standard broadcasting and other type of operations across dimensional arrays typically perform as expected while still returning an AbstractDimArray type with correct dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In cases where you would like to do some operation on the dimension index, e.g. take the cosines of the values of the dimension X while still keeping the dimensional information of X, you can use the syntax:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimArray(cos, dims(A, X))","category":"page"},{"location":"course/#Referenced-dimensions","page":"Crash course","title":"Referenced dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes.","category":"page"},{"location":"course/#IndexMode","page":"Crash course","title":"IndexMode","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimensionalData provides types for specifying details about the dimension index. This enables optimisations with Selectors, and modified behaviours such as selection of intervals or points, which will give slightly different results for selectors like Between for Points and Intervals.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"It also allows plots to always be the right way up when either the index or the  array is backwards - reverseing the data lazily when required for plotting if reqiured, not when loaded.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The major categories of IndexMode are Categorical, Sampled and NoIndex, which are all subtypes of Aligned. Unaligned also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as Transformed. These are a work in progress.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Aligned types will be detected automatically if not specified. A Dimension containing and index of String, Char or Symbol will be given the Categorical mode. A range will be Sampled, defaulting to Points and Regular, with the Order detected automatically. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"See the api docs for specifics about these IndexModes.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions. It's a pluggable, generalised version of AxisArrays.jl with a cleaner syntax, and additional functionality found in NamedDims.jl. It has similar goals to pythons xarray, and is primarily written for use with spatial data in GeoData.jl.\n\nDimensions\n\nDimensions are just wrapper types. They store the dimension index and define details about the grid and other metadata, and are also used to index into the array, wrapping a value or a Selector. X, Y, Z and Ti are the exported defaults.\n\nA generalised Dim type is available to use arbitrary symbols to name dimensions. Custom dimensions can be defined using the @dim macro.\n\nWe can use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:\n\njulia> using DimensionalData\n\njulia> A = DimArray(rand(40, 50), (X, Y));\n\njulia> A[Y(1), X(1:10)]\nDimArray with dimensions:\n X: 1:10 (NoIndex)\nand referenced dimensions:\n Y: 1 (NoIndex)\nand data: 10-element Array{Float64,1}\n[0.515774, 0.575247, 0.429075, 0.234041, 0.4484, 0.302562, 0.911098, 0.541537, 0.267234, 0.370663]\n\nAnd this has no runtime cost:\n\njulia> using BenchmarkTools\n\njulia> @btime A[X(1), Y(2)]\n  25.068 ns (1 allocation: 16 bytes)\n0.7302366320496405\n\njulia> @btime parent(A)[1, 2]\n  34.061 ns (1 allocation: 16 bytes)\n0.7302366320496405\n\nDims can be used for indexing and views without knowing dimension order:\n\nA[X(10)]\nview(A, Y(30:40), X(1:20))\n\nAnd for indicating dimensions to reduce or permute in julia Base and Statistics functions that have dims arguments:\n\nusing Statistics\n\nA = DimArray(rand(10, 10, 100), (X, Y, Ti));\nmean(A, dims=Ti)\npermutedims(A, [Ti, Y, X])\n\nYou can also use arbitrary symbol to create Dim{X} dimensions:\n\njulia> A = DimArray(rand(10, 20, 30), (:a, :b, :c));\n\njulia> A[a=2:5, c=9]\n\nDimArray with dimensions:\n Dim{:a}: 2:5 (NoIndex)\n Dim{:b}: Base.OneTo(20) (NoIndex)\nand referenced dimensions:\n Dim{:c}: 9 (NoIndex)\nand data: 4×20 Array{Float64,2}\n 0.868237   0.528297   0.32389   …  0.89322   0.6776    0.604891\n 0.635544   0.0526766  0.965727     0.50829   0.661853  0.410173\n 0.732377   0.990363   0.728461     0.610426  0.283663  0.00224321\n 0.0849853  0.554705   0.594263     0.217618  0.198165  0.661853\n\nOther methods also work:\n\njulia> bounds(A, (:b, :c))\n\n((1, 20), (1, 30))\n\njulia> mean(A, dim=Dim{:b})\n\njulia> mean(A, dims=Dim{:b})\nDimArray with dimensions:\n Dim{:a}: Base.OneTo(10) (NoIndex)\n Dim{:b}: 1 (NoIndex)\n Dim{:c}: Base.OneTo(30) (NoIndex)\nand data: 10×1×30 Array{Float64,3}\n[:, :, 1]\n 0.543099\n 0.542407\n 0.540647\n 0.513554\n 0.601689\n 0.601558\n 0.46997\n 0.524254\n 0.601844\n 0.520966\n[and 29 more slices...]\n\nSelectors\n\nSelectors find indices in the dimension based on values At, Near, or Between the index value(s). They can be used in getindex, setindex! and view to select indices matching the passed in value(s)\n\nAt(x): get indices exactly matching the passed in value(s)\nNear(x): get the closest indices to the passed in value(s)\nWhere(f::Function): filter the array axis by a function of dimension index values.\nBetween(a, b): get all indices between two values (inclusive)\nContains(x): get indices where the value x falls in the interval. Only used for Sampled Intervals, for Points us At.\n\nWe can use selectors with dim wrappers:\n\nA[X(Between(1, 10)), Y(At(25.7))]\n\nWithout dim wrappers selectors must be in the right order:\n\nusing Unitful\n\njulia> A = DimArray(rand(10, 20), (X((1:10:100)u\"m\"), Ti((1:5:100)u\"s\")))\n\njulia> A[Between(10.5u\"m\", 50.5u\"m\"), Near(23u\"s\")]\nDimArray with dimensions:\n X: (11:10:41) m (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Time (type Ti): 21 s (Sampled: Ordered Regular Points)\nand data: 4-element Array{Float64,1}\n[0.819172, 0.418113, 0.461722, 0.379877]\n\nFor values other than Int/AbstractArray/Colon (which are set aside for regular indexing) the At selector is assumed, and can be dropped completely:\n\njulia> A = DimArray(rand(3, 3), (X(Val((:a, :b, :c))), Y([25.6, 25.7, 25.8])))\nDimArray with dimensions:\n X: Val{(:a, :b, :c)}()\n Y: Float64[25.6, 25.7, 25.8]\nand data: 3×3 Array{Float64,2}\n 0.280308  0.92255    0.023938\n 0.129487  0.0993857  0.618391\n 0.246378  0.276186   0.0425624\n\njulia> A[:b, 25.8]\n0.61839141062599\n\nUsing all Val indexes (only recommended for small arrays) you can index with named dimensions At arbitrary values with no runtime cost:\n\nusing BenchmarkTools\n\njulia> A = DimArray(rand(3, 3), (cat=Val((:a, :b, :c)),\n                                 val=Val((5.0, 6.0, 7.0))))\nDimArray with dimensions:\n Dim{:cat}: Val{(:a, :b, :c)}() (Categorical: Unordered)\n Dim{:val}: Val{(5.0, 6.0, 7.0)}() (Categorical: Unordered)\nand data: 3×3 Array{Float64,2}\n 0.993357  0.765515  0.914423\n 0.405196  0.98223   0.330779\n 0.365312  0.388873  0.88732\n\njulia> @btime A[:a, 7.0]\n  26.333 ns (1 allocation: 16 bytes)\n0.32927504968939925\n\njulia> @btime A[cat=:a, val=7.0]\n  31.920 ns (2 allocations: 48 bytes)\n0.7476441117572306\n\nIt's also easy to write your own custom Selector if your need a different behaviour.\n\nExample usage:\n\nusing Dates, DimensionalData\ntimespan = DateTime(2001,1):Month(1):DateTime(2001,12)\nA = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))\n\njulia> A[X(Near(35)), Ti(At(DateTime(2001,5)))]\n0.658404535807791\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)]\nDimArray with dimensions:\n X: 20:10:50\nand referenced dimensions:\n Time (type Ti): 2001-05-01T00:00:00\nand data: 4-element Array{Float64,1}\n[0.456175, 0.737336, 0.658405, 0.520152]\n\nDim types or objects can be used instead of a dimension number in many Base and Statistics methods:\n\nMethods where dims can be used containing indices or Selectors\n\ngetindex, setindex! view\n\nMethods where dims can be used\n\nsize, axes, firstindex, lastindex\ncat\nreverse\ndropdims\nreduce, mapreduce\nsum, prod, maximum, minimum,\nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice\nfill\n\nExample usage:\n\nA = DimArray(rand(20,10), (X, Y))\nsize(A, Y)\nusing Statistics\nmean(A, dims=X)\nstd(A; dims=Y())\n\nWarnings\n\nIndexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break searchsorted and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it's allowed. But it will still do strange things to your interval sizes if the dimension span is Irregular.\n\nAlternate Packages\n\nThere are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.\n\nAxisRanges.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn how to use this package, see the Crash course.","category":"page"}]
}
