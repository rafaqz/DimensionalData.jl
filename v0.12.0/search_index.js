var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To use the functionality of DimensionalData in your module, dispatch on AbstractDimArray and AbstractDimension.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Arrays:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractDimArray\r\nDimArray","category":"page"},{"location":"api/#DimensionalData.AbstractDimArray","page":"API","title":"DimensionalData.AbstractDimArray","text":"Supertype for all \"dim\" arrays.\n\nThese arrays return a Tuple of Dimension  from a dims method, and can be rebuilt using rebuild.\n\nparent must return the source array.\n\nThey should have metadata, name and refdims  methods, although these are optional. \n\nA rebuild method for AbstractDimArray must accept  data, dims, refdims, name, metadata arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimArray","page":"API","title":"DimensionalData.DimArray","text":"DimArray(data, dims, refdims, name)\n\nThe main subtype of AbstractDimArray. Maintains and updates its dimensions through transformations and moves dimensions to refdims after reducing operations (like e.g. mean).\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-types","page":"API","title":"Core types","text":"","category":"section"},{"location":"api/#Dimensions:","page":"API","title":"Dimensions:","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Dimension\r\nDependentDim\r\nIndependentDim\r\nXDim\r\nYDim\r\nZDim\r\nTimeDim\r\nX\r\nY\r\nZ\r\nTi\r\nParametricDimension\r\nDim\r\nAnonDim\r\n@dim","category":"page"},{"location":"api/#DimensionalData.Dimension","page":"API","title":"DimensionalData.Dimension","text":"Supertype of all dimension types.\n\nExample concrete implementations are X, Y, Z,  Ti (Time), and the custom [Dim]@ref) dimension.\n\nDimensions label the axes of an AbstractDimesnionalArray,  or other dimensional objects, and are used to index into the array.\n\nThey may also provide an alternate index to lookup for each array axis. This may be any AbstractVector matching the array axis length, or a Val holding a tuple for compile-time index lookups.\n\nDimensions also have mode and metadata fields. \n\nmode gives more details about the dimension, such as that it is  Categorical or Sampled as Points or  Intervals along some transect. DimensionalData will attempt to guess the mode from the passed-in index value.\n\nmetadata can hold any metadata object adding more information about  the array axis - useful for extending DimensionalData for specific  contexts, like geospatial data in GeoData.jl. By default it is nothing.\n\nExample:\n\nusing DimensionalData, Dates\n\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimArray(zeros(3, 5, 12), (y, x, ti))\n\n# output\n\nDimArray with dimensions:\n Y: Char[a, b, c] (Categorical: Unordered)\n X: 2:2:10 (Sampled: Ordered Regular Points)\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand data: 3×5×12 Array{Float64,3}\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n[and 11 more slices...]\n\nFor simplicity, the same Dimension types are also used as wrappers  in getindex, like:\n\nx = A[X(2), Y(3)]\n\n# output\n\nDimArray with dimensions:\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Y: c (Categorical: Unordered)\n X: 4 (Sampled: Ordered Regular Points)\nand data: 12-element Array{Float64,1}\n[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\nA Dimension can also wrap Selector.\n\nx = A[X(Between(3, 4)), Y(At('b'))]\n\n# output\n\nDimArray with dimensions:\n X: 4:2:4 (Sampled: Ordered Regular Points)\n Time (type Ti): DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Y: b (Categorical: Unordered)\nand data: 1×12 Array{Float64,2}\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\nDimension objects may have mode and metadata fields to track additional information about the data and the index, and their relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DependentDim","page":"API","title":"DimensionalData.DependentDim","text":"Supertype for Dependent dimensions. These will plot on the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndependentDim","page":"API","title":"DimensionalData.IndependentDim","text":"Supertype for independent dimensions. Thise will plot on the X axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.XDim","page":"API","title":"DimensionalData.XDim","text":"Supertype for all X dimensions. \n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.YDim","page":"API","title":"DimensionalData.YDim","text":"Supertype for all Y dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ZDim","page":"API","title":"DimensionalData.ZDim","text":"Supertype for all Z dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.TimeDim","page":"API","title":"DimensionalData.TimeDim","text":"Supertype for all time dimensions.\n\nIn a TimeDime with Interval sampling the locus will automatically  be set to Start(). Dates and times generally refer to the start of a  month, hour, second etc., not the central point as is more common with spatial data. `\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.X","page":"API","title":"DimensionalData.X","text":"X(val=:; mode=AutoMode(), metadata=nothing)\n\nX Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nxdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Y","page":"API","title":"DimensionalData.Y","text":"Y(val=:; mode=AutoMode(), metadata=nothing)\n\nY Dimension. Y <: YDim <: DependentDim\n\nExample:\n\nydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Z","page":"API","title":"DimensionalData.Z","text":"Z(val=:; mode=AutoMode(), metadata=nothing)\n\nZ Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nzdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ti","page":"API","title":"DimensionalData.Ti","text":"Ti(val=:; mode=AutoMode(), metadata=nothing)\n\nTime Dimension. Ti <: TimeDim <: IndependentDim\n\nTime is already used by Dates, and T is a common type parameter,  We use Ti to avoid clashes.\n\nExample:\n\ntimedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n# Or\nval = A[Ti(1)]\n# Or\nmean(A; dims=Ti)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ParametricDimension","page":"API","title":"DimensionalData.ParametricDimension","text":"Supertype for Dimensions with user-set type paremeters\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dim","page":"API","title":"DimensionalData.Dim","text":"Dim{:X}()\nDim{:X}(val=:; mode=AutoMode(), metadata=nothing)\nDim{:X}(val, mode, metadata=nothing)\n\nA generic dimension. For use when custom dims are required when loading data from a file. The sintax is ugly and verbose to use for indexing, ie Dim{:lat}(1:9) rather than Lat(1:9). This is the main reason they are not the only type of dimension availabile.\n\nusing DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\ndimension Dim{:custom} (type Dim):\nval: Char[a, b, c]\nmode: AutoMode\nmetadata: nothing\ntype: Dim{:custom,Array{Char,1},AutoMode{AutoOrder},Nothing}\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AnonDim","page":"API","title":"DimensionalData.AnonDim","text":"AnonDim()\n\nAnonymous dimension. Used when extra dimensions are created,  such as during transpose of a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.@dim","page":"API","title":"DimensionalData.@dim","text":"@dim typ [supertype=Dimension] [name=string(typ)] [shortname=string(typ)]\n\nMacro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply YourDim <: Dimension. Making a Dimesion inherit from XDim, YDim, ZDim or TimeDim will affect  automatic plot layout and other methods that dispatch on these types. <: YDim are plotted on the Y axis, <: XDim on the X axis, etc.\n\nExample:\n\n@dim Lat \"Lattitude\" \"lat\"\n@dim Lon XDim \"Longitude\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#Selectors","page":"API","title":"Selectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Selector\r\nAt\r\nNear\r\nBetween\r\nContains\r\nWhere","category":"page"},{"location":"api/#DimensionalData.Selector","page":"API","title":"DimensionalData.Selector","text":"Selectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as DateTime objects for a Ti dimension.\n\nSelectors provided in DimensionalData are:\n\nAt\nBetween\nNear\nWhere\nContains\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.At","page":"API","title":"DimensionalData.At","text":"At(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Near","page":"API","title":"DimensionalData.Near","text":"Near(x)\n\nSelector that selects the nearest index to x.\n\nWith Points this is simply the index values nearest to the x, however with Intervals it is the interval center nearest to x. This will be offset from the index value for Start and End loci.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n\n4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Between","page":"API","title":"DimensionalData.Between","text":"Between(a, b)\n\nSelector that retreive all indices located between 2 values, evaluated with >= for the lower value, and < for the upper value. This means the same value will not be counted twice in 2 Between selections.\n\nFor Intervals the whole interval must be lie between the values. For Points the points must fall between the values. Different Sampling types may give different results with the same input - this is the intended behaviour.\n\nBetween for Irregular intervals is a little complicated. The interval is the distance between a value and the next (for Start locus) or previous (for End locus) value.\n\nFor Center, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use Between with Irregular Intervals(Center()) with caution.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Between(15, 25)), Y(Between(4, 6.5))]\n\n# output\n\nDimArray with dimensions:\n X: 20:10:20 (Sampled: Ordered Regular Points)\n Y: 5:6 (Sampled: Ordered Regular Points)\nand data: 1×2 Array{Int64,2}\n 4  5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Contains","page":"API","title":"DimensionalData.Contains","text":"Contains(x)\n\nSelector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.\n\nCan only be used for Intervals or Categorical.\n\nExample\n\nusing DimensionalData\n\ndims_ = X(10:10:20; mode=Sampled(sampling=Intervals())),\n        Y(5:7; mode=Sampled(sampling=Intervals()))\nA = DimArray([1 2 3; 4 5 6], dims_)\nA[X(Contains(8)), Y(Contains(6.8))]\n\n# output\n\n3\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Where","page":"API","title":"DimensionalData.Where","text":"Where(f::Function)\n\nSelector that filters a dimension by any function that accepts a single value from the index and returns a Bool.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))\nA[X(Where(x -> x > 15)), Y(Where(x -> x in (19, 21)))]\n\n# output\n\nDimArray with dimensions:\n X: Int64[20] (Sampled: Ordered Regular Points)\n Y: Int64[19, 21] (Sampled: Ordered Regular Points)\nand data: 1×2 Array{Int64,2}\n 4  6\n\n\n\n\n\n","category":"type"},{"location":"api/#Index-Modes","page":"API","title":"Index Modes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"IndexMode\r\nAligned\r\nAbstractSampled\r\nSampled\r\nAbstractCategorical\r\nCategorical\r\nUnaligned\r\nTransformed\r\nNoIndex\r\nAutoMode","category":"page"},{"location":"api/#DimensionalData.IndexMode","page":"API","title":"DimensionalData.IndexMode","text":"Types defining the behaviour of a dimension, how they are plotted and how Selectors like Between work on them.\n\nAn IndexMode may be a simple type like NoIndex indicating that the index is just the underlying array axis. It could also be a Categorical index indicating the index is ordered or unordered categories, or a Sampled index indicating sampling along some transect.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Aligned","page":"API","title":"DimensionalData.Aligned","text":"Supertype for IndexModes where the index is aligned with the array axes. This is by far the most common case.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractSampled","page":"API","title":"DimensionalData.AbstractSampled","text":"Abstract supertype for IndexModes where the index is aligned with the array, and is independent of other dimensions. Sampled is provided by this package, Projected in GeoData.jl also extends AbstractSampled, adding crs projections.\n\nA rebuild method for AbstractSampled must accept order, span  and sampling, arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Sampled","page":"API","title":"DimensionalData.Sampled","text":"Sampled(order::Order, span::Span, sampling::Sampling)\nSampled(; order=AutoOrder(), span=AutoSpan(), sampling=Points())\n\nA concrete implementation of the IndexMode AbstractSampled. It can be used to represent Points or Intervals.\n\nIt is capable of representing gridded data from a wide range of sources, allowing correct bounds and Selectors for points or intervals of regular, irregular, forward and reverse indexes.\n\nThe Sampled mode is assigned for all indexes of AbstractRange  not assigned to Categorical.\n\nFields\n\norder indicating array and index order (in Order), detected from the range order.\nspan indicates the size of intervals or distance between points, and will be set to  Regular for AbstractRange and Irregular for AbstractArray,  unless assigned manually.\nsampling is assigned to Points, unless set to Intervals manually. Using Intervals will change the behaviour of bounds and Selectorss to take account for the full size of the interval, rather than the point alone.\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\ndims_ = (X(100:-10:10; mode=Sampled(sampling=Intervals())),\n         Y([1, 4, 7, 10]; mode=Sampled(span=Regular(2), sampling=Intervals())))\nA = DimArray(rand(10, 4), dims_)\nmap(mode, dims(A))\n\n# output\n\n(Sampled: Ordered Regular Intervals, Sampled: Ordered Regular Intervals)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractCategorical","page":"API","title":"DimensionalData.AbstractCategorical","text":"IndexModes for dimensions where the values are categories.\n\nCategorical is the provided concrete implementation.\n\nA rebuild method for AbstractCategorical must accept the order argumen.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Categorical","page":"API","title":"DimensionalData.Categorical","text":"Categorical(o::Order)\nCategorical(; order=Unordered())\n\nAn IndexMode where the values are categories.\n\nThis will be automatically assigned if the index contains AbstractString, Symbol or Char. Otherwise it can be assigned manually.\n\nOrder will not be determined automatically for Categorical, it instead defaults to [Unordered].\n\nFields\n\norder: Order indicating array and index order.\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\ndims_ = X([\"one\", \"two\", \"thee\"]), Y([:a, :b, :c, :d])\nA = DimArray(rand(3, 4), dims_)\nmap(mode, dims(A))\n\n# output\n\n(Categorical: Unordered, Categorical: Unordered)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unaligned","page":"API","title":"DimensionalData.Unaligned","text":"Supertype for IndexMode where the Dimension index is not aligned to the grid.\n\nIndexing with an Unaligned dimension with Selectors must provide all other Unaligned dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Transformed","page":"API","title":"DimensionalData.Transformed","text":"Transformed(f, dim::Dimension)\n\nIndexMode that uses an affine transformation to convert dimensions from dims(mode) to dims(array). This can be useful when the dimensions are e.g. rotated from a more commonly used axis.\n\nAny function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.\n\nFields\n\nf: transformation function\ndims: a tuple containing dimenension types or symbols matching the order needed by the transform function.\n\nExample\n\nusing DimensionalData, CoordinateTransformations\n\nm = LinearMap([0.5 0.0; 0.0 0.5])\nA = [1 2  3  4\n     5 6  7  8\n     9 10 11 12];\ndimz = Dim{:t1}(mode=Transformed(m, X)),\n              Dim{:t2}(mode=Transformed(m, Y))\nda = DimArray(A, dimz)\n\nda[X(At(6)), Y(At(2))]\n\n# output\n\n9\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoIndex","page":"API","title":"DimensionalData.NoIndex","text":"NoIndex()\n\nAn IndexMode that is identical to the array axis.\n\nExample\n\nDefining a DimArray without passing an index to the dimension, the IndexMode will be NoIndex:\n\nusing DimensionalData\n\nA = DimArray(rand(3, 3), (X, Y))\nmap(mode, dims(A))\n\n# output\n\n(NoIndex, NoIndex)\n\nIs identical to:\n\nA = DimArray(rand(3, 3), (X(; mode=NoIndex()), Y(; mode=NoIndex())))\nmap(mode, dims(A))\n\n# output\n\n(NoIndex, NoIndex)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoMode","page":"API","title":"DimensionalData.AutoMode","text":"AutoMode()\n\nAutomatic IndexMode, the default mode. It will be converted automatically  to another IndexMode when it is possible to detect it from the index.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Order of arrays and indices:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Order\r\nUnordered\r\nOrdered\r\nAutoOrder\r\nUnknownOrder\r\nDimensionalData.Forward\r\nDimensionalData.Reverse","category":"page"},{"location":"api/#DimensionalData.Order","page":"API","title":"DimensionalData.Order","text":"Traits for the order of the array, index and the relation between them.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unordered","page":"API","title":"DimensionalData.Unordered","text":"Unordered(relation=Forward())\n\nTrait indicating that the array or dimension has no order. This means the index cannot be searched with searchsortedfirst, or similar methods, and that plotting order does not matter. \n\nIt still has a relation between the array axis and the dimension index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ordered","page":"API","title":"DimensionalData.Ordered","text":"Ordered(index, array, relation)\nOrdered(; index=Forward(), array=Forward(), relation=Forward())\n\nContainer object for dimension and array ordering.\n\nFields\n\nEach can have a value of  Forward or Reverse.\n\nindex: The order of the dimension index\narray: The order of array axis, in terms of how you would want to plot it\nrelation: The relation between the index and the array.\n\nAll combinations of forward and reverse order for data and index seem to occurr in real datasets, as strange as that seems. We cover these possibilities by specifying the order of both explicitly, and the direction of the relationship between them.\n\nKnowing the order of indices is important for using methods like searchsortedfirst() to find indices in sorted lists of values. Knowing the order of the data is then required to map to the actual indices. It's also used to plot the data later.\n\nThe default is Ordered(Forward(), Forward(), Forward())\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoOrder","page":"API","title":"DimensionalData.AutoOrder","text":"AutoOrder()\n\nOrder will be found automatically where possible.\n\nThis will fail for all dim eltypes without isless methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.UnknownOrder","page":"API","title":"DimensionalData.UnknownOrder","text":"UnknownOrder()\n\nOrder is not known and can't be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Forward","page":"API","title":"DimensionalData.Forward","text":"Forward()\n\nIndicates that the array axis, dimension index or the relation between them is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Reverse","page":"API","title":"DimensionalData.Reverse","text":"Reverse()\n\nIndicates that the array axis, dimension index or the relation between them is in reverse order.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Index modes for Intervals","category":"page"},{"location":"api/#Span","page":"API","title":"Span","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Span\r\nRegular\r\nIrregular\r\nAutoSpan","category":"page"},{"location":"api/#DimensionalData.Span","page":"API","title":"DimensionalData.Span","text":"Defines the type of span used in a Sampling index. These are Regular or Irregular.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Regular","page":"API","title":"DimensionalData.Regular","text":"Regular(step=AutoStep())\n\nIntervalss have regular size. This is passed to the constructor, although these are normally build automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Irregular","page":"API","title":"DimensionalData.Irregular","text":"Irregular(bounds::Tuple)\nIrregular(lowerbound, upperbound)\n\nIrregular have irrigular size. To enable bounds tracking and accuract selectors, the starting bounds must be provided as a 2 tuple, or 2 arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoSpan","page":"API","title":"DimensionalData.AutoSpan","text":"AutoSpan()\n\nSpan will be guessed and replaced by a constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Sampling\r\nPoints\r\nIntervals","category":"page"},{"location":"api/#DimensionalData.Sampling","page":"API","title":"DimensionalData.Sampling","text":"Indicates the sampling method used by the index: Points or Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Points","page":"API","title":"DimensionalData.Points","text":"Points()\n\nSampling mode where single samples at exact points.\n\nThese are always plotted at the center of array cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Intervals","page":"API","title":"DimensionalData.Intervals","text":"Intervals(locus::Locus)\n\nSampling mode where samples are the mean (or similar)  value over an interval.\n\nIntervals require a Locus of Start, Center or End  to define where in the interval the index values refer to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Loci","page":"API","title":"Loci","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Sampling positions for Intervals","category":"page"},{"location":"api/","page":"API","title":"API","text":"Locus\r\nCenter\r\nStart\r\nEnd\r\nAutoLocus","category":"page"},{"location":"api/#DimensionalData.Locus","page":"API","title":"DimensionalData.Locus","text":"Locii indicate the position of index values in cells.\n\nThese allow for values array cells to align with the Start,  Center, or End of values in the dimension index. \n\nThis means they can be plotted with correct axis markers, and allows automatic  converrsions to between formats with different standards (such as NetCDF and GeoTiff).\n\nLocii are often Start for time series, but often Center for spatial data.\n\nThese are reflected in the default values: Ti dimensions with Sampled index mode will default to Start Locii. All others default to Center.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Center","page":"API","title":"DimensionalData.Center","text":"Center()\n\nIndicates a dimension value is for the center of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Start","page":"API","title":"DimensionalData.Start","text":"Start()\n\nIndicates a dimension value is for the start of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.End","page":"API","title":"DimensionalData.End","text":"End()\n\nIndicates a dimension value is for the end of its corresponding array cell, in the direction of the dimension index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoLocus","page":"API","title":"DimensionalData.AutoLocus","text":"AutoLocus()\n\nIndicates a dimension where the index position is not yet known. This will be filled with a default on object construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#Getting-basic-info","page":"API","title":"Getting basic info","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These useful functions for obtaining information from your dimensional data:","category":"page"},{"location":"api/","page":"API","title":"API","text":"bounds\r\ndata\r\ndimnum\r\ndims\r\nhasdim\r\notherdims\r\ncommondims\r\nlabel\r\nmode\r\nmetadata\r\nname\r\nrefdims\r\nshortname\r\nunits\r\nval\r\nbasetypeof","category":"page"},{"location":"api/#DimensionalData.bounds","page":"API","title":"DimensionalData.bounds","text":"bounds(dim::Dimension) => Tuple{T,T}}\nbounds(dims::Tuple{<:Dimension,Vararg}) => Tuple{Vararg{<:Tuple{T,T}}}\nbounds(A::AbstractArray, [dims]) => Tuple{Vararg{Tuple{T,T},N}}\nbounds(A::AbstractArray, dim) => Tuple{T,T}\n\nReturn the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimnum","page":"API","title":"DimensionalData.dimnum","text":"dimnum(x, lookup::Tuple) => NTuple{Int}\ndimnum(x, lookup) => Int\n\nGet the number(s) of Dimension(s) as ordered in the dimensions of an object.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple, Array or single Dimension or dimension Type.\n\nThe return type will be a Tuple of Int or a single Int, depending on wether lookup is a Tuple or single Dimension.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dims","page":"API","title":"DimensionalData.dims","text":"dims(x) => Tuple{Vararg{<:Dimension}}\ndims(x, dims::Tuple) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension\n\nReturn a tuple of Dimensions for an object, in the order that matches  the axes or columns etc. of the underlying data.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nThe default is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.hasdim","page":"API","title":"DimensionalData.hasdim","text":"hasdim(x, lookup::Tuple) => NTUple{Bool}\nhasdim(x, lookup) => Bool\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nCheck if an object or tuple contains an Dimension, or a tuple of dimensions.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.otherdims","page":"API","title":"DimensionalData.otherdims","text":"otherdims(x, lookup) => Tuple{Vararg{<:Dimension,N}}\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nA tuple holding the unmatched dimensions is always returned.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.commondims","page":"API","title":"DimensionalData.commondims","text":"commondims(x, lookup) => Tuple{Vararg{<:Dimension}}\n\nThis is basically dims(x, lookup) where the order of the original is kept,  unlike dims where the lookup tuple determines the order\n\nAlso unlike dims,commondims always returns a Tuple, no matter the input.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.label","page":"API","title":"DimensionalData.label","text":"label(x) => String\nlabel(dims::NTuple{N,<:Dimension}) => NTuple{N,String}\nlabel(A::AbstractDimArray, dims::NTuple{N,<:Dimension}) => NTuple{N,String}\n\nGet a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.mode","page":"API","title":"DimensionalData.mode","text":"mode(dim:Dimension) => IndexMode \nmode(dims::Tuple) => Tuple{Vararg{<:IndexMode,N}}\nmode(A::AbstractDimArray, [dims::Tuple]) => Tuple\n\nReturns the IndexMode of a dimension. This dictates properties of the dimension such as array axis and index order,  and sampling properties.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.metadata","page":"API","title":"DimensionalData.metadata","text":"metadata(dim::Dimension)\nmetadata(dims::Tuple{<:Dimension,Vararg})\nmetadata(A::AbstractDimArray, dims::Tuple)  => (Dim metadata)\nmetadata(A::AbstractDimArray) => (Array metadata)\n\nReturns the metadata for an array or the specified dimension(s). dims can be a Symbol (with Dim{X}, a Dimension, a Dimension type,  or a mixed tuple.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.name","page":"API","title":"DimensionalData.name","text":"name(x) => String\nname(xs::NTuple{N,<:Dimension}) => NTuple{N,String}\nname(A::AbstractDimArray, dims::NTuple{N}) => NTuple{N,String}\n\nGet the name of an array or Dimension, or a tuple of of either.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims","page":"API","title":"DimensionalData.refdims","text":"refdims(x) => Tuple{Vararg{<:Dimension}}\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some  captions empty.\n\nThe default is to return an empty Tuple ().\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.shortname","page":"API","title":"DimensionalData.shortname","text":"shortname(x) => String\nshortname(xs::NTuple{N}) => NTuple{N,String}\nshortname(A::AbstractDimArray, dims::NTuple{N}) => NTuple{N,String}\n\nGet the shortname of an array or Dimension, or a tuple of of either.\n\nThis may be a shorter version more suitable for small labels than  name, but it may also be identical to name.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.units","page":"API","title":"DimensionalData.units","text":"units(x) => Union{Nothing,Any}\nunits(::NTuple{N}) => NTuple{N}\nunit(A::AbstractDimArray, dims::NTuple{N}) => NTuple{N,String}\n\nGet the units of an array or Dimension, or a tuple of of either.\n\nUnits do not have a set field, and may or may not be included in metadata. This method is to facilitate use in labels and plots when units are available,  not a guarantee that they will be. If not available, nothing is returned.\n\ndims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.val","page":"API","title":"DimensionalData.val","text":"val(x)\nval(dims::Tuple) => Tuple\nval(A::AbstractDimArray, dims::Tuple)  => Tuple\n\nReturn the contained value of a wrapper object.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nObjects that don't define a val method are returned unaltered.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"And some utility methods for transforming DimensionalData objects:","category":"page"},{"location":"api/","page":"API","title":"API","text":"rebuild\r\nmodify\r\ndimwise\r\ndimwise!\r\nsetdims\r\nswapdims\r\nreorderindex\r\nreorderarray\r\nreorderrelation\r\nreverseindex\r\nreversearray\r\nflipindex\r\nfliparray\r\nfliprelation","category":"page"},{"location":"api/#DimensionalData.rebuild","page":"API","title":"DimensionalData.rebuild","text":"rebuild(x, args...)\nrebuild(x; kwargs...)\n\nRebuild an object struct with updated field values. \n\nThis is an abstraction that alows inbuilt and custom types to be rebuilt  functionally to update them, as most objects in DimensionalData are immutable.\n\nx can be a AbstractDimArray, a Dimension, IndexMode or other custom types.\n\nThe arguments reuired are defined for the abstract type that has a rebuild method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.modify","page":"API","title":"DimensionalData.modify","text":"modify(f, A::AbstractDimArray) => AbstractDimArray\n\nModify the parent data, rebuilding the AbstractDimArray wrapper without change. f must return a AbstractArray of the same size as the original.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise","page":"API","title":"DimensionalData.dimwise","text":"dimwise(f, A::AbstractDimArray{T,N}, B::AbstractDimArray{T2,M) => AbstractDimArray{T3,N}\n\nDimension-wise application of function f to A and B. \n\nArguments\n\n-a: AbstractDimArray to broacast from, along dimensions not in b. -b: AbstractDimArray to broadcast from all diensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is  sliced by the dimensions of B, and storing the value in dest.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimwise!","page":"API","title":"DimensionalData.dimwise!","text":"dimwise!(f, dest::AbstractDimArray{T1,N}, A::AbstractDimArray{T2,N}, B::AbstractDimArray) => dest\n\nDimension-wise application of function f. \n\nArguments\n\n-dest: AbstractDimArray to update -a: AbstractDimArray to broacast from, along dimensions not in b. -b: AbstractDimArray to broadcast from all diensions. Dimensions must be a subset of a.\n\nThis is like broadcasting over every slice of A if it is  sliced by the dimensions of B, and storing the value in dest.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.setdims","page":"API","title":"DimensionalData.setdims","text":"setdims(A::AbstractArray, newdims) => AbstractArray\nsetdims(::Tuple, newdims) => Tuple{Vararg{<:Dimension,N}}\nsetdims(dim::Dimension, newdims) => Dimension\n\nReplaces the first dim matching <: basetypeof(newdim) with newdim,  and returns a new object or tuple with the dimension updated.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nnewdim: Tuple or single Dimension or dimension Type.\n\nExample\n\nusing DimensionalData\n\nA = DimArray(ones(10, 10), (X, Y(10:10:100)))\nB = setdims(A, Y('a':'j'))\nval(dims(B, Y))\n\n# output\n\n'a':1:'j'\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.swapdims","page":"API","title":"DimensionalData.swapdims","text":"swapdims(x::T, newdims) => T\nswapdims(dims::Tuple, newdims) => Tuple{Dimension}\n\nSwap dimensions for the passed in dimensions, in the order passed.\n\nPassing in the Dimension types rewraps the dimension index,  keeping the index values and metadata, while constructed Dimension  objectes replace the original dimension. nothing leaves the original  dimension as-is.\n\nArguments\n\nx: any object with a dims method or a Tuple of Dimension.\nnewdim: Tuple of Dimension or dimension Type.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorderindex","page":"API","title":"DimensionalData.reorderindex","text":"reorderindex(A, order::Union{Order,Dimension{<:Order},Tuple})\n\nReorder every dims index to order, or reorder index for  the the given dimension(s) to the Order they wrap.\n\norder can be an Order, a single Dimension  or a Tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorderarray","page":"API","title":"DimensionalData.reorderarray","text":"reorderarray(A, order::Union{Order,Dimension{<:Order},Tuple})\n\nReorder the array to order for every axis, or reorder array  for the the given dimension(s) to the Order they wrap.\n\norder can be an Order, a single Dimension  or a Tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorderrelation","page":"API","title":"DimensionalData.reorderrelation","text":"reorderrelation(A, order::Union{Order,Dimension{<:Order},Tuple})\n\nReorder relation to order for every dimension, or reorder relation  for the the given dimension(s) to the Order they wrap.\n\nThis will reverse the array, not the dimension index.\n\norder can be an Order, a single Dimension  or a Tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reverseindex","page":"API","title":"DimensionalData.reverseindex","text":"reverseindex(A; dims) => AbstractDimArray\nreverseindex(dim::Dimension) => Dimension\n\nReverse the dimension index.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reversearray","page":"API","title":"DimensionalData.reversearray","text":"reversearray(A; dims) => AbstractDimArray\nreversearray(dim::Dimension) => Dimension\n\nReverse the array order, and update the dim to match.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-methods-for-developers","page":"API","title":"Non-exported methods for developers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.dims2indices\r\nDimensionalData.formatdims\r\nDimensionalData.reducedims\r\nDimensionalData.slicedims\r\nDimensionalData.comparedims\r\nDimensionalData.identify","category":"page"},{"location":"api/#DimensionalData.dims2indices","page":"API","title":"DimensionalData.dims2indices","text":"dims2indices(dim::Dimension, lookup, [emptyval=Colon()]) => NTuple{Union{Colon,AbstractArray,Int}}\n\nConvert a Dimension or Selector lookup to indices, ranges or Colon.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.formatdims","page":"API","title":"DimensionalData.formatdims","text":"formatdims(A, dims) => Tuple{Vararg{<:Dimension,N}}\n\nFormat the passed-in dimension(s) dims to match the array A.\n\nThis means converting indexes of Tuple to LinRange, and running identify. Errors are also thrown if dims don't match the array dims or size.\n\nIf a IndexMode hasn't been specified, an mode is chosen based on the type and element type of the index:\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reducedims","page":"API","title":"DimensionalData.reducedims","text":"reducedims(x, dimstoreduce)\n\nReplace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like mean or reduce to a length of 1, but the number of dimensions has not changed.\n\nIndexMode traits are also updated to correspond to the change in cell step, sampling type and order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.slicedims","page":"API","title":"DimensionalData.slicedims","text":"slicedims(x, I) => Tuple{Tuple,Tuple}\n\nSlice the dimensions to match the axis values of the new array\n\nAll methods returns a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.\n\nCalled at the array level the returned tuple will also include the previous reference dims attached to the array.\n\nArguments\n\nx: An AbstractDimArray, Tuple of Dimension, or Dimension\nI: A tuple of Integer, Colon or AbstractArray\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.comparedims","page":"API","title":"DimensionalData.comparedims","text":"comparedims(A::AbstractDimArray...)\ncomparedims(A::Tuple...)\ncomparedims(a, b)\n\nCheck that dimensions or tuples of dimensions are the same, and return the first valid dimension. If AbstractDimArrays are passed as arguments their dimensions are compared.\n\nEmpty tuples and nothing dimension values are ignored, returning the Dimension value if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.identify","page":"API","title":"DimensionalData.identify","text":"identify(indexmode, index)\n\nIdentify an IndexMode or its fields from index content and existing IndexMode.\n\n\n\n\n\n","category":"function"},{"location":"developer/#For-package-developers","page":"For Developers","title":"For package developers","text":"","category":"section"},{"location":"developer/#Goals:","page":"For Developers","title":"Goals:","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated.\nFlexibility: dims and selectors are parametric types with multiple uses\nAbstraction: never dispatch on concrete types, maximum re-usability of methods\nClean, readable syntax. Minimise required parentheses, minimise of exported methods, and instead extend Base methods whenever possible.\nMinimal interface: implementing a dimension-aware type should be easy.\nFunctional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.\nLaziness. Label data correctly, and manipulate them when needed -  instead of standardising eagerly.\nLeast surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or dims=X in base, you should be able to use DimensionalData.jl dims.\nType stability: dimensional methods should be type stable more often than Base methods\nZero cost dimensional indexing a[Y(4), X(5)] of a single value.\nLow cost indexing for range getindex and views: these cant be zero cost as dim ranges have to be updated.\nPlotting is easy: data should plot sensibly and correctly with useful labels - after all transformations using dims or indices\nPrioritise spatial data: other use cases are a free bonus of the modular approach.","category":"page"},{"location":"developer/#Why-this-package","page":"For Developers","title":"Why this package","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Why not AxisArrays.jl or NamedDims.jl?","category":"page"},{"location":"developer/#Structure","page":"For Developers","title":"Structure","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Both AxisArrays and NamedDims use concrete types for dispatch on arrays, and for dimension type Axis in AxisArrays. This makes them hard to extend.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Its a little easier with DimensionalData.jl. You can inherit from AbstractDimArray, or just implement dims and rebuild methods. Dims and selectors in DimensionalData.jl are also extensible. Recursive primitive methods allow inserting whatever methods you want to add extra types. @generated is only used to match and permute arbitrary tuples of types, and contain no type-specific details. The @generated functions in AxisArrays internalise axis/index conversion behaviour preventing extension in external packages and scripts.","category":"page"},{"location":"developer/#Syntax","page":"For Developers","title":"Syntax","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"AxisArrays.jl is verbose by default: a[Axis{:y}(1)] vs a[Y(1)] used here. NamedDims.jl has concise syntax, but the dimensions are no longer types, NamedDims.jl syntax can now be replicated using Dim{:X}: ","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"A = Dimarray(rand(4, 5), (:a, :b)\r\nA[:b=5, :a=3] = 25.0","category":"page"},{"location":"developer/#Data-types-and-the-interface","page":"For Developers","title":"Data types and the interface","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"DimensionalData.jl provides the concrete DimArray type. But it's core purpose is to be easily used with other array types.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Some of the functionality in DimensionalData.jl will work without inheriting from AbstractDimArray. The main requirement define a dims method that returns a Tuple of Dimension that matches the dimension order and axis values of your data. Define rebuild, and base methods for similar and parent if you want the metadata to persist through transformations (see the DimArray and AbstractDimArray types). A refdims method returns the lost dimensions of a previous transformation, passed in to the rebuild method. refdims can be discarded, the main loss being plot labels.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Inheriting from AbstractDimArray will give nearly all the functionality of using DimArray.","category":"page"},{"location":"course/#Crash-course","page":"Crash course","title":"Crash course","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This is brief a tutorial for DimensionalData.jl.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The main functionality is explained here, but the full list of features is listed at the API page.","category":"page"},{"location":"course/#Dimensions-and-DimArrays","page":"Crash course","title":"Dimensions and DimArrays","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The core type of DimensionalData.jl is the Dimension and the types that inherit from it, such as Ti, X, Y, Z, the generic Dim{:x}, or others that you define manually using the @dim macro.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions are primarily used in DimArray, other AbstractDimArray.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can use dimensions without a value index - these simply label the axis. A DimArray with labelled dimensions is constructed by:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA = DimArray(rand(5, 5), (X, Y))\r\nA[Y(1), X(2)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Or we can use the Dim{X} dim by using Symbols:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A = DimArray(rand(5, 5), (:a, :b))\r\nA[a=3, b=5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"But often, we want to provide a lookup index for the dimension:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Dates\r\nt = DateTime(2001):Month(1):DateTime(2001,12)\r\nx = 10:10:100\r\nA = DimArray(rand(12, 10), (X(x), Ti(t)))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Here both X and Ti are dimensions from DimensionalData. The currently exported dimensions are X, Y, Z, Ti. Ti is shortening of Time - to avoid the conflict with Dates.Time.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The length of each dimension index has to match the size of the corresponding array axis. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This can also be done with Symbol, using Dim{X}:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A = DimArray(rand(12, 10), (:time=t, :distance=x))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Symbols can be more convenient than defining dims with @dim, but have some downsides. They don't inherit from a specific Dimension type, so plots will not know what axis to put them on. If you need to specify the dimension mode or metadata manually, the Dim{X} syntax becomes less beneficial. ","category":"page"},{"location":"course/#Indexing-the-array-by-name-and-index","page":"Crash course","title":"Indexing the array by name and index","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The simplest case is to select a dimension by index. Let's say every 2nd point of the Ti dimension and every 3rd point of the X dimension. This is done with the simple Ti(range) syntax like so:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:end), Ti(1:2:end)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Of course, when specifying only one dimension, all elements of the other dimensions are assumed to be included:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:10)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"info: Indexing\nIndexing AbstractDimArrays works with getindex, setindex! and view. The result is still an AbstracDimArray.","category":"page"},{"location":"course/#Selecting-by-name-and-value","page":"Crash course","title":"Selecting by name and value","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The above example is useful because one does not have to care about the ordering of the dimensions. But arguably more useful is to be able to select a dimension by its values. For example, we would like to get all values of A where the X dimension is between two values.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selecting by value in DimensionalData is done with the selectors, which are listed in the Selectors page. This avoids the ambiguity of what happens when the index values of the dimension are also integers (like the case here for the dimension X).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"For simplicity, here we use the Between selector, but  others also exist, like At, Contains, or Near.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(Between(12, 35)), Ti(Between(Date(2001, 5), Date(2001, 7)))]","category":"page"},{"location":"course/#Selecting-by-position","page":"Crash course","title":"Selecting by position","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"So far, the selection protocols we have mentioned work by specifying the name of the dimension, without worry about the order.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"However normal indexing also works by specifying dimensions by position. This functionality also covers Selectors.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Continuing to use A we defined above, you can see how this works by comparing the statements without and with names:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[:, Between(12, 35)] == A[X(Between(12, 35))]\r\nA[:, 1:5] == A[X(1:5)]\r\nA[1:5, :] == A[Ti(1:5)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Using this approach it is necessary to specify all dimensions by position. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In addition, to support as base Julia functionality single index access like in standard Array:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[1:5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This selects the first 5 entries of the underlying array. In the case that A has only one dimension, it will be retained. Multidimensional AbstracDimArray indexed this way will return a regular array.","category":"page"},{"location":"course/#Specifying-dims-keyword-arguments-with-Dimension","page":"Crash course","title":"Specifying dims keyword arguments with Dimension","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In many Julia functions like size or sum, you can specify the dimension along which to perform the operation as an Int. It is also possible to do this using Dimension types with AbstractDimArray:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"sum(A; dims=X)","category":"page"},{"location":"course/#Numeric-operations-on-dimension-arrays-and-dimensions","page":"Crash course","title":"Numeric operations on dimension arrays and dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Numeric operations on a AbstractDimArray match base Julia as much as possible. Standard broadcasting and other type of operations across dimensional arrays typically perform as expected while still returning an AbstractDimArray type with correct dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In cases where you would like to do some operation on the dimension index, e.g. take the cosines of the values of the dimension X while still keeping the dimensional information of X, you can use the syntax:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimArray(cos, x)","category":"page"},{"location":"course/#Referenced-dimensions","page":"Crash course","title":"Referenced dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes.","category":"page"},{"location":"course/#IndexMode","page":"Crash course","title":"IndexMode","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"DimensionalData provides types for specifying details about the dimension index. This enables optimisations with Selectors, and modified behaviours such as selection of intervals or points, which will give slightly different results for selectors like Between for Points and Intervals.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"It also allows plots to always be the right way up when either the index or the  array is backwards - reverseing the data lazily when required for plotting if reqiured, not when loaded.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The major categories of IndexMode are Categorical, Sampled and NoIndex, which are all subtypes of Aligned. Unaligned also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as Transformed. These are a work in progress.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Aligned types will be detected automatically if not specified. A Dimension containing and index of String, Char or Symbol will be given the Categorical mode. A range will be Sampled, defaulting to Points and Regular, with the Order detected automatically. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"See the api docs for specifics about these IndexModes.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions. It's a pluggable, generalised version of AxisArrays.jl with a cleaner syntax, and additional functionality found in NamedDimensions.jl. It has similar goals to pythons xarray, and is primarily written for use with spatial data in GeoData.jl.\n\nDimensions\n\nDimensions are just wrapper types. They store the dimension index and define details about the grid and other metadata, and are also used to index into the array, wrapping a value or a Selector. X, Y, Z and Ti are the exported defaults.\n\nA generalised Dim type is available to use arbitrary symbols to name dimensions. Custom dimensions can be defined using the @dim macro.\n\nWe can use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:\n\njulia> using DimensionalData\n\njulia> A = DimArray(rand(40, 50), (X, Y));\n\njulia> A[Y(1), X(1:10)]\nDimArray with dimensions:\n X: 1:10 (NoIndex)\nand referenced dimensions:\n Y: 1 (NoIndex)\nand data: 10-element Array{Float64,1}\n[0.515774, 0.575247, 0.429075, 0.234041, 0.4484, 0.302562, 0.911098, 0.541537, 0.267234, 0.370663]\n\nAnd this has no runtime cost:\n\njulia> using BenchmarkTools\n\njulia> @btime A[X(1), Y(2)]\n  25.068 ns (1 allocation: 16 bytes)\n0.7302366320496405\n\njulia> @btime parent(A)[1, 2]\n  34.061 ns (1 allocation: 16 bytes)\n0.7302366320496405\n\nThe core component is the AbstractDimension, and types that inherit from it, such as Time, X, Y, Z, the generic Dim{:x} or others you define manually using the @dim macro.\n\nDims can be used for indexing and views without knowing dimension order:\n\nA[X(10)]\nview(A, Y(30:40), X(1:20))\n\nAnd for indicating dimensions to reduce or permute in julia Base and Statistics functions that have dims arguments:\n\nusing Statistics\n\nA = DimArray(rand(10, 10, 100), (X, Y, Ti));\nmean(A, dims=Ti)\npermutedims(A, [Ti, Y, X]) \n\nYou can also use arbitrary symbol to create Dim{X} dimensions:\n\njulia> A = DimArray(rand(10, 20, 30), (:a, :b, :c));\n\njulia> A[a=2:5, c=9]\n\nDimArray with dimensions:\n Dim{:a}: 2:5 (NoIndex)\n Dim{:b}: Base.OneTo(20) (NoIndex)\nand referenced dimensions:\n Dim{:c}: 9 (NoIndex)\nand data: 4×20 Array{Float64,2}\n 0.868237   0.528297   0.32389   …  0.89322   0.6776    0.604891\n 0.635544   0.0526766  0.965727     0.50829   0.661853  0.410173\n 0.732377   0.990363   0.728461     0.610426  0.283663  0.00224321\n 0.0849853  0.554705   0.594263     0.217618  0.198165  0.661853\n\nOther methods also work:\n\njulia> bounds(A, (:b, :c))\n\n((1, 20), (1, 30))\n\njulia> mean(A, dim=Dim{:b})\n\njulia> mean(A, dims=Dim{:b})\nDimArray with dimensions:\n Dim{:a}: Base.OneTo(10) (NoIndex)\n Dim{:b}: 1 (NoIndex)\n Dim{:c}: Base.OneTo(30) (NoIndex)\nand data: 10×1×30 Array{Float64,3}\n[:, :, 1]\n 0.543099\n 0.542407\n 0.540647\n 0.513554\n 0.601689\n 0.601558\n 0.46997\n 0.524254\n 0.601844\n 0.520966\n[and 29 more slices...]\n\nSelectors\n\nSelectors find indices in the dimension based on values At, Near, or Between the index value(s). They can be used in getindex, setindex! and view to select indices matching the passed in value(s)\n\nAt(x): get indices exactly matching the passed in value(s)\nNear(x): get the closest indices to the passed in value(s)\nWhere(f::Function): filter the array axis by a function of dimension  index values.\nBetween(a, b): get all indices between two values (inclusive)\nContains(x): get indices where the value x falls in the interval.  Only used for Sampled Intervals, for Points us At.\n\nWe can use selectors with dim wrappers:\n\nA[X(Between(1, 10)), Y(At(25.7))]\n\nWithout dim wrappers selectors must be in the right order:\n\nusing Unitful\n\njulia> A = DimArray(rand(10, 20), (X((1:10:100)u\"m\"), Ti((1:5:100)u\"s\")))\n\njulia> A[Between(10.5u\"m\", 50.5u\"m\"), Near(23u\"s\")]\nDimArray with dimensions:\n X: (11:10:41) m (Sampled: Ordered Regular Points)\nand referenced dimensions:\n Time (type Ti): 21 s (Sampled: Ordered Regular Points)\nand data: 4-element Array{Float64,1}\n[0.819172, 0.418113, 0.461722, 0.379877]\n\nFor values other than Int/AbstractArray/Colon (which are set aside for  regular indexing) the At selector is assumed, and can be dropped completely:\n\njulia> A = DimArray(rand(3, 3), (X(Val((:a, :b, :c))), Y([25.6, 25.7, 25.8])))\nDimArray with dimensions:\n X: Val{(:a, :b, :c)}()\n Y: Float64[25.6, 25.7, 25.8]\nand data: 3×3 Array{Float64,2}\n 0.280308  0.92255    0.023938\n 0.129487  0.0993857  0.618391\n 0.246378  0.276186   0.0425624\n\njulia> A[:b, 25.8]\n0.61839141062599\n\nUsing all Val indexes (only recommended for small arrays) you can index with named dimensions At arbitrary values with no  runtime cost:\n\nusing BenchmarkTools\n\njulia> A = DimArray(rand(3, 3), (cat=Val((:a, :b, :c)), \n                                 val=Val((5.0, 6.0, 7.0))))\nDimArray with dimensions:\n Dim{:cat}: Val{(:a, :b, :c)}() (Categorical: Unordered)\n Dim{:val}: Val{(5.0, 6.0, 7.0)}() (Categorical: Unordered)\nand data: 3×3 Array{Float64,2}\n 0.993357  0.765515  0.914423\n 0.405196  0.98223   0.330779\n 0.365312  0.388873  0.88732\n\njulia> @btime A[:a, 7.0]\n  26.333 ns (1 allocation: 16 bytes)\n0.32927504968939925\n\njulia> @btime A[cat=:a, val=7.0]\n  31.920 ns (2 allocations: 48 bytes)\n0.7476441117572306\n````\n\nIt's also easy to write your own custom `Selector` if your need a different behaviour.\n\n_Example usage:_\n\n\njulia using Dates, DimensionalData timespan = DateTime(2001,1):Month(1):DateTime(2001,12) A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))\n\njulia> A[X(Near(35)), Ti(At(DateTime(2001,5)))] 0.658404535807791\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)] DimArray with dimensions:  X: 20:10:50 and referenced dimensions:  Time (type Ti): 2001-05-01T00:00:00 and data: 4-element Array{Float64,1} [0.456175, 0.737336, 0.658405, 0.520152]\n\n\nDim types or objects can be used instead of a dimension number in many\nBase and Statistics methods:\n\n## Methods where dims can be used containing indices or Selectors\n\n`getindex`, `setindex!` `view`\n\n## Methods where dims can be used\n\n- `size`, `axes`, `firstindex`, `lastindex`\n- `cat`\n- `reverse`\n- `dropdims`\n- `reduce`, `mapreduce`\n- `sum`, `prod`, `maximum`, `minimum`, \n- `mean`, `median`, `extrema`, `std`, `var`, `cor`, `cov`\n- `permutedims`, `adjoint`, `transpose`, `Transpose`\n- `mapslices`, `eachslice`\n- `fill`\n\n_Example usage:_\n\n\njulia A = DimArray(rand(20,10), (X, Y)) size(A, Y) using Statistics mean(A, dims=X) std(A; dims=Y()) ```\n\nAlternate Packages\n\nThere are a lot of similar julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate any of their functionality, although with slightly more verbose syntax and less polish in some cases. If there is anything it doesn't do that these packages can do, put in an issue with the feature requrest.\n\nAxisRanges.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn how to use this package, see the Crash course.","category":"page"}]
}
