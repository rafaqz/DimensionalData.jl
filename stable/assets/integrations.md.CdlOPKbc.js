import{_ as e,o as r,c as t,aA as s}from"./chunks/framework.32ERgV9X.js";const p=JSON.parse('{"title":"Integrations","description":"","frontmatter":{},"headers":[],"relativePath":"integrations.md","filePath":"integrations.md","lastUpdated":null}'),o={name:"integrations.md"};function i(l,a,n,d,c,h){return r(),t("div",null,[...a[0]||(a[0]=[s('<h1 id="Integrations" tabindex="-1">Integrations <a class="header-anchor" href="#Integrations" aria-label="Permalink to &quot;Integrations {#Integrations}&quot;">​</a></h1><h2 id="Rasters.jl" tabindex="-1">Rasters.jl <a class="header-anchor" href="#Rasters.jl" aria-label="Permalink to &quot;Rasters.jl {#Rasters.jl}&quot;">​</a></h2><p><a href="https://rafaqz.github.io/Rasters.jl/stable" target="_blank" rel="noreferrer">Rasters.jl</a> extends DimensionalData for geospatial data manipulation, providing file load/save capabilities for a wide range of raster data sources and common GIS tools like polygon rasterization and masking. <code>Raster</code> types are aware of their <code>crs</code> and their <code>missingval</code> (which is often not <code>missing</code> for performance and storage reasons).</p><p>Rasters.jl is also the reason DimensionalData.jl exists at all! But it always made sense to separate out spatial indexing from GIS tools and dependencies.</p><p>A <code>Raster</code> is a <code>AbstractDimArray</code>, a <code>RasterStack</code> is a <code>AbstractDimStack</code>, and <code>Projected</code> and <code>Mapped</code> are <code>AbstractSampled</code> lookups.</p><h2 id="YAXArrays.jl" tabindex="-1">YAXArrays.jl <a class="header-anchor" href="#YAXArrays.jl" aria-label="Permalink to &quot;YAXArrays.jl {#YAXArrays.jl}&quot;">​</a></h2><p><a href="https://juliadatacubes.github.io/YAXArrays.jl/dev/" target="_blank" rel="noreferrer">YAXArrays.jl</a> is another spatial data package aimed more at (very) large datasets. Its functionality is slowly converging with Rasters.jl (both wrapping DiskArrays.jl/DimensionalData.jl) and we work closely with the developers.</p><p><code>YAXArray</code> is a <code>AbstractDimArray</code> and inherits its behaviours.</p><h2 id="ClimateBase.jl" tabindex="-1">ClimateBase.jl <a class="header-anchor" href="#ClimateBase.jl" aria-label="Permalink to &quot;ClimateBase.jl {#ClimateBase.jl}&quot;">​</a></h2><p><a href="https://juliaclimate.github.io/ClimateBase.jl/dev/" target="_blank" rel="noreferrer">ClimateBase.jl</a> Extends DimensionalData.jl with methods for analysis of climate data.</p><h2 id="ArviZ.jl" tabindex="-1">ArviZ.jl <a class="header-anchor" href="#ArviZ.jl" aria-label="Permalink to &quot;ArviZ.jl {#ArviZ.jl}&quot;">​</a></h2><p><a href="https://arviz-devs.github.io/ArviZ.jl/dev/" target="_blank" rel="noreferrer">ArviZ.jl</a> Is a Julia package for exploratory analysis of Bayesian models.</p><p>An <code>ArviZ.Dataset</code> is an <code>AbstractDimStack</code>!</p><h2 id="JuMP.jl" tabindex="-1">JuMP.jl <a class="header-anchor" href="#JuMP.jl" aria-label="Permalink to &quot;JuMP.jl {#JuMP.jl}&quot;">​</a></h2><p><a href="https://jump.dev/" target="_blank" rel="noreferrer">JuMP.jl</a> is a powerful optimization DSL. It defines its own named array types but now accepts any <code>AbstractDimArray</code> too, through a package extension.</p><h2 id="CryoGrid.jl" tabindex="-1">CryoGrid.jl <a class="header-anchor" href="#CryoGrid.jl" aria-label="Permalink to &quot;CryoGrid.jl {#CryoGrid.jl}&quot;">​</a></h2><p><a href="https://juliahub.com/ui/Packages/General/CryoGrid" target="_blank" rel="noreferrer">CryoGrid.jl</a> A Julia implementation of the CryoGrid permafrost model.</p><p><code>CryoGridOutput</code> uses <code>DimArray</code> for views into output data.</p><h2 id="DynamicGrids.jl" tabindex="-1">DynamicGrids.jl <a class="header-anchor" href="#DynamicGrids.jl" aria-label="Permalink to &quot;DynamicGrids.jl {#DynamicGrids.jl}&quot;">​</a></h2><p><a href="https://github.com/cesaraustralia/DynamicGrids.jl" target="_blank" rel="noreferrer">DynamicGrids.jl</a> is a spatial simulation engine, for cellular automata and spatial process models.</p><p>All DynamicGrids.jl <code>Outputs</code> are <code>&lt;: AbstractDimArray</code>, and <code>AbstractDimArray</code> are used for auxiliary data to allow temporal synchronisation during simulations. Notably, this all works on GPUs!</p><h2 id="AstroImages.jl" tabindex="-1">AstroImages.jl <a class="header-anchor" href="#AstroImages.jl" aria-label="Permalink to &quot;AstroImages.jl {#AstroImages.jl}&quot;">​</a></h2><p><a href="http://juliaastro.org/dev/modules/AstroImages" target="_blank" rel="noreferrer">AstroImages.jl</a> Provides tools to load and visualise astronomical images. <code>AstroImage</code> is <code>&lt;: AbstractDimArray</code>.</p><h2 id="TimeseriesTools.jl" tabindex="-1">TimeseriesTools.jl <a class="header-anchor" href="#TimeseriesTools.jl" aria-label="Permalink to &quot;TimeseriesTools.jl {#TimeseriesTools.jl}&quot;">​</a></h2><p><a href="https://juliahub.com/ui/Packages/General/TimeseriesTools" target="_blank" rel="noreferrer">TimeseriesTools.jl</a> Uses <code>DimArray</code> for time-series data.</p><h2 id="NaNStatistics.jl" tabindex="-1">NaNStatistics.jl <a class="header-anchor" href="#NaNStatistics.jl" aria-label="Permalink to &quot;NaNStatistics.jl {#NaNStatistics.jl}&quot;">​</a></h2><p>Most functions in <a href="https://github.com/brenhinkeller/NaNStatistics.jl" target="_blank" rel="noreferrer">NaNStatistics.jl</a> support <code>DimArray</code>&#39;s, see <a href="https://github.com/brenhinkeller/NaNStatistics.jl?tab=readme-ov-file#dimensionaldata-support" target="_blank" rel="noreferrer">the README</a> for details.</p>',27)])])}const u=e(o,[["render",i]]);export{p as __pageData,u as default};
