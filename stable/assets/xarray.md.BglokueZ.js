import{_ as e,o as t,c as r,aA as s}from"./chunks/framework.32ERgV9X.js";const c=JSON.parse('{"title":"Xarray and PythonCall.jl","description":"","frontmatter":{},"headers":[],"relativePath":"xarray.md","filePath":"xarray.md","lastUpdated":null}'),i={name:"xarray.md"};function l(n,a,o,h,p,d){return t(),r("div",null,[...a[0]||(a[0]=[s(`<h1 id="Xarray-and-PythonCall.jl" tabindex="-1">Xarray and PythonCall.jl <a class="header-anchor" href="#Xarray-and-PythonCall.jl" aria-label="Permalink to &quot;Xarray and PythonCall.jl {#Xarray-and-PythonCall.jl}&quot;">â€‹</a></h1><p>In the Python ecosystem <a href="https://xarray.dev" target="_blank" rel="noreferrer">Xarray</a> is by far the most popular package for working with multidimensional labelled arrays. The main data structures it provides are:</p><ul><li><p><a href="https://docs.xarray.dev/en/stable/user-guide/data-structures.html#dataarray" target="_blank" rel="noreferrer">DataArray</a>, analagous to <code>DimArray</code>.</p></li><li><p><a href="https://docs.xarray.dev/en/stable/user-guide/data-structures.html#dataset" target="_blank" rel="noreferrer">Dataset</a>, analagous to <code>DimStack</code>.</p></li></ul><p>DimensionalData integrates with <a href="https://juliapy.github.io/PythonCall.jl/stable/" target="_blank" rel="noreferrer">PythonCall.jl</a> to allow converting these Xarray types to their DimensionalData equivalent:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PythonCall</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pyconvert</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># By default this will share the underlying array</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_dimarray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pyconvert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DimArray, my_dataarray)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_dimstack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pyconvert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DimStack, my_dataset)</span></span></code></pre></div><p>Here are some things to keep in mind when converting:</p><ul><li><p><code>pyconvert(DimArray, x)</code> is zero-copy by default, i.e. it will share the underlying array with Python and register itself with Pythons GC to ensure that the memory isn&#39;t garbage-collected prematurely. If you want to make a copy you can call it like <code>pyconvert(DimArray, x; copy=true)</code>.</p></li><li><p>When doing a zero-copy conversion from <code>x</code> to <code>x_jl</code>, <code>parent(x_jl)</code> will be a <a href="https://juliapy.github.io/PythonCall.jl/stable/pythoncall-reference/#PythonCall.Wrap.PyArray" target="_blank" rel="noreferrer">PyArray</a>. In most situations there should be no overhead from this but note that a <code>PyArray</code> is not a <code>DenseArray</code> so some operations that dispatch on <code>DenseArray</code> may not be performant, e.g. BLAS calls. See these issues for more information:</p><ul><li><p><a href="https://github.com/JuliaPy/PythonCall.jl/issues/319" target="_blank" rel="noreferrer">https://github.com/JuliaPy/PythonCall.jl/issues/319</a></p></li><li><p><a href="https://github.com/JuliaPy/PythonCall.jl/issues/182" target="_blank" rel="noreferrer">https://github.com/JuliaPy/PythonCall.jl/issues/182</a></p></li></ul><p>When <code>copy=true</code>, <code>parent(x_jl)</code> will always be a standard <code>Array</code>. However, we do not consider the type of parent array covered by semver so this may change in the future.</p></li><li><p>Python stores arrays in row-major order whereas Julia stores them in column-major order, hence the dimensions on a converted <code>DimArray</code> will be in reverse order from the original <code>DataArray</code>. This is done to ensure that the &#39;fast axis&#39; to iterate over is the same dimension in both Julia and Python.</p></li></ul>`,7)])])}const u=e(i,[["render",l]]);export{c as __pageData,u as default};
