var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Arrays","page":"API","title":"Arrays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimArray\r\nDimArray","category":"page"},{"location":"api/#DimensionalData.AbstractDimArray","page":"API","title":"DimensionalData.AbstractDimArray","text":"AbstractDimArray <: AbstractArray\n\nAbstract supertype for all \"dim\" arrays.\n\nThese arrays return a Tuple of Dimension from a dims method, and can be rebuilt using rebuild.\n\nparent must return the source array.\n\nThey should have metadata, name and refdims methods, although these are optional.\n\nA rebuild method for AbstractDimArray must accept data, dims, refdims, name, metadata arguments.\n\nIndexing AbstractDimArray with non-range AbstractArray has undefined effects on the Dimension index. Use forward-ordered arrays only\"\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimArray","page":"API","title":"DimensionalData.DimArray","text":"DimArray <: AbstractDimArray\n\nDimArray(data, dims, refdims, name, metadata)\nDimArray(data, dims::Tuple; refdims=(), name=NoName(), metadata=NoMetadata())\n\nThe main concrete subtype of AbstractDimArray.\n\nDimArray maintains and updates its Dimensions through transformations and moves dimensions to reference dimension refdims after reducing operations (like e.g. mean).\n\nArguments\n\ndata: An AbstractArray.\ndims: A Tuple of Dimension\nname: A string name for the array. Shows in plots and tables.\nrefdims: refence dimensions. Usually set programmatically to track past   slices and reductions of dimension for labelling and reconstruction.\nmetadata: Dict or Metadata object, or NoMetadata()\n\nIndexing can be done with all regular indices, or with Dimensions and/or Selectors. \n\nIndexing AbstractDimArray with non-range AbstractArray has undefined effects on the Dimension index. Use forward-ordered arrays only\"\n\nExample:\n\nusing Dates, DimensionalData\n\nti = (Ti(DateTime(2001):Month(1):DateTime(2001,12)),\nx = X(10:10:100))\nA = DimArray(rand(12,10), (ti, x), \"example\")\n\njulia> A[X(Near([12, 35])), Ti(At(DateTime(2001,5)))];\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)];\n\n\n\n\n\n","category":"type"},{"location":"api/#Multi-array-datasets","page":"API","title":"Multi-array datasets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDimStack\r\nDimStack","category":"page"},{"location":"api/#DimensionalData.AbstractDimStack","page":"API","title":"DimensionalData.AbstractDimStack","text":"AbstractDimStack\n\nAbstract supertype for dimensional stacks.\n\nThese have multiple layers of data, but share dimensions.\n\nNotably, their behaviour lies somewhere between a DimArray and a NamedTuple:\n\nindexing with a Symbol as in dimstack[:symbol] returns a DimArray layer.\niteration amd map are apply over array layers, as indexed with a Symbol.\ngetindex and many base methods are applied as for DimArray - to avoid the need    to allways use map.\n\nThis design gives very succinct code when working with many-layered, mixed-dimension objects.  But it may be jarring initially - the most surprising outcome is that dimstack[1] will return a NamedTuple of values for the first index in all layers, while first(dimstack) will return the first value of the iterator - the DimArray for the first layer.\n\nSee DimStack for the concrete implementation. Most methods are defined on the abstract type.\n\nTo extend AbstractDimStack, implement argument and keyword version of  rebuild and also rebuild_from_arrays.\n\nThe constructor of an AbstractDimStack must accept a NamedTuple.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimStack","page":"API","title":"DimensionalData.DimStack","text":"DimStack <: AbstractDimStack\n\nDimStack(data::AbstractDimArray...)\nDimStack(data::Tuple{Vararg{AbstractDimArray}})\nDimStack(data::NamedTuple{Keys,Vararg{AbstractDimArray}})\nDimStack(data::NamedTuple, dims::DimTuple; metadata=NoMetadata())\n\nDimStack holds multiple objects sharing some dimensions, in a NamedTuple.\n\nNotably, their behaviour lies somewhere between a DimArray and a NamedTuple:\n\nindexing with a Symbol as in dimstack[:symbol] returns a DimArray layer.\niteration amd map are apply over array layers, as indexed with a Symbol.\ngetindex or view with Int, Dimensions or Selectors that resolve to Int will   return a NamedTuple of values from each layer in the stack.   This has very good performace, and avoids the need to always use map.\ngetindex or view with a Vector or Colon will return another DimStack where   all data layers have been sliced.  \nsetindex! must pass a Tuple or NamedTuple maching the layers.\nmany base and Statistics methods (sum, mean etc) will work as for a DimArray   again removing the need to use map.\n\nFor example, here we take the mean over the time dimension for all layers :\n\nmean(mydimstack; dims=Ti)\n\nAnd this equivalent to:\n\nmap(A -> mean(A; dims=Ti), mydimstack)\n\nThis design gives succinct code when working with many-layered, mixed-dimension objects. \n\nBut it may be jarring initially - the most surprising outcome is that dimstack[1] will return a NamedTuple of values for the first index in all layers, while first(dimstack) will return the first value of the iterator - the DimArray for the first layer.\n\nDimStack can be constructed from multiple AbstractDimArray or a NamedTuple of AbstractArray and a matching dims tuple.\n\nMost Base and Statistics methods that apply to AbstractArray can be used on all layers of the stack simulataneously. The result is a DimStack, or a NamedTuple if methods like mean are used without dims arguments, and return a single non-array value.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0];\n\njulia> dimz = (X([:a, :b]), Y(10.0:10.0:30.0))\nX Symbol[a, b],\nY 10.0:10.0:30.0\n\njulia> da1 = DimArray(1A, dimz; name=:one);\n\njulia> da2 = DimArray(2A, dimz; name=:two);\n\njulia> da3 = DimArray(3A, dimz; name=:three);\n\njulia> s = DimStack(da1, da2, da3);\n\njulia> s[At(:b), At(10.0)]\n(one = 4.0, two = 8.0, three = 12.0)\n\njulia> s[X(At(:a))] isa DimStack\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Dimension-indices-generators","page":"API","title":"Dimension indices generators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimIndices\r\nDimKeys\r\nDimPoints","category":"page"},{"location":"api/#DimensionalData.DimIndices","page":"API","title":"DimensionalData.DimIndices","text":"DimIndices <: AbstractArray\n\nDimIndices(x)\nDimIndices(dims::Tuple)\nDimIndices(dims::Dimension)\n\nLike CartesianIndices, but for Dimensions. Behaves as an Array of Tuple of Dimension(i) for all combinations of the axis indices of dims.\n\nThis can be used to view/index into arbitrary dimensions over an array, and is especially useful when combined with otherdims, to iterate over the indices of unknown dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimKeys","page":"API","title":"DimensionalData.DimKeys","text":"DimKeys <: AbstractArray\n\nDimKeys(x)\nDimKeys(dims::Tuple)\nDimKeys(dims::Dimension)\n\nLike CartesianIndices, but for the lookup values of Dimensions. Behaves as an Array of Tuple of Dimension(At(lookupvalue)) for all combinations of the lookup values of dims.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimPoints","page":"API","title":"DimensionalData.DimPoints","text":"DimPoints <: AbstractArray\n\nDimPoints(x; order)\nDimPoints(dims::Tuple; order)\nDimPoints(dims::Dimension; order)\n\nLike CartesianIndices, but for the point values of the dimension index.  Behaves as an Array of Tuple lookup values (whatever they are) for all combinations of the lookup values of dims.\n\nEither a Dimension, a Tuple of Dimension or an object that defines a dims method can be passed in.\n\nKeywords\n\norder: determines the order of the points, the same as the order of dims by default.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.jl/TableTraits.jl-interface","page":"API","title":"Tables.jl/TableTraits.jl interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.AbstractDimTable\r\nDimTable\r\nDimensionalData.DimColumn","category":"page"},{"location":"api/#DimensionalData.AbstractDimTable","page":"API","title":"DimensionalData.AbstractDimTable","text":"AbstractDimTable <: Tables.AbstractColumns\n\nAbstract supertype for dim tables\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimTable","page":"API","title":"DimensionalData.DimTable","text":"DimTable <: AbstractDimTable\n\nDimTable(A::AbstractDimArray)\n\nConstruct a Tables.jl/TableTraits.jl compatible object out of an AbstractDimArray.\n\nThis table will have a column for the array data and columns for each Dimension index, as a [DimColumn]. These are lazy, and generated as required.\n\nColumn names are converted from the dimension types using DimensionalData.dim2key. This means type Ti becomes the column name :Ti, and Dim{:custom} becomes :custom.\n\nTo get dimension columns, you can index with Dimension (X()) or Dimension type (X) as well as the regular Int or Symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimColumn","page":"API","title":"DimensionalData.DimColumn","text":"DimColumn{T,D<:Dimension} <: AbstractVector{T}\n\nDimColumn(dim::Dimension, dims::Tuple{Vararg{DimTuple}})\nDimColumn(dim::DimColumn, length::Int, dimstride::Int)\n\nA table column based on a Dimension and it's relationship with other Dimensions in dims.\n\nlength is the product of all dim lengths (usually the length of the corresponding array data), while stride is the product of the preceding dimension lengths, which may or may not be the real stride of the corresponding array depending on the data type. For A isa Array, the dimstride will match the stride.\n\nWhen the second argument is a Tuple of Dimension, the length and dimstride fields are calculated from the dimensions, relative to the column dimension dim.\n\nThis object will be returned as a column of DimTable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Common-methods","page":"API","title":"Common methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Common functions for obtaining information from objects:","category":"page"},{"location":"api/","page":"API","title":"API","text":"dims\r\nrefdims\r\nmetadata\r\nname","category":"page"},{"location":"api/#DimensionalData.Dimensions.dims","page":"API","title":"DimensionalData.Dimensions.dims","text":"dims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\ndims(x, dim) => Dimension\n\nReturn a tuple of Dimensions for an object, in the order that matches the axes or columns of the underlying data.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nThe default is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.refdims","page":"API","title":"DimensionalData.Dimensions.refdims","text":"refdims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\nrefdims(x, dim) => Dimension\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty.\n\nThe default is to return an empty Tuple ().\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.metadata","page":"API","title":"DimensionalData.Dimensions.LookupArrays.metadata","text":"metadata(x) => (object metadata)\nmetadata(x, dims::Tuple)  => Tuple (Dimension metadata)\nmetadata(xs::Tuple) => Tuple\n\nReturns the metadata for an object or for the specified dimension(s)\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.name","page":"API","title":"DimensionalData.Dimensions.name","text":"name(x) => String\nname(xs:Tuple) => NTuple{N,String}\nname(x, dims::Tuple) => NTuple{N,String}\nname(x, dim) => String\n\nGet the name of an array or Dimension, or a tuple of of either.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Utility methods for transforming DimensionalData objects:","category":"page"},{"location":"api/","page":"API","title":"API","text":"set\r\nrebuild\r\nmodify\r\nbroadcast_dims\r\nbroadcast_dims!\r\nreorder\r\nBase.cat\r\nBase.map\r\nBase.copy!\r\nBase.eachslice","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.set","page":"API","title":"DimensionalData.Dimensions.LookupArrays.set","text":"set(x, val)\nset(x, args::Pairs...) => x with updated field/s\nset(x, args...; kw...) => x with updated field/s\nset(x, args::Tuple{Vararg{Dimension}}; kw...) => x with updated field/s\n\nset(dim::Dimension, index::AbstractArray) => Dimension\nset(dim::Dimension, lookup::LookupArray) => Dimension\nset(dim::Dimension, lookupcomponent::LookupArrayTrait) => Dimension\nset(dim::Dimension, metadata::AbstractMetadata) => Dimension\n\nSet the properties of an object, its internal data or the traits of its dimensions and lookup index.\n\nAs DimensionalData is so strongly typed you do not need to specify what field of a LookupArray to set - there is no ambiguity.\n\nTo set fields of a LookupArray you need to specify the dimension. This can be done using X => val pairs, X = val keyword arguments, or X(val) wrapped arguments.\n\nWhen a Dimension or LookupArray is passed to set to replace the existing ones, fields that are not set will keep their original values.\n\nNotes:\n\nChanging a lookup index range/vector will also update the step size and order where applicable.\n\nSetting the Order like ForwardOrdered will not reverse the array or dimension to match. Use reverse and reorder to do this.\n\nExamples\n\njulia> using DimensionalData; const DD = DimensionalData\nDimensionalData\n\njulia> da = DimArray(zeros(3, 4), (custom=10.0:010.0:30.0, Z=-20:010.0:10.0));\n\njulia> set(da, ones(3, 4))\n3×4 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    1.0    1.0  1.0   1.0\n 20.0    1.0    1.0  1.0   1.0\n 30.0    1.0    1.0  1.0   1.0 \n\nChange the Dimension wrapper type:\n\njulia> set(da, :Z => Ti, :custom => Z)\n3×4 DimArray{Float64,2} with dimensions:\n  Z Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Ti Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    0.0    0.0  0.0   0.0\n 20.0    0.0    0.0  0.0   0.0\n 30.0    0.0    0.0  0.0   0.0 \n\nChange the lookup Vector:\n\njulia> set(da, Z => [:a, :b, :c, :d], :custom => [4, 5, 6])\n3×4 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Int64} Int64[4, 5, 6] ForwardOrdered Regular Points,\n  Z Sampled{Symbol} Symbol[a, b, c, d] ForwardOrdered Regular Points\n     :a   :b   :c   :d\n 4  0.0  0.0  0.0  0.0\n 5  0.0  0.0  0.0  0.0\n 6  0.0  0.0  0.0  0.0\n\nChange the LookupArray type:\n\njulia> set(da, Z=DD.NoLookup(), custom=DD.Sampled())\n3×4 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Z\n 10.0  0.0  0.0  0.0  0.0\n 20.0  0.0  0.0  0.0  0.0\n 30.0  0.0  0.0  0.0  0.0\n\nChange the Sampling trait:\n\njulia> set(da, :custom => DD.Irregular(10, 12), Z => DD.Regular(9.9))\n3×4 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Irregular Points,\n  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    0.0    0.0  0.0   0.0\n 20.0    0.0    0.0  0.0   0.0\n 30.0    0.0    0.0  0.0   0.0\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.rebuild","page":"API","title":"DimensionalData.Dimensions.LookupArrays.rebuild","text":"rebuild(x, args...)\nrebuild(x; kw...)\n\nRebuild an object struct with updated field values.\n\nx can be a AbstractDimArray, a Dimension, LookupArray or other custom types.\n\nThis is an abstraction that alows inbuilt and custom types to be rebuilt to update their fields, as most objects in DimensionalData.jl are immutable.\n\nThe arguments version can be concise but depends on a fixed order defined for some DimensionalData objects. It should be defined based on the object type in DimensionalData, adding the fields specific to your object.\n\nThe keyword version ignores order, and is mostly automated  using ConstructionBase.setproperties. It should only be defined if your object has  missing fields or fields with different names to DimensionalData objects.\n\nThe arguments required are defined for the abstract type that has a rebuild method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.modify","page":"API","title":"DimensionalData.modify","text":"modify(f, A::AbstractDimArray) => AbstractDimArray\nmodify(f, s::AbstractDimStack) => AbstractDimStack\nmodify(f, dim::Dimension) => Dimension\nmodify(f, x, lookupdim::Dimension) => typeof(x)\n\nModify the parent data, rebuilding the object wrapper without change. f must return a AbstractArray of the same size as the original.\n\nThis method is mostly useful as a way of swapping the parent array type of an object.\n\nExample\n\nIf we have a previously-defined DimArray, we can copy it to an Nvidia GPU with:\n\nA = DimArray(rand(100, 100), (X, Y))\nmodify(CuArray, A)\n\nThis also works for all the data layers in a DimStack.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.broadcast_dims","page":"API","title":"DimensionalData.broadcast_dims","text":"broadcast_dims(f, sources::AbstractDimArray...) => AbstractDimArray\n\nBroadcast function f over the AbstractDimArrays in sources, permuting and reshaping dimensions to match where required. The result will contain all the dimensions in  all passed in arrays in the order in which they are found.\n\nArguments\n\nsources: AbstractDimArrays to broadcast over with f.\n\nThis is like broadcasting over every slice of A if it is sliced by the dimensions of B.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.broadcast_dims!","page":"API","title":"DimensionalData.broadcast_dims!","text":"broadcast_dims!(f, dest::AbstractDimArray, sources::AbstractDimArray...) => dest\n\nBroadcast function f over the AbstractDimArrays in sources, writing to dest.  sources are permuting and reshaping dimensions to match where required.\n\nThe result will contain all the dimensions in all passed in arrays, in the order in which they are found.\n\nArguments\n\ndest: AbstractDimArray to update.\nsources: AbstractDimArrays to broadcast over with f.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reorder","page":"API","title":"DimensionalData.reorder","text":"reorder(A::AbstractDimArray, order::Pair) => AbstractDimArray\nreorder(A::Dimension, order::Order) => AbstractDimArray\n\nReorder every dims index/array to order, or reorder index for the the given dimension(s) to the Order they wrap.\n\norder can be an Order, or Dimeension => Order pairs.\n\nIf no axis reversal is required the same objects will be returned, without allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.cat","page":"API","title":"Base.cat","text":"Base.cat(stacks::AbstractDimStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nKeywords\n\nkeys: Tuple of Symbol for the stack keys to concatenate.\ndims: Dimension of child array to concatenate on.\n\nExample\n\nConcatenate the :seasurfacetemp and :humidity layers in the time dimension:\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.map","page":"API","title":"Base.map","text":"Base.map(f, stacks::AbstractDimStack...)\n\nApply function f to each layer of the stacks.\n\nIf f returns DimArrays the result will be another DimStack. Other values will be returned in a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.copy!","page":"API","title":"Base.copy!","text":"Base.copy!(dst::AbstractArray, src::AbstractGimStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\nExample\n\nCopy the :humidity layer from stack to array.\n\ncopy!(array, stack, :humidity)\n\n\n\n\n\nBase.copy!(dst::AbstractDimStack, src::AbstractDimStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\nCopy just the :sea_surface_temp and :humidity layers from src to dst.\n\ncopy!(dst::AbstractDimStack, src::AbstractDimStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.eachslice","page":"API","title":"Base.eachslice","text":"Base.eachslice(stack::AbstractDimStack; dims)\n\nCreate a generator that iterates over dimensions dims of stack, returning stacks that select all the data from the other dimensions in stack using views.\n\nThe generator has size and axes equivalent to those of the provided dims.\n\nExamples\n\njulia> ds = DimStack((\n           x=DimArray(randn(2, 3, 4), (X([:x1, :x2]), Y(1:3), Z)),\n           y=DimArray(randn(2, 3, 5), (X([:x1, :x2]), Y(1:3), Ti))\n       ));\n\njulia> slices = eachslice(ds; dims=(Z, X));\n\njulia> size(slices)\n(4, 2)\n\njulia> map(dims, axes(slices))\nZ,\nX Categorical{Symbol} Symbol[x1, x2] ForwardOrdered\n\njulia> first(slices)\n┌ Warning: (Z,) dims were not found in object\n└ @ DimensionalData.Dimensions\nDimStack with dimensions:\n  Y Sampled{Int64} 1:3 ForwardOrdered Regular Points,\n  Ti\nand 2 layers:\n  :x Float64 dims: Y (3)\n  :y Float64 dims: Y, Ti (3×5)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Most base methods work as expected, using Dimension wherever a dims keyword is used. They are not allspecifically documented here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Shorthand constructors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Base.fill\r\nBase.rand\r\nBase.zeros\r\nBase.ones","category":"page"},{"location":"api/#Base.fill","page":"API","title":"Base.fill","text":"Base.fill(x, dims::Dimension...; kw...) => DimArray\nBase.fill(x, dims::Tuple{Vararg{Dimension}}; kw...) => DimArray\n\nCreate a DimArray with a fill value of x.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nKeywords are the same as for DimArray.\n\nExample\n\njulia> using DimensionalData\n\njulia> rand(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  0  0  1\n 1  0  1  1\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.rand","page":"API","title":"Base.rand","text":"Base.rand(x, dims::Dimension...; kw...) => DimArray\nBase.rand(x, dims::Tuple{Vararg{Dimension}}; kw...) => DimArray\nBase.rand(r::AbstractRNG, x, dims::Tuple{Vararg{Dimension}}; kw...) => DimArray\nBase.rand(r::AbstractRNG, x, dims::Dimension...; kw...) => DimArray\n\nCreate a DimArray of random values.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nKeywords are the same as for DimArray.\n\nExample\n\njulia> using DimensionalData\n\njulia> rand(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  0  0  1\n 1  0  1  1\n\njulia> rand(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 0.43204   0.835111  0.624231\n 0.752868  0.471638  0.193652\n 0.484558  0.846559  0.455256\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zeros","page":"API","title":"Base.zeros","text":"Base.zeros(x, dims::Dimension...; kw...) => DimArray\nBase.zeros(x, dims::Tuple{Vararg{Dimension}}; kw...) => DimArray\n\nCreate a DimArray of zeros.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nKeywords are the same as for DimArray.\n\nExample\n\njulia> using DimensionalData\n\njulia> zeros(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 0  0  0  0\n 0  0  0  0\n\njulia> zeros(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.ones","page":"API","title":"Base.ones","text":"Base.ones(x, dims::Dimension...; kw...) => DimArray\nBase.ones(x, dims::Tuple{Vararg{Dimension}}; kw...) => DimArray\n\nCreate a DimArray of ones.\n\nThere are two kinds of Dimension value acepted:\n\nA Dimension holding an AbstractVector will set the dimension index to  that AbstractVector, and detect the dimension lookup.\nA Dimension holding an Integer will set the length of the axis, and set the dimension lookup to NoLookup.\n\nKeywords are the same as for DimArray.\n\nExample\n\njulia> using DimensionalData\n\njulia> ones(Bool, X(2), Y(4))\n2×4 DimArray{Bool,2} with dimensions: X, Y\n 1  1  1  1\n 1  1  1  1\n\njulia> ones(X([:a, :b, :c]), Y(100.0:50:200.0))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Dimensions","page":"API","title":"Dimensions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Handling of Dimensions is kept in a sub-module Dimensions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Dimensions.Dimensions","category":"page"},{"location":"api/#DimensionalData.Dimensions","page":"API","title":"DimensionalData.Dimensions","text":"Dimensions\n\nSub-module for Dimensions wrappers, and operations on them used in DimensionalData.jl.\n\nTo load Dimensions types and methods into scope:\n\nusing DimensionalData\nusing .LookupArrays\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"API","title":"API","text":"Dimensions have a type-heirarchy that organises plotting and dimension matching.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Dimensions.Dimension\r\nDimensions.DependentDim\r\nDimensions.IndependentDim\r\nDimensions.XDim\r\nDimensions.YDim\r\nDimensions.ZDim\r\nDimensions.TimeDim\r\nX\r\nY\r\nZ\r\nTi\r\nDim\r\nCoord\r\nDimensions.AnonDim\r\n@dim","category":"page"},{"location":"api/#DimensionalData.Dimensions.Dimension","page":"API","title":"DimensionalData.Dimensions.Dimension","text":"Dimension\n\nAbstract supertype of all dimension types.\n\nExample concrete implementations are X, Y, Z, Ti (Time), and the custom [Dim]@ref) dimension.\n\nDimensions label the axes of an AbstractDimArray, or other dimensional objects, and are used to index into the array.\n\nThey may also provide an alternate index to lookup for each array axis. This may be any AbstractVector matching the array axis length, or a Val holding a tuple for compile-time index lookups.\n\nDimensions also have lookup and metadata fields.\n\nlookup gives more details about the dimension, such as that it is Categorical or Sampled as Points or Intervals along some transect. DimensionalData will attempt to guess the lookup from the passed-in index value.\n\nExample:\n\nusing DimensionalData, Dates\n\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimArray(zeros(3, 5, 12), (y, x, ti))\n\n# output\n\n3×5×12 DimArray{Float64,3} with dimensions:\n  Y Categorical{Char} Char[a, b, c] ForwardOrdered,\n  X Sampled{Int64} 2:2:10 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\n[:, :, 1]\n       2    4    6    8    10\n  'a'  0.0  0.0  0.0  0.0   0.0\n  'b'  0.0  0.0  0.0  0.0   0.0\n  'c'  0.0  0.0  0.0  0.0   0.0\n[and 11 more slices...]\n\nFor simplicity, the same Dimension types are also used as wrappers in getindex, like:\n\nx = A[X(2), Y(3)]\n\n# output\n\n12-element DimArray{Float64,1} with dimensions:\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical{Char} Char[c] ForwardOrdered,\n  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points\n 2021-01-01T00:00:00  0.0\n 2021-02-01T00:00:00  0.0\n 2021-03-01T00:00:00  0.0\n 2021-04-01T00:00:00  0.0\n 2021-05-01T00:00:00  0.0\n 2021-06-01T00:00:00  0.0\n 2021-07-01T00:00:00  0.0\n 2021-08-01T00:00:00  0.0\n 2021-09-01T00:00:00  0.0\n 2021-10-01T00:00:00  0.0\n 2021-11-01T00:00:00  0.0\n 2021-12-01T00:00:00  0.0\n\nA Dimension can also wrap Selector.\n\nx = A[X(Between(3, 4)), Y(At('b'))]\n\n# output\n\n1×12 DimArray{Float64,2} with dimensions:\n  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical{Char} Char[b] ForwardOrdered\n     2021-01-01T00:00:00  …   2021-12-01T00:00:00\n 4  0.0                                  0.0\n\nDimension objects may have lookup and metadata fields to track additional information about the data and the index, and their relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.DependentDim","page":"API","title":"DimensionalData.Dimensions.DependentDim","text":"DependentDim <: Dimension\n\nAbstract supertype for Dependent dimensions. These will plot on the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.IndependentDim","page":"API","title":"DimensionalData.Dimensions.IndependentDim","text":"IndependentDim <: Dimension\n\nAbstract supertype for independent dimensions. Thise will plot on the X axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.XDim","page":"API","title":"DimensionalData.Dimensions.XDim","text":"XDim <: IndependentDim\n\nAbstract supertype for all X dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.YDim","page":"API","title":"DimensionalData.Dimensions.YDim","text":"YDim <: DependentDim\n\nAbstract supertype for all Y dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.ZDim","page":"API","title":"DimensionalData.Dimensions.ZDim","text":"ZDim <: DependentDim\n\nAbstract supertype for all Z dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.TimeDim","page":"API","title":"DimensionalData.Dimensions.TimeDim","text":"TimeDim <: IndependentDim\n\nAbstract supertype for all time dimensions.\n\nIn a TimeDime with Interval sampling the locus will automatically be set to Start(). Dates and times generally refer to the start of a month, hour, second etc., not the central point as is more common with spatial data. `\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.X","page":"API","title":"DimensionalData.Dimensions.X","text":"X <: XDim\n\nX(val=:)\n\nX Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nxdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.Y","page":"API","title":"DimensionalData.Dimensions.Y","text":"Y <: YDim\n\nY(val=:)\n\nY Dimension. Y <: YDim <: DependentDim\n\nExample:\n\nydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.Z","page":"API","title":"DimensionalData.Dimensions.Z","text":"Z <: ZDim\n\nZ(val=:)\n\nZ Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nzdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.Ti","page":"API","title":"DimensionalData.Dimensions.Ti","text":"m     Ti <: TimeDim\n\nTi(val=:)\n\nTime Dimension. Ti <: TimeDim <: IndependentDim\n\nTime is already used by Dates, and T is a common type parameter, We use Ti to avoid clashes.\n\nExample:\n\ntimedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n# Or\nval = A[Ti(1)]\n# Or\nmean(A; dims=Ti)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.Dim","page":"API","title":"DimensionalData.Dimensions.Dim","text":"Dim{S}(val=:)\n\nA generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.\n\nDimension types take precedence over same named Dim types when indexing with symbols, or e.g. creating Tables.jl keys.\n\nusing DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.Coord","page":"API","title":"DimensionalData.Dimensions.Coord","text":"Coord <: Dimension\n\nA coordinate dimension itself holds dimensions.\n\nThis allows combining point data with other dimensions, such as time.\n\nExample\n\njulia> using DimensionalData\n\njulia> dim = Coord([(1.0,1.0,1.0), (1.0,2.0,2.0), (3.0,4.0,4.0), (1.0,3.0,4.0)], (X(), Y(), Z()))\nCoord ::\n  val: Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0, 3.0,\n4.0)]\n  lookup: MergedLookup\nCoord{Vector{Tuple{Float64, Float64, Float64}}, DimensionalData.MergedLookup{Tuple{X{Colon, AutoLookup{Auto\nOrder}, NoMetadata}, Y{Colon, AutoLookup{AutoOrder}, NoMetadata}, Z{Colon, AutoLookup{AutoOrder}, NoMetada\nta}}}, NoMetadata}\n\njulia> da = DimArray(0.1:0.1:0.4, dim)\n4-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0,\n3.0, 4.0)]\n    MergedLookup\n 0.1\n 0.2\n 0.3\n 0.4\n\njulia> da[Coord(Z(At(1.0)), Y(Between(1, 3)))]\n1-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0)] MergedLookup\n 0.1\n\njulia> da[Coord(4)] == 0.4\ntrue\n\njulia> da[Coord(Between(1, 5), :, At(4.0))]\n2-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(3.0, 4.0, 4.0), (1.0, 3.0, 4.0)] MergedLookup\n 0.3\n 0.4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.AnonDim","page":"API","title":"DimensionalData.Dimensions.AnonDim","text":"AnonDim <: Dimension\n\nAnonDim()\n\nAnonymous dimension. Used when extra dimensions are created, such as during transpose of a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.@dim","page":"API","title":"DimensionalData.Dimensions.@dim","text":"@dim typ [supertype=Dimension] [name::String=string(typ)]\n\nMacro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply YourDim <: Dimension. Making a Dimesion inherit from XDim, YDim, ZDim or TimeDim will affect automatic plot layout and other methods that dispatch on these types. <: YDim are plotted on the Y axis, <: XDim on the X axis, etc.\n\nExample:\n\nusing DimensionalData\nusing DimensionalData: @dim, YDim, XDim\n@dim Lat YDim \"latitude\"\n@dim Lon XDim \"Longitude\"\n# output\n\n\n\n\n\n\n","category":"macro"},{"location":"api/#Exported-methopds","page":"API","title":"Exported methopds","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"hasdim\r\ndimnum","category":"page"},{"location":"api/#DimensionalData.Dimensions.hasdim","page":"API","title":"DimensionalData.Dimensions.hasdim","text":"hasdim([f], x, query::Tuple) => NTUple{Bool}\nhasdim([f], x, query...) => NTUple{Bool}\nhasdim([f], x, query) => Bool\n\nCheck if an object x has dimensions that match or inherit from the query dimensions.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nquery: Tuple or single Dimension or dimension Type.\nf: <: by default, but can be >: to match abstract types to concrete types.\n\nCheck if an object or tuple contains an Dimension, or a tuple of dimensions.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> hasdim(A, X)\ntrue\n\njulia> hasdim(A, (Z, X, Y))\n(true, true, true)\n\njulia> hasdim(A, Ti)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.dimnum","page":"API","title":"DimensionalData.Dimensions.dimnum","text":"dimnum(x, query::Tuple) => NTuple{Int}\ndimnum(x, query) => Int\n\nGet the number(s) of Dimension(s) as ordered in the dimensions of an object.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nquery: Tuple, Array or single Dimension or dimension Type.\n\nThe return type will be a Tuple of Int or a single Int, depending on wether query is a Tuple or single Dimension.\n\nExample\n\njulia> using DimensionalData\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> dimnum(A, (Z, X, Y))\n(3, 1, 2)\n\njulia> dimnum(A, Y)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-methods","page":"API","title":"Non-exported methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Dimensions.lookup\r\nDimensions.label\r\nDimensionalData.dim2key\r\nDimensionalData.key2dim\r\nDimensionalData.dims2indices\r\nDimensionalData.selectindices\r\nDimensionalData.format\r\nDimensionalData.reducedims\r\nDimensionalData.swapdims\r\nDimensionalData.slicedims\r\nDimensionalData.comparedims\r\nDimensionalData.combinedims\r\nDimensionalData.otherdims\r\nDimensionalData.commondims\r\nDimensionalData.sortdims\r\nDimensionalData.basetypeof\r\nDimensionalData.setdims\r\nDimensionalData.dimsmatch\r\nDimensionalData.dimstride\r\nDimensionalData.refdims_title\r\nDimensionalData.rebuild_from_arrays","category":"page"},{"location":"api/#DimensionalData.Dimensions.lookup","page":"API","title":"DimensionalData.Dimensions.lookup","text":"lookup(x::Dimension) => LookupArray\nlookup(x, [dims::Tuple]) => Tuple{Vararg{LookupArray}}\nlookup(x::Tuple) => Tuple{Vararg{LookupArray}}\nlookup(x, dim) => LookupArray\n\nReturns the LookupArray of a dimension. This dictates properties of the dimension such as array axis and index order, and sampling properties.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.label","page":"API","title":"DimensionalData.Dimensions.label","text":"label(x) => String\nlabel(x, dims::Tuple) => NTuple{N,String}\nlabel(x, dim) => String\nlabel(xs::Tuple) => NTuple{N,String}\n\nGet a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.dim2key","page":"API","title":"DimensionalData.Dimensions.dim2key","text":"dim2key(dim::Dimension) => Symbol\ndim2key(dims::Type{<:Dimension}) => Symbol\ndim2key(dims::Tuple) => Tuple{Symbol,Vararg}\n\nConvert a dimension object to a simbol. X(), Y(), Ti() etc will be converted. to :X, :Y, :Ti, as with any other dims generated with the @dim macro.\n\nAll other Dim{S}() dimensions will generate Symbols S.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.key2dim","page":"API","title":"DimensionalData.Dimensions.key2dim","text":"key2dim(s::Symbol) => Dimension\nkey2dim(dims...) => Tuple{Dimension,Vararg}\nkey2dim(dims::Tuple) => Tuple{Dimension,Vararg}\n\nConvert a symbol to a dimension object. :X, :Y, :Ti etc will be converted. to X(), Y(), Ti(), as with any other dims generated with the @dim macro.\n\nAll other Symbols S will generate Dim{S}() dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.dims2indices","page":"API","title":"DimensionalData.Dimensions.dims2indices","text":"dims2indices(dim::Dimension, I) => NTuple{Union{Colon,AbstractArray,Int}}\n\nConvert a Dimension or Selector I to indices of Int, AbstractArray or Colon.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.selectindices","page":"API","title":"DimensionalData.Dimensions.LookupArrays.selectindices","text":"selectindices(lookups, selectors)\n\nConverts Selector to regular indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.format","page":"API","title":"DimensionalData.Dimensions.format","text":"format(dims, x) => Tuple{Vararg{Dimension,N}}\n\nFormat the passed-in dimension(s) dims to match the object x.\n\nErrors are thrown if dims don't match the array dims or size,  and any fields holding Auto- objects are filled with guessed objects.\n\nIf a LookupArray hasn't been specified, a lookup is chosen based on the type and element type of the index.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.reducedims","page":"API","title":"DimensionalData.Dimensions.reducedims","text":"reducedims(x, dimstoreduce) => Tuple{Vararg{Dimension}}\n\nReplace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like mean or reduce to a length of 1, but the number of dimensions has not changed.\n\nLookupArray traits are also updated to correspond to the change in cell step, sampling type and order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.swapdims","page":"API","title":"DimensionalData.Dimensions.swapdims","text":"swapdims(x::T, newdims) => T\nswapdims(dims::Tuple, newdims) => Tuple{Vararg{Dimension}}\n\nSwap dimensions for the passed in dimensions, in the order passed.\n\nPassing in the Dimension types rewraps the dimension index, keeping the index values and metadata, while constructed Dimension objectes replace the original dimension. nothing leaves the original dimension as-is.\n\nArguments\n\nx: any object with a dims method or a Tuple of Dimension.\nnewdim: Tuple of Dimension or dimension Type.\n\nExample\n\nusing DimensionalData\nA = ones(X(2), Y(4), Z(2))\nDimensions.swapdims(A, (Dim{:a}, Dim{:b}, Dim{:c}))\n\n# output\n2×4×2 DimArray{Float64,3} with dimensions: Dim{:a}, Dim{:b}, Dim{:c}\n[:, :, 1]\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n[and 1 more slices...]\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.slicedims","page":"API","title":"DimensionalData.Dimensions.slicedims","text":"slicedims(x, I) => Tuple{Tuple,Tuple}\nslicedims(f, x, I) => Tuple{Tuple,Tuple}\n\nSlice the dimensions to match the axis values of the new array.\n\nAll methods return a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.\n\nCalled at the array level the returned tuple will also include the previous reference dims attached to the array.\n\nArguments\n\nf: a function getindex,  view or dotview. This will be used for slicing   getindex is the default if f is not included.\nx: An AbstractDimArray, Tuple of Dimension, or Dimension\nI: A tuple of Integer, Colon or AbstractArray\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.comparedims","page":"API","title":"DimensionalData.Dimensions.comparedims","text":"comparedims(A::AbstractDimArray...; kw...)\ncomparedims(A::Tuple...; kw...)\ncomparedims(a, b; kw...)\n\nCheck that dimensions or tuples of dimensions are the same, and return the first valid dimension. If AbstractDimArrays are passed as arguments their dimensions are compared.\n\nEmpty tuples and nothing dimension values are ignored, returning the Dimension value if it exists.\n\nKeywords\n\nThese are all Bool flags:\n\ntype: compare complete type, true by default.\nlookuptype: compare wrapped LookupArray type, false by default. \nlength: compare lengths, true by default.\nignore_length_one: ignore length 1 in comparisons, and return whichever   dimension is not length 1, if any. This is useful in e.g. broadcasting comparisons.   false by default.\nvalue: compare all values in each LookupArray are identical, false by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.combinedims","page":"API","title":"DimensionalData.Dimensions.combinedims","text":"combinedims(xs; check=true)\n\nCombine the dimensions of each object in xs, in the order they are found.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.otherdims","page":"API","title":"DimensionalData.Dimensions.otherdims","text":"otherdims(x, query) => Tuple{Vararg{Dimension,N}}\n\nGet the dimensions of an object not in query.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension.\nquery: Tuple or single Dimension or dimension Type.\nf: <: by default, but can be >: to match abstract types to concrete types.\n\nA tuple holding the unmatched dimensions is always returned.\n\nExample\n\njulia> using DimensionalData, DimensionalData.Dimensions\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> otherdims(A, X)\nY, Z\n\njulia> otherdims(A, (Y, Z))\nX\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.commondims","page":"API","title":"DimensionalData.Dimensions.commondims","text":"commondims([f], x, query) => Tuple{Vararg{Dimension}}\n\nThis is basically dims(x, query) where the order of the original is kept, unlike dims where the query tuple determines the order\n\nAlso unlike dims,commondims always returns a Tuple, no matter the input. No errors are thrown if dims are absent from either x or query.\n\nf is <: by default, but can be >: to sort abstract types by concrete types.\n\njulia> using DimensionalData, .Dimensions\n\njulia> A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia> commondims(A, X)\nX\n\njulia> commondims(A, (X, Z))\nX, Z\n\njulia> commondims(A, Ti)\n()\n\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.sortdims","page":"API","title":"DimensionalData.Dimensions.sortdims","text":"sortdims([f], tosort, order) => Tuple\n\nSort dimensions tosort by order. Dimensions in order but missing from tosort are replaced with nothing.\n\ntosort and order can be Tuples or Vectors or Dimension or dimension type. Abstract supertypes like TimeDim can be used in order.\n\nf is <: by default, but can be >: to sort abstract types by concrete types.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.basetypeof","page":"API","title":"DimensionalData.Dimensions.LookupArrays.basetypeof","text":"basetypeof(x) => Type\n\nGet the \"base\" type of an object - the minimum required to define the object without it's fields. By default this is the full UnionAll for the type. But custom basetypeof methods can be defined for types with free type parameters.\n\nIn DimensionalData this is primariliy used for comparing Dimensions, where Dim{:x} is different from Dim{:y}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.setdims","page":"API","title":"DimensionalData.Dimensions.setdims","text":"setdims(X, newdims) => AbstractArray\nsetdims(::Tuple, newdims) => Tuple{Vararg{Dimension,N}}\n\nReplaces the first dim matching <: basetypeof(newdim) with newdim, and returns a new object or tuple with the dimension updated.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nnewdim: Tuple or single Dimension, Type or Symbol.\n\nExample\n\nusing DimensionalData, DimensionalData.Dimensions, DimensionalData.LookupArrays\nA = ones(X(10), Y(10:10:100))\nB = setdims(A, Y(Categorical('a':'j'; order=ForwardOrdered())))\nlookup(B, Y)\n# output\nCategorical{Char} ForwardOrdered\nwrapping: 'a':1:'j'\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.dimsmatch","page":"API","title":"DimensionalData.Dimensions.dimsmatch","text":"dimsmatch([f], dim, query) => Bool\ndimsmatch([f], dims::Tuple, query::Tuple) => Bool\n\nCompare 2 dimensions or Tuple of Dimension are of the same base type, or are at least rotations/transformations of the same type.\n\nf is <: by default, but can be >: to match abstract types to concrete types.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.dimstride","page":"API","title":"DimensionalData.Dimensions.dimstride","text":"dimstride(x, dim) => Int\n\nGet the stride of the dimension relative to the other dimensions.\n\nThis may or may not be equal to the stride of the related array, although it will be for Array.\n\nArguments\n\nx is any object with a dims method, or a Tuple of Dimension.\ndim is a Dimension, Dimension type, or and Int. Using an Int is not type-stable.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims_title","page":"API","title":"DimensionalData.refdims_title","text":"refdims_title(A::AbstractDimArray)\nrefdims_title(refdims::Tuple)\nrefdims_title(refdim::Dimension)\n\nGenerate a title string based on reference dimension values.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.rebuild_from_arrays","page":"API","title":"DimensionalData.rebuild_from_arrays","text":"rebuild_from_arrays(s::AbstractDimStack, das::NamedTuple{<:Any,<:Tuple{Vararg{AbstractDimArray}}}; kw...)\n\nRebuild an AbstractDimStack from a NamedTuple of AbstractDimArray and an existing stack.\n\nKeywords\n\nKeywords are simply the fields of the stack object:\n\ndata\ndims\nrefdims\nmetadata\nlayerdims\nlayermetadata\n\n\n\n\n\n","category":"function"},{"location":"api/#LookupArrays","page":"API","title":"LookupArrays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.LookupArrays","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays","page":"API","title":"DimensionalData.Dimensions.LookupArrays","text":"LookupArrays\n\nModule for LookupArrays and [Selector]s used in DimensionalData.jl\n\nLookupArrays defines traits and AbstractArray wrappers that give specific behaviours for a lookup index when indexed with Selector.\n\nFor example, these allow tracking over array order so fast indexing works evne when  the array is reversed.\n\nTo load LookupArrays types and methods into scope:\n\nusing DimensionalData\nusing .LookupArrays\n\n\n\n\n\n","category":"module"},{"location":"api/#Selectors","page":"API","title":"Selectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.Selector\r\nLookupArrays.IntSelector\r\nLookupArrays.ArraySelector\r\nAt\r\nNear\r\nBetween\r\nTouches\r\nContains\r\nWhere\r\nAll","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Selector","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Selector","text":"Selector\n\nAbstract supertype for all selectors.\n\nSelectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as DateTime objects for a Ti dimension.\n\nSelectors provided in DimensionalData are:\n\nAt\nBetween\nTouches\nNear\nWhere\nContains\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.IntSelector","page":"API","title":"DimensionalData.Dimensions.LookupArrays.IntSelector","text":"IntSelector <: Selector\n\nAbstract supertype for Selectors that return a single Int index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.ArraySelector","page":"API","title":"DimensionalData.Dimensions.LookupArrays.ArraySelector","text":"ArraySelector <: Selector\n\nAbstract supertype for Selectors that return an AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.At","page":"API","title":"DimensionalData.Dimensions.LookupArrays.At","text":"At <: IntSelector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Near","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","text":"Near <: IntSelector\n\nNear(x)\n\nSelector that selects the nearest index to x.\n\nWith Points this is simply the index values nearest to the x, however with Intervals it is the interval center nearest to x. This will be offset from the index value for Start and End loci.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Between","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Between","text":"Between <: ArraySelector\n\nBetween(a, b)\n\nDepreciated: use a..b instead of Between(a, b). Other Interval objects from IntervalSets.jl, like `OpenInterval(a, b) will also work, giving the correct open/closed boundaries.\n\nBetween will e removed in furture to avoid clashes with DataFrames.Between.\n\nSelector that retreive all indices located between 2 values, evaluated with >= for the lower value, and < for the upper value. This means the same value will not be counted twice in 2 adjacent Between selections.\n\nFor Intervals the whole interval must be lie between the values. For Points the points must fall between the values. Different Sampling types may give different results with the same input - this is the intended behaviour.\n\nBetween for Irregular intervals is a little complicated. The interval is the distance between a value and the next (for Start locus) or previous (for End locus) value.\n\nFor Center, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use Between with Irregular Intervals(Center()) with caution.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Between(15, 25)), Y(Between(4, 6.5))]\n\n# output\n\n1×2 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points\n     5  6\n 20  4  5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Touches","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Touches","text":"Touches <: ArraySelector\n\nTouches(a, b)\n\nSelector that retreives all indices touching the closed interval 2 values, for the maximum possible area that could interact with the supplied range.\n\nThis can be better than .. when e.g. subsetting an area to rasterize, as you may wish to include pixels that just touch the area, rather than those that fall within it.\n\nTouches is different to using closed intervals when the lookups also contain intervals - if any of the intervals touch, they are included. With .. they are discarded unless the whole cell interval falls inside the selector interval.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Touches(15, 25)), Y(Touches(4, 6.5))]\n\n# output\n1×2 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points\n     5  6\n 20  4  5\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Contains","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Contains","text":"Contains <: IntSelector\n\nContains(x)\n\nSelector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.\n\nCan only be used for Intervals or Categorical.\n\nExample\n\nusing DimensionalData; const DD = DimensionalData\ndims_ = X(10:10:20; sampling=DD.Intervals(DD.Center())),\n        Y(5:7; sampling=DD.Intervals(DD.Center()))\nA = DimArray([1 2 3; 4 5 6], dims_)\nA[X(Contains(8)), Y(Contains(6.8))]\n\n# output\n3\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Where","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Where","text":"Where <: ArraySelector\n\nWhere(f::Function)\n\nSelector that filters a dimension lookup by any function that accepts a single value and returns a Bool.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))\nA[X(Where(x -> x > 15)), Y(Where(x -> x in (19, 21)))]\n\n# output\n\n1×2 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} Int64[20] ForwardOrdered Regular Points,\n  Y Sampled{Int64} Int64[19, 21] ForwardOrdered Regular Points\n     19  21\n 20   4   6\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.All","page":"API","title":"DimensionalData.Dimensions.LookupArrays.All","text":"All <: Selector\n\nAll(selectors::Selector...)\n\nSelector that combines the results of other selectors.  The indices used will be the union of all result sorted in ascending order.\n\nExample\n\nusing DimensionalData, Unitful\n\ndimz = X(10.0:20:200.0), Ti(1u\"s\":5u\"s\":100u\"s\")\nA = DimArray((1:10) * (1:20)', dimz)\nA[X=All(At(10.0), At(50.0)), Ti=All(1u\"s\"..10u\"s\", 90u\"s\"..100u\"s\")]\n\n# output\n\n2×4 DimArray{Int64,2} with dimensions:\n  X Sampled{Float64} Float64[10.0, 50.0] ForwardOrdered Regular Points,\n  Ti Sampled{Quantity{Int64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}} Quantity{Int64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}[1 s, 6 s, 91 s, 96 s] ForwardOrdered Regular Points\n       1 s  6 s  91 s  96 s\n 10.0    1    2    19    20\n 50.0    3    6    57    60\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Lookup properties:","category":"page"},{"location":"api/","page":"API","title":"API","text":"bounds\r\nLookupArrays.val","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.bounds","page":"API","title":"DimensionalData.Dimensions.LookupArrays.bounds","text":"bounds(xs, [dims::Tuple]) => Tuple{Vararg{Tuple{T,T}}}\nbounds(xs::Tuple) => Tuple{Vararg{Tuple{T,T}}}\nbounds(x, dim) => Tuple{T,T}\nbounds(dim::Union{Dimension,LookupArray}) => Tuple{T,T}\n\nReturn the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.\n\ndims can be a Dimension, a dimension type, or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.val","page":"API","title":"DimensionalData.Dimensions.LookupArrays.val","text":"val(x)\nval(dims::Tuple) => Tuple\n\nReturn the contained value of a wrapper object.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nObjects that don't define a val method are returned unaltered.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.LookupArray\r\nLookupArrays.Aligned\r\nLookupArrays.AbstractSampled\r\nLookupArrays.Sampled\r\nLookupArrays.AbstractCategorical\r\nLookupArrays.Categorical\r\nLookupArrays.Unaligned\r\nLookupArrays.Transformed\r\nDimensions.MergedLookup\r\nLookupArrays.NoLookup\r\nLookupArrays.AutoLookup\r\nLookupArrays.AutoIndex","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.LookupArray","page":"API","title":"DimensionalData.Dimensions.LookupArrays.LookupArray","text":"LookupArray\n\nTypes defining the behaviour of a lookup index, how it is plotted and how Selectors like Between work.\n\nA LookupArray may be NoLookup indicating that the index is just the underlying array axis, Categorical for ordered or unordered categories,  or a Sampled index for Points or Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Aligned","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Aligned","text":"Aligned <: LookupArray\n\nAbstract supertype for LookupArrays where the index is aligned with the array axes.\n\nThis is by far the most common supertype for LookupArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AbstractSampled","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AbstractSampled","text":"AbstractSampled <: Aligned\n\nAbstract supertype for LookupArrays where the index is aligned with the array, and is independent of other dimensions. Sampled is provided by this package.\n\nAbstractSampled must have  order, span and sampling fields, or a rebuild method that accpts them as keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Sampled","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Sampled","text":"Sampled <: AbstractSampled\n\nSampled(data::AbstractVector, order::Order, span::Span, sampling::Sampling, metadata)\nSampled(; data=AutoIndex(), order=AutoOrder(), span=AutoSpan(), sampling=Points(), metadata=NoMetadata())\n\nA concrete implementation of the LookupArray AbstractSampled. It can be used to represent Points or Intervals.\n\nSampled is capable of representing gridded data from a wide range of sources, allowing correct bounds and Selectors for points or intervals of regular, irregular, forward and reverse indexes.\n\nOn AbstractDimArray construction, Sampled lookup is assigned for all lookups of  AbstractRange not assigned to Categorical.\n\nArguments\n\ndata: An AbstractVector of index values, matching the length of the curresponding   array axis. \norder: Order) indicating the order of the index,   AutoOrder by default, detected from the order of data   to be ForwardOrdered, ReverseOrdered or Unordered.   These can be provided explicitly if they are known and performance is important.\nspan: indicates the size of intervals or distance between points, and will be set to   Regular for AbstractRange and Irregular for AbstractArray,   unless assigned manually.\nsampling: is assigned to Points, unless set to Intervals manually.    Using Intervals will change the behaviour of bounds and Selectorss   to take account for the full size of the interval, rather than the point alone.\nmetadata: a Dict or Metadata wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is NoMetadata().\n\nExample\n\nCreate an array with [Interval] sampling, and Regular span for a vector with known spacing.\n\nWe set the Locus of the Intervals to Start specifying that the index values are for the positions at the start of each interval.\n\nusing DimensionalData, DimensionalData.LookupArrays\n\nx = X(Sampled(100:-20:10; sampling=Intervals(Start())))\ny = Y(Sampled([1, 4, 7, 10]; span=Regular(3), sampling=Intervals(Start())))\nA = ones(x, y)\n\n# output\n5×4 DimArray{Float64,2} with dimensions:\n  X Sampled{Int64} 100:-20:20 ReverseOrdered Regular Intervals,\n  Y Sampled{Int64} Int64[1, 4, 7, 10] ForwardOrdered Regular Intervals\n      1    4    7    10\n 100  1.0  1.0  1.0   1.0\n  80  1.0  1.0  1.0   1.0\n  60  1.0  1.0  1.0   1.0\n  40  1.0  1.0  1.0   1.0\n  20  1.0  1.0  1.0   1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AbstractCategorical","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AbstractCategorical","text":"AbstractCategorical <: Aligned\n\nLookupArrays where the values are categories.\n\nCategorical is the provided concrete implementation.  but this can easily be extended - all methods are defined for AbstractCategorical.\n\nAll AbstractCategorical must provide a rebuild method with data, order and metadata keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Categorical","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Categorical","text":"Categorical <: AbstractCategorical\n\nCategorical(o::Order)\nCategorical(; order=Unordered())\n\nAn LookupArray where the values are categories.\n\nThis will be automatically assigned if the index contains AbstractString, Symbol or Char. Otherwise it can be assigned manually.\n\nOrder will be determined automatically where possible.\n\nArguments\n\ndata: An AbstractVector of index values, matching the length of the curresponding   array axis. \norder: Order) indicating the order of the index,   AutoOrder by default, detected from the order of data   to be ForwardOrdered, ReverseOrdered or Unordered.   Can be provided if this is known and performance is important.\nmetadata: a Dict or Metadata wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is NoMetadata().\n\nExample\n\nCreate an array with [Interval] sampling.\n\nusing DimensionalData\n\nds = X([\"one\", \"two\", \"three\"]), Y([:a, :b, :c, :d])\nA = DimArray(rand(3, 4), ds)\nDimensions.lookup(A)\n\n# output\n\nCategorical{String} String[one, two, three] Unordered,\nCategorical{Symbol} Symbol[a, b, c, d] ForwardOrdered\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Unaligned","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Unaligned","text":"Unaligned <: LookupArray\n\nAbstract supertype for LookupArray where the index is not aligned to the grid.\n\nIndexing an Unaligned with Selectors must provide all other Unaligned dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Transformed","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Transformed","text":"Transformed <: Unaligned\n\nTransformed(f, dim::Dimension; metadata=NoMetadata())\n\nLookupArray that uses an affine transformation to convert dimensions from dims(lookup) to dims(array). This can be useful when the dimensions are e.g. rotated from a more commonly used axis.\n\nAny function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.\n\nArguments\n\nf: transformation function\ndim: a dimension to transform to.\n\nKeyword Arguments\n\nmetdata: \n\nExample\n\nusing DimensionalData, DimensionalData.LookupArrays, CoordinateTransformations\n\nm = LinearMap([0.5 0.0; 0.0 0.5])\nA = [1 2  3  4\n     5 6  7  8\n     9 10 11 12];\nda = DimArray(A, (t1=Transformed(m, X), t2=Transformed(m, Y)))\n\nda[X(At(6)), Y(At(2))]\n\n# output\n9\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.MergedLookup","page":"API","title":"DimensionalData.Dimensions.MergedLookup","text":"MergedLookup <: LookupArray\n\nMergedLookup(data, dims; [metadata])\n\nA LookupArray that holds multiple combined dimensions.\n\nMergedLookup can be indexed with Selectors like At,  Between, and Where although Near has undefined meaning.\n\nArguments\n\ndata: A Vector of Tuple.\ndims: A Tuple of Dimension indicating the dimensions in the tuples in data.\n\nKeywords\n\nmetadata: a Dict or Metadata object to attach dimension metadata.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.NoLookup","page":"API","title":"DimensionalData.Dimensions.LookupArrays.NoLookup","text":"NoLookup <: LookupArray\n\nNoLookup()\n\nA LookupArray that is identical to the array axis.  Selectors can't be used on this lookup.\n\nExample\n\nDefining a DimArray without passing an index to the dimensions, it will be assigned NoLookup:\n\nusing DimensionalData\n\nA = DimArray(rand(3, 3), (X, Y))\nDimensions.lookup(A)\n\n# output\n\nNoLookup, NoLookup\n\nWhich is identical to:\n\nusing .LookupArrays\nA = DimArray(rand(3, 3), (X(NoLookup()), Y(NoLookup())))\nDimensions.lookup(A)\n\n# output\n\nNoLookup, NoLookup\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AutoLookup","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AutoLookup","text":"AutoLookup <: LookupArray\n\nAutoLookup()\nAutoLookup(index=AutoIndex(); kw...)\n\nAutomatic LookupArray, the default lookup. It will be converted automatically to another LookupArray when it is possible to detect it from the index.\n\nKeywords will be used in the detected LookupArray constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AutoIndex","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AutoIndex","text":"AutoIndex\n\nDetect a LookupArray index from the context. This is used in NoLookup to simply use the array axis as the index when the array is constructed, and in set to change the LookupArray type without changing the index values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Metadata","page":"API","title":"Metadata","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.AbstractMetadata\r\nLookupArrays.Metadata\r\nLookupArrays.NoMetadata","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AbstractMetadata","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AbstractMetadata","text":"AbstractMetadata{X,T}\n\nAbstract supertype for all metadata wrappers.\n\nMetadata wrappers allow tracking the contents and origin of metadata. This can  facilitate conversion between metadata types (for saving a file to a differenet format) or simply saving data back to the same file type with identical metadata.\n\nUsing a wrapper instead of Dict or NamedTuple also lets us pass metadata  objects to set without ambiguity about where to put them.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Metadata","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Metadata","text":"Metadata <: AbstractMetadata\n\nMetadata{X}(val::Union{Dict,NamedTuple})\nMetadata{X}(pairs::Pair...) => Metadata{Dict}\nMetadata{X}(; kw...) => Metadata{NamedTuple}\n\nGeneral Metadata object. The X type parameter categorises the metadata for method dispatch, if required. \n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.NoMetadata","page":"API","title":"DimensionalData.Dimensions.LookupArrays.NoMetadata","text":"NoMetadata <: AbstractMetadata\n\nNoMetadata()\n\nIndicates an object has no metadata. But unlike using nothing,  get, keys and haskey will still work on it, get always returning the fallback argument. keys returns () while haskey always returns false.\n\n\n\n\n\n","category":"type"},{"location":"api/#LookupArray-traits","page":"API","title":"LookupArray traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.LookupArrayTrait","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.LookupArrayTrait","page":"API","title":"DimensionalData.Dimensions.LookupArrays.LookupArrayTrait","text":"LookupArrayTrait\n\nAbstract supertype of all traits of a LookupArray.\n\nThese modify the behaviour of the lookup index.\n\nThe term \"Trait\" is used loosely - these may be fields of an object of traits hard-coded to specific types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Order","page":"API","title":"Order","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.Order\r\nLookupArrays.Ordered\r\nLookupArrays.ForwardOrdered\r\nLookupArrays.ReverseOrdered\r\nLookupArrays.Unordered\r\nLookupArrays.AutoOrder","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Order","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Order","text":"Order <: LookupArrayTrait\n\nTraits for the order of a LookupArray. These determine how searchsorted finds values in the index, and how objects are plotted.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Ordered","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Ordered","text":"Ordered <: Order\n\nSupertype for the order of an ordered LookupArray, including ForwardOrdered and ReverseOrdered.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.ForwardOrdered","page":"API","title":"DimensionalData.Dimensions.LookupArrays.ForwardOrdered","text":"ForwardOrdered <: Ordered\n\nForwardOrdered()\n\nIndicates that the LookupArray index is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.ReverseOrdered","page":"API","title":"DimensionalData.Dimensions.LookupArrays.ReverseOrdered","text":"ReverseOrdered <: Ordered\n\nReverseOrdered()\n\nIndicates that the LookupArray index is in the reverse order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Unordered","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Unordered","text":"Unordered <: Order\n\nUnordered()\n\nIndicates that LookupArray is unordered.\n\nThis means the index cannot be searched with searchsortedfirst or similar optimised methods - instead it will use findfirst.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AutoOrder","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AutoOrder","text":"AutoOrder <: Order\n\nAutoOrder()\n\nSpecifies that the Order of a LookupArray will be found automatically where possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#Span","page":"API","title":"Span","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.Span\r\nLookupArrays.Regular\r\nLookupArrays.Irregular\r\nLookupArrays.Explicit\r\nLookupArrays.AutoSpan","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Span","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Span","text":"Span <: LookupArrayTrait\n\nDefines the type of span used in a Sampling index. These are Regular or Irregular.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Regular","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Regular","text":"Regular <: Span\n\nRegular(step=AutoStep())\n\nPoints or Intervals that have a fixed, regular step.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Irregular","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Irregular","text":"Irregular <: Span\n\nIrregular(bounds::Tuple)\nIrregular(lowerbound, upperbound)\n\nPoints or Intervals that have an Irrigular step size. To enable bounds tracking and accuract selectors, the starting bounds are provided as a 2 tuple, or 2 arguments. (nothing, nothing) is acceptable input, the bounds will be guessed from the index, but may be innaccurate.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Explicit","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Explicit","text":"Explicit(bounds::AbstractMatix)\n\nIntervals where the span is explicitly listed for every interval.\n\nThis uses a matrix where with length 2 columns for each index value, holding the lower and upper bounds for that specific index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AutoSpan","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AutoSpan","text":"AutoSpan <: Span\n\nAutoSpan()\n\nThe span will be guessed and replaced in format or set.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.Sampling\r\nLookupArrays.Points\r\nLookupArrays.Intervals","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Sampling","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Sampling","text":"Sampling <: LookupArrayTrait\n\nIndicates the sampling method used by the index: Points or Intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Points","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Points","text":"Points <: Sampling\n\nPoints()\n\nSampling lookup where single samples at exact points.\n\nThese are always plotted at the center of array cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Intervals","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Intervals","text":"Intervals <: Sampling\n\nIntervals(locus::Locus)\n\nSampling specifying that sampled values are the mean (or similar) value over an interval, rather than at one specific point.\n\nIntervals require a Locus of Start, Center or End to define the location in the interval that the index values refer to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Loci","page":"API","title":"Loci","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LookupArrays.Locus\r\nLookupArrays.Center\r\nLookupArrays.Start\r\nLookupArrays.End\r\nLookupArrays.AutoLocus","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Locus","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Locus","text":"Locus <: LookupArrayTrait\n\nAbstract supertype of types that indicate the position of index values  where they represent Intervals.\n\nThese allow for values array cells to align with the Start, Center, or End of values in the lookup index.\n\nThis means they can be plotted with correct axis markers, and allows automatic converrsions to between formats with different standards (such as NetCDF and GeoTiff).\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Center","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Center","text":"Center <: Locus\n\nCenter()\n\nIndicates a lookup value is for the center of its corresponding array cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.Start","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Start","text":"Start <: Locus\n\nStart()\n\nIndicates a lookup value is for the start of its corresponding array cell, in the direction of the lookup index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.End","page":"API","title":"DimensionalData.Dimensions.LookupArrays.End","text":"End <: Locus\n\nEnd()\n\nIndicates a lookup value is for the end of its corresponding array cell, in the direction of the lookup index order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.AutoLocus","page":"API","title":"DimensionalData.Dimensions.LookupArrays.AutoLocus","text":"AutoLocus <: Locus\n\nAutoLocus()\n\nIndicates a interval where the index position is not yet known. This will be filled with a default value on object construction.\n\n\n\n\n\n","category":"type"},{"location":"api/#LookupArrays-methods","page":"API","title":"LookupArrays methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"hasselection\r\nLookupArrays.shiftlocus\r\nLookupArrays.sampling\r\nLookupArrays.span\r\nLookupArrays.order\r\nLookupArrays.index\r\nLookupArrays.locus\r\nLookupArrays.units","category":"page"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.hasselection","page":"API","title":"DimensionalData.Dimensions.LookupArrays.hasselection","text":"hasselection(x, selector) => Bool\nhasselection(x, selectors::Tuple) => Bool\n\nCheck if indexing into x with selectors can be performed, where x is some object with a dims method, and selectors is a Selector or Dimension or a tuple of either.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.shiftlocus","page":"API","title":"DimensionalData.Dimensions.LookupArrays.shiftlocus","text":"shiftlocus(locus::Locus, x)\n\nShift the index of x from the current locus to the new locus.\n\nWe only shift Sampled, Regular or Explicit, Intervals. \n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.sampling","page":"API","title":"DimensionalData.Dimensions.LookupArrays.sampling","text":"sampling(x, [dims::Tuple]) => Tuple\nsampling(x, dim) => Sampling\nsampling(xs::Tuple) => Tuple{Vararg{Sampling}}\nsampling(x:Union{Dimension,LookupArray}) => Sampling\n\nReturn the Sampling for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.span","page":"API","title":"DimensionalData.Dimensions.LookupArrays.span","text":"span(x, [dims::Tuple]) => Tuple\nspan(x, dim) => Span\nspan(xs::Tuple) => Tuple{Vararg{Span,N}}\nspan(x::Union{Dimension,LookupArray}) => Span\n\nReturn the Span for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.order","page":"API","title":"DimensionalData.Dimensions.LookupArrays.order","text":"order(x, [dims::Tuple]) => Tuple\norder(xs::Tuple) => Tuple\norder(x::Union{Dimension,LookupArray}) => Order\n\nReturn the Ordering of the dimension index for each dimension: ForwardOrdered, ReverseOrdered, or Unordered \n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.index","page":"API","title":"DimensionalData.Dimensions.LookupArrays.index","text":"index(x) => Tuple{Vararg{AbstractArray}}\nindex(x, dims::Tuple) => Tuple{Vararg{AbstractArray}}\nindex(dims::Tuple) => Tuple{Vararg{AbstractArray}}}\nindex(x, dim) => AbstractArray\nindex(dim::Dimension) => AbstractArray\n\nReturn the contained index of a Dimension.\n\nOnly valid when a Dimension contains an AbstractArray or a Val tuple like Val{(:a, :b)}(). The Val is unwrapped to return just the Tuple\n\ndims can be a Dimension, or a tuple of Dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.locus","page":"API","title":"DimensionalData.Dimensions.LookupArrays.locus","text":"locus(x, [dims::Tuple]) => Tuple\nlocus(x, dim) => Locus\nlocus(xs::Tuple) => Tuple{Vararg{Locus,N}}\nlocus(x::Union{Dimension,LookupArray}) => Locus\n\nReturn the Locus for each dimension.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.LookupArrays.units","page":"API","title":"DimensionalData.Dimensions.LookupArrays.units","text":"units(x) => Union{Nothing,Any}\nunits(xs:Tuple) => Tuple\nunit(A::AbstractDimArray, dims::Tuple) => Tuple\nunit(A::AbstractDimArray, dim) => Union{Nothing,Any}\n\nGet the units of an array or Dimension, or a tuple of of either.\n\nUnits do not have a set field, and may or may not be included in metadata. This method is to facilitate use in labels and plots when units are available, not a guarantee that they will be. If not available, nothing is returned.\n\nSecond argument dims can be Dimensions, Dimension types, or Symbols for Dim{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Name","page":"API","title":"Name","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DimensionalData.AbstractName\r\nDimensionalData.Name\r\nDimensionalData.NoName","category":"page"},{"location":"api/#DimensionalData.AbstractName","page":"API","title":"DimensionalData.AbstractName","text":"AbstractName\n\nAbstract supertype for name wrappers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Name","page":"API","title":"DimensionalData.Name","text":"Name <: AbstractName\n\nName(name::Union{Symbol,Name) => Name\nName(name::NoName) => NoName\n\nName wrapper. This lets arrays keep symbol names when the array wrapper neeeds to be `isbits, like for use on GPUs. It makes the name a property of the type. It's not necessary to use in normal use, a symbol is probably easier.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoName","page":"API","title":"DimensionalData.NoName","text":"NoName <: AbstractName\n\nNoName()\n\nNoName specifies an array is not named, and is the default name value for all AAbstractDimArrays.\n\n\n\n\n\n","category":"type"},{"location":"developer/#For-package-developers","page":"For Developers","title":"For package developers","text":"","category":"section"},{"location":"developer/#Goals:","page":"For Developers","title":"Goals:","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated.\nFlexibility: dims and selectors are parametric types with multiple uses\nAbstraction: never dispatch on concrete types, maximum re-usability of methods\nClean, readable syntax. Minimise required parentheses, minimise of exported methods, and instead extend Base methods whenever possible.\nMinimal interface: implementing a dimension-aware type should be easy.\nFunctional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.\nLaziness. Label data correctly, and manipulate them when needed -  instead of standardising eagerly.\nLeast surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or dims=X in base, you should be able to use DimensionalData.jl dims.\nType stability: dimensional methods should be type stable more often than Base methods\nZero cost dimensional indexing a[Y(4), X(5)] of a single value.\nLow cost indexing for range getindex and views: these cant be zero cost as dim ranges have to be updated.\nPlotting is easy: data should plot sensibly and correctly with useful labels - after all transformations using dims or indices\nPrioritise spatial data: other use cases are a free bonus of the modular approach.","category":"page"},{"location":"developer/#Why-this-package","page":"For Developers","title":"Why this package","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Why not AxisArrays.jl or NamedDims.jl?","category":"page"},{"location":"developer/#Structure","page":"For Developers","title":"Structure","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Both AxisArrays and NamedDims use concrete types for dispatch on arrays, and for dimension type Axis in AxisArrays. This makes them hard to extend.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Its a little easier with DimensionalData.jl. You can inherit from AbstractDimArray, or just implement dims and rebuild methods. Dims and selectors in DimensionalData.jl are also extensible. Recursive primitive methods allow inserting whatever methods you want to add extra types. @generated is only used to match and permute arbitrary tuples of types, and contain no type-specific details. The @generated functions in AxisArrays internalise axis/index conversion behaviour preventing extension in external packages and scripts.","category":"page"},{"location":"developer/#Syntax","page":"For Developers","title":"Syntax","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"AxisArrays.jl is verbose by default: a[Axis{:y}(1)] vs a[Y(1)] used here. NamedDims.jl has concise syntax, but the dimensions are no longer types, NamedDims.jl syntax can now be replicated using Dim{:X}: ","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"A = DimArray(rand(4, 5), (:a, :b))\r\nA[:b=5, :a=3] = 25.0","category":"page"},{"location":"developer/#Data-types-and-the-interface","page":"For Developers","title":"Data types and the interface","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"DimensionalData.jl provides the concrete DimArray type. But it's core purpose is to be easily used with other array types.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Some of the functionality in DimensionalData.jl will work without inheriting from AbstractDimArray. The main requirement define a dims method that returns a Tuple of Dimension that matches the dimension order and axis values of your data. Define rebuild, and base methods for similar and parent if you want the metadata to persist through transformations (see the DimArray and AbstractDimArray types). A refdims method returns the lost dimensions of a previous transformation, passed in to the rebuild method. refdims can be discarded, the main loss being plot labels.","category":"page"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"Inheriting from AbstractDimArray will give nearly all the functionality of using DimArray.","category":"page"},{"location":"developer/#LookupArrays-and-Dimensions","page":"For Developers","title":"LookupArrays and Dimensions","text":"","category":"section"},{"location":"developer/","page":"For Developers","title":"For Developers","text":"LookupArrays and Dimensions","category":"page"},{"location":"course/#Crash-course","page":"Crash course","title":"Crash course","text":"","category":"section"},{"location":"course/#Dimensions-and-DimArrays","page":"Crash course","title":"Dimensions and DimArrays","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The core type of DimensionalData.jl is the Dimension and the types that inherit from it, such as Ti, X, Y, Z, the generic Dim{:x}, or others that you define manually using the @dim macro.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions are primarily used in DimArray, other AbstractDimArray.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can use dimensions without a value index - these simply label the axis. A DimArray with labelled dimensions is constructed by:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA = rand(X(5), Y(5))\r\nA[Y(1), X(2)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"As shown above, Dimensions can be used to construct arrays in rand, ones, zeros and fill with either a range for a lookup index or a number for the dimension length.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Or we can use the Dim{X} dims by using Symbols, and indexing with keywords:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A = DimArray(rand(5, 5), (:a, :b))\r\nA[a=3, b=5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Often, we want to provide a lookup index for the dimension:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Dates\r\nt = DateTime(2001):Month(1):DateTime(2001,12)\r\nx = 10:10:100\r\nA = rand(X(x), Ti(t))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Here both X and Ti are dimensions from DimensionalData. The currently exported dimensions are X, Y, Z, Ti (Ti is shortening of Time).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The length of each dimension index has to match the size of the corresponding array axis. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This can also be done with Symbol, using Dim{X}:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A2 = DimArray(rand(12, 10), (time=t, distance=x))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Symbols can be more convenient to use than defining custom dims with @dim, but have some downsides. They don't inherit from a specific Dimension type, so plots will not know what axis to put them on. They also cannot use the basic constructor methods like rand or zeros, as we cannot dispatch on Symbol for Base methods without \"type-piracy\".","category":"page"},{"location":"course/#Indexing-the-array-by-name-and-index","page":"Crash course","title":"Indexing the array by name and index","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The simplest case is to select a dimension by index. Let's say every 2nd point of the Ti dimension and every 3rd point of the X dimension. This is done with the simple Ti(range) syntax like so:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:11), Ti(1:2:11)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"When specifying only one dimension, all elements of the other dimensions are assumed to be included:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(1:3:10)]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"info: Indexing\nIndexing AbstractDimArrays works with getindex, setindex! and view. The result is still an AbstracDimArray, unless using all single Int or Selectors that resolve to Int.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Dimensions can be used to construct arrays in rand, ones, zeros and fill with either a range for a lookup index or a number for the dimension length.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA1 = ones(X(1:40), Y(50))","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A1[Y(1), X(1:10)]","category":"page"},{"location":"course/#Indexing-Performance","page":"Crash course","title":"Indexing Performance","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Indexing with Dimension has no runtime cost:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"julia> A2 = ones(X(3), Y(3))\r\n3×3 DimArray{Float64,2} with dimensions: X, Y\r\n 1.0  1.0  1.0\r\n 1.0  1.0  1.0\r\n 1.0  1.0  1.0\r\n\r\njulia> @btime $A2[X(1), Y(2)]\r\n  1.077 ns (0 allocations: 0 bytes)\r\n1.0\r\n\r\njulia> @btime parent($A2)[1, 2]\r\n  1.078 ns (0 allocations: 0 bytes)\r\n1.0","category":"page"},{"location":"course/#Specifying-dims-keyword-arguments-with-Dimension","page":"Crash course","title":"Specifying dims keyword arguments with Dimension","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In many Julia functions like size or sum, you can specify the dimension along which to perform the operation as an Int. It is also possible to do this using Dimension types with AbstractDimArray:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A3 = rand(X(3), Y(4), Ti(5));\r\nsum(A3; dims=Ti)","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This also works in methods from Statistics:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Statistics\r\nmean(A3; dims=Ti)","category":"page"},{"location":"course/#Methods-where-dims,-dim-types,-or-Symbols-can-be-used-to-indicate-the-array-dimension:","page":"Crash course","title":"Methods where dims, dim types, or Symbols can be used to indicate the array dimension:","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"size, axes, firstindex, lastindex\ncat, reverse, dropdims\nreduce, mapreduce\nsum, prod, maximum, minimum,\nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice","category":"page"},{"location":"course/#LookupArrays-and-Selectors","page":"Crash course","title":"LookupArrays and Selectors","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Indexing by value in DimensionalData is done with Selectors. IntervalSets.jl is now used for selecting ranges of values (formerly Between).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selector Description\n[At(x)] get the index exactly matching the passed in value(s)\n[Near(x)] get the closest index to the passed in value(s)\n[Contains(x)] get indices where the value x falls within an interval\n[Where(f)] filter the array axis by a function of the dimension index values.\n[a..b] get all indices between two values, inclusively.\n[OpenInterval(a, b)] get all indices between a and b, exclusively.\n[Interval{A,B}(a, b)] get all indices between a and b, as :closed or :open.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selectors find indices in the LookupArray, for each dimension.  Here we use an Interval to select a range between integers and DateTime:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A[X(12..35), Ti(Date(2001, 5)..Date(2001, 7))]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selectors can be used in getindex, setindex! and view to select indices matching the passed in value(s)","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can use selectors inside dim wrappers, here selecting values from DateTime and Int:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Dates\r\ntimespan = DateTime(2001,1):Month(1):DateTime(2001,12)\r\nA4 = rand(Ti(timespan), X(10:10:100))\r\nA4[X(Near(35)), Ti(At(DateTime(2001,5)))]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Without dim wrappers selectors must be in the right order, and specify all axes:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using Unitful\r\nA5 = rand(Y((1:10:100)u\"m\"), Ti((1:5:100)u\"s\"));\r\nA5[10.5u\"m\" .. 50.5u\"m\", Near(23u\"s\")]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"We can also use Linear indices as in standard Array:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A5[1:5]","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"But unless the DimArray is one dimensional, this will return a regular Array. It is not possible to keep the LookupArray or even Dimensions after linear indexing is used.","category":"page"},{"location":"course/#LookupArrays-and-traits","page":"Crash course","title":"LookupArrays and traits","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Using a regular range or Vector as a lookup index has a number of downsides. We cannot use searchsorted for fast searches without knowing the order of the array, and this is slow to compute at runtime. It also means reverse or rotations cannot be used while keeping the DimArray wrapper.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Step sizes are also a problem. Some ranges like LinRange lose their step size with a length of 1. Often, instead of a range, multi-dimensional data formats provide a Vector of evenly spaced values for a lookup, with a step size specified separately. Converting to a range introduces floating point errors that means points may not be selected with At without setting tolerances.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This means using a lookup wrapper with traits is more generally robust and versatile than simply using a range or vector. DimensionalData provides types for specifying details about the dimension index, in the LookupArrays sub-module:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nusing .LookupArrays","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The main LookupArray are :","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Sampled \nCategorical,\nNoLookup","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Each comes with specific traits that are either fixed or variable, depending on the contained index. These enable optimisations with Selectors, and modified behaviours, such as:","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Selection of Intervals or Points, which will give slightly","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"different results for selectors like .. - as whole intervals are   selected, and have different bounds values.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Tracking of lookup order. A reverse order is labelled ReverseOrdered and","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"will still work with searchsorted, and for plots to always be the right way   up when either the index or the array is backwards. Reversing a DimArray   will reverse the LookupArray for that dimension, swapping ReverseOrdered   to ForwardOrdered.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Sampled Intervals can have index located at a Locus of: ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Start,\nCenter \nEnd","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Which specifies the point of the interval represented in the index, to match different data standards, e.g. GeoTIFF (Start) and NetCDF (Center).","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"A Span specifies the gap between Points or the size of","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Intervals. This may be: ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Regular, in the case of a range and equally spaced vector, \nIrregular for unequally spaced vectors\nExplicit for the case where all interval start and end points are specified explicitly - as is common in the NetCDF standard.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"These traits all for subtypes of Aligned.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Unaligned also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as Transformed.","category":"page"},{"location":"course/#LookupArray-detection","page":"Crash course","title":"LookupArray detection","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Aligned types will be detected automatically if not specified - which usually isn't required. ","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"An empty Dimension or a Type or Symbol will be assigned NoLookup - this behaves as a simple named dimension without a lookup index.\nA Dimension containing and index of String, Char, Symbol or mixed types will be given the Categorical mode,\nA range will be assigned Sampled, defaulting to  Regular, Points \nOther AbstractVector will be assigned Sampled Irregular Points.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"In all cases the Order of ForwardOrdered or ReverseOrdered will be be detected, otherwise Unordered for an unsorted Array.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"See the LookupArray API docs for more detail.","category":"page"},{"location":"course/#Referenced-dimensions","page":"Crash course","title":"Referenced dimensions","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes so that cat can reconstruct the lookup array from previous dimensions that have been sliced.","category":"page"},{"location":"course/#Warnings","page":"Crash course","title":"Warnings","text":"","category":"section"},{"location":"course/","page":"Crash course","title":"Crash course","text":"Indexing with unordered or reverse-ordered arrays has undefined behaviour. It will trash the dimension index, break searchsorted and nothing will make sense any more. So do it at you own risk.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"However, indexing with sorted vectors of Int can be useful, so it's allowed. But it may do strange things to interval sizes for Intervals that are not Explicit.","category":"page"},{"location":"course/","page":"Crash course","title":"Crash course","text":"This selects the first 5 entries of the underlying array. In the case that A has only one dimension, it will be retained. Multidimensional AbstracDimArray indexed this way will return a regular array.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index. It provides no-cost abstractions for named indexing, and fast index lookups.\n\nDimensionalData is a pluggable, generalised version of AxisArrays.jl with a cleaner syntax, and additional functionality found in NamedDims.jl. It has similar goals to pythons xarray, and is primarily written for use with spatial data in Rasters.jl.\n\nThe basic syntax is:\n\njulia> using DimensionalData\n\njulia> A = rand(X(50), Y(10.0:40.0))\n50×31 DimArray{Float64,2} with dimensions: \n  X,\n  Y Sampled{Float64} 10.0:1.0:40.0 ForwardOrdered Regular Points\n 10.0         11.0       12.0       13.0       14.0        15.0       16.0        17.0       …  32.0       33.0        34.0       35.0       36.0        37.0       38.0        39.0       40.0\n  0.293347     0.737456   0.986853   0.780584   0.707698    0.804148   0.632667    0.780715      0.767575   0.555214    0.872922   0.808766   0.880933    0.624759   0.803766    0.796118   0.696768\n  0.199599     0.290297   0.791926   0.564099   0.0241986   0.239102   0.0169679   0.186455      0.644238   0.467091    0.524335   0.42627    0.982347    0.324083   0.0356058   0.306446   0.117187\n  ⋮                                                         ⋮                                ⋱                                     ⋮                                                        ⋮\n  0.720404     0.388392   0.635609   0.430277   0.943823    0.661993   0.650442    0.91391   …   0.299713   0.518607    0.411973   0.410308   0.438817    0.580232   0.751231    0.519257   0.598583\n  0.00602102   0.270036   0.696129   0.139551   0.924883    0.190963   0.164888    0.13436       0.717962   0.0452556   0.230943   0.848782   0.0362465   0.363868   0.709489    0.644131   0.801824\n\njulia> A[Y=1:10, X=1]\n10-element DimArray{Float64,1} with dimensions: \n  Y Sampled{Float64} 10.0:1.0:19.0 ForwardOrdered Regular Points\nand reference dimensions: X\n 10.0  0.293347\n 11.0  0.737456\n 12.0  0.986853\n 13.0  0.780584\n  ⋮    \n 17.0  0.780715\n 18.0  0.472306\n 19.0  0.20442\n\nSee the docs for more details\n\nSome properties of DimensionalData.jl objects:\n\nbroadcasting and most Base methods maintain and sync dimension context.\ncomprehensive plot recipes for Plots.jl.\na Tables.jl interface with DimTable\nmulti-layered DimStacks that can be indexed together,    and have base methods applied to all layers.\nthe Adapt.jl interface for use on GPUs, even as GPU kernel arguments.\ntraits for handling a wide range of spatial data types accurately.\n\nMethods where dims can be used containing indices or Selectors\n\ngetindex, setindex! view\n\nMethods where dims, dim types, or Symbols can be used to indicate the array dimension:\n\nsize, axes, firstindex, lastindex\ncat, reverse, dropdims\nreduce, mapreduce\nsum, prod, maximum, minimum,\nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice\n\nMethods where dims can be used to construct DimArrays:\n\nfill, ones, zeros, falses, trues, rand\n\nNote: recent changes have greatly reduced the exported API\n\nPreviously exported methods can me brought into global scope by using the sub-modules they have been moved to - LookupArrays and Dimensions:\n\nusing DimensionalData\nusing DimensionalData.LookupArrays, DimensionalData.Dimensions\n\nAlternate Packages\n\nThere are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.\n\nAxisKeys.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread.\n\nThe main functionality is explained here, but the full list of features is listed at the API page.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn how to use this package, see the Crash course.","category":"page"}]
}
