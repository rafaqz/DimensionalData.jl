{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#dimensionaldata","title":"DimensionalData","text":"<p>DimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index.</p> <p>DimensionalData is a pluggable, generalised version of AxisArrays.jl with a cleaner syntax, and additional functionality found in NamedDims.jl. It has similar goals to pythons xarray, and is primarily written for use with spatial data in Rasters.jl.</p> <p></p> <p></p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Clean, readable syntax. Minimise required parentheses, minimise of exported</li> <li>Zero-cost dimensional indexing <code>a[Y(4), X(5)]</code> of a single value. methods, and instead extend Base methods whenever possible.</li> <li>Plotting is easy: data should plot sensibly and correctly with useful labels, by default.</li> <li>Least surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or <code>dims=X</code> in base, you should be able to use DimensionalData.jl dims.</li> <li>Minimal interface: implementing a dimension-aware type should be easy.</li> <li>Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated. Always dispatch on abstract types.</li> <li>Type stability: dimensional methods should be type stable more often than Base methods</li> <li>Functional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.</li> </ul>"},{"location":"#for-package-developers","title":"For package developers","text":""},{"location":"#data-types-and-the-interface","title":"Data types and the interface","text":"<p>DimensionalData.jl provides the concrete <code>DimArray</code> type. But its behaviours are intended to be easily applied to other array types.</p> more <p>The main requirement for extending DimensionalData.jl is to define a <code>dims</code> method that returns a <code>Tuple</code> of <code>Dimension</code> that matches the dimension order and axis values of your data. Define <code>rebuild</code> and base methods for <code>similar</code> and <code>parent</code> if you want the metadata to persist through transformations (see the <code>DimArray</code> and <code>AbstractDimArray</code> types). A <code>refdims</code> method returns the lost dimensions of a previous transformation, passed in to the <code>rebuild</code> method. <code>refdims</code> can be discarded, the main loss being plot labels and ability to reconstruct dimensions in <code>cat</code>.</p> <p>Inheriting from <code>AbstractDimArray</code> in this way will give nearly all the functionality of using <code>DimArray</code>.</p> <p></p> <p></p>"},{"location":"#lookuparrays-and-dimensions","title":"LookupArrays and Dimensions","text":"<p>Sub modules <code>LookupArrays</code> and <code>Dimensions</code> define the behviour of dimensions and their lookup index.</p> <p><code>LookupArrays</code> and <code>Dimensions</code></p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#api","title":"API","text":""},{"location":"reference/#arrays","title":"Arrays","text":"<p># <code>DimensionalData.AbstractDimArray</code> \u2014 Type.</p> <pre><code>AbstractDimArray &lt;: AbstractArray\n</code></pre> <p>Abstract supertype for all \"dim\" arrays.</p> <p>These arrays return a <code>Tuple</code> of <code>Dimension</code> from a <code>dims</code> method, and can be rebuilt using <code>rebuild</code>.</p> <p><code>parent</code> must return the source array.</p> <p>They should have <code>metadata</code>, <code>name</code> and <code>refdims</code> methods, although these are optional.</p> <p>A <code>rebuild</code> method for <code>AbstractDimArray</code> must accept <code>data</code>, <code>dims</code>, <code>refdims</code>, <code>name</code>, <code>metadata</code> arguments.</p> <p>Indexing <code>AbstractDimArray</code> with non-range <code>AbstractArray</code> has undefined effects on the <code>Dimension</code> index. Use forward-ordered arrays only\"</p> <p>source</p> <p># <code>DimensionalData.DimArray</code> \u2014 Type.</p> <pre><code>DimArray &lt;: AbstractDimArray\n\nDimArray(data, dims, refdims, name, metadata)\nDimArray(data, dims::Tuple; refdims=(), name=NoName(), metadata=NoMetadata())\n</code></pre> <p>The main concrete subtype of <code>AbstractDimArray</code>.</p> <p><code>DimArray</code> maintains and updates its <code>Dimension</code>s through transformations and moves dimensions to reference dimension <code>refdims</code> after reducing operations (like e.g. <code>mean</code>).</p> <p>Arguments</p> <ul> <li><code>data</code>: An <code>AbstractArray</code>.</li> <li><code>dims</code>: A <code>Tuple</code> of <code>Dimension</code></li> <li><code>name</code>: A string name for the array. Shows in plots and tables.</li> <li><code>refdims</code>: refence dimensions. Usually set programmatically to track past   slices and reductions of dimension for labelling and reconstruction.</li> <li><code>metadata</code>: <code>Dict</code> or <code>Metadata</code> object, or <code>NoMetadata()</code></li> </ul> <p>Indexing can be done with all regular indices, or with <code>Dimension</code>s and/or <code>Selector</code>s. </p> <p>Indexing <code>AbstractDimArray</code> with non-range <code>AbstractArray</code> has undefined effects on the <code>Dimension</code> index. Use forward-ordered arrays only\"</p> <p>Example:</p> <pre><code>using Dates, DimensionalData\n\nti = (Ti(DateTime(2001):Month(1):DateTime(2001,12)),\nx = X(10:10:100))\nA = DimArray(rand(12,10), (ti, x), \"example\")\n\njulia&gt; A[X(Near([12, 35])), Ti(At(DateTime(2001,5)))];\n\njulia&gt; A[Near(DateTime(2001, 5, 4)), Between(20, 50)];\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#multi-array-datasets","title":"Multi-array datasets","text":"<p># <code>DimensionalData.AbstractDimStack</code> \u2014 Type.</p> <pre><code>AbstractDimStack\n</code></pre> <p>Abstract supertype for dimensional stacks.</p> <p>These have multiple layers of data, but share dimensions.</p> <p>Notably, their behaviour lies somewhere between a <code>DimArray</code> and a <code>NamedTuple</code>:</p> <ul> <li>indexing with a <code>Symbol</code> as in <code>dimstack[:symbol]</code> returns a <code>DimArray</code> layer.</li> <li>iteration amd <code>map</code> are apply over array layers, as indexed with a <code>Symbol</code>.</li> <li><code>getindex</code> and many base methods are applied as for <code>DimArray</code> - to avoid the need    to allways use <code>map</code>.</li> </ul> <p>This design gives very succinct code when working with many-layered, mixed-dimension objects.  But it may be jarring initially - the most surprising outcome is that <code>dimstack[1]</code> will return a <code>NamedTuple</code> of values for the first index in all layers, while <code>first(dimstack)</code> will return the first value of the iterator - the <code>DimArray</code> for the first layer.</p> <p>See <code>DimStack</code> for the concrete implementation. Most methods are defined on the abstract type.</p> <p>To extend <code>AbstractDimStack</code>, implement argument and keyword version of  <code>rebuild</code> and also <code>rebuild_from_arrays</code>.</p> <p>The constructor of an <code>AbstractDimStack</code> must accept a <code>NamedTuple</code>.</p> <p>source</p> <p># <code>DimensionalData.DimStack</code> \u2014 Type.</p> <pre><code>DimStack &lt;: AbstractDimStack\n\nDimStack(data::AbstractDimArray...)\nDimStack(data::Tuple{Vararg{AbstractDimArray}})\nDimStack(data::NamedTuple{Keys,Vararg{AbstractDimArray}})\nDimStack(data::NamedTuple, dims::DimTuple; metadata=NoMetadata())\n</code></pre> <p>DimStack holds multiple objects sharing some dimensions, in a <code>NamedTuple</code>.</p> <p>Notably, their behaviour lies somewhere between a <code>DimArray</code> and a <code>NamedTuple</code>:</p> <ul> <li>indexing with a <code>Symbol</code> as in <code>dimstack[:symbol]</code> returns a <code>DimArray</code> layer.</li> <li>iteration amd <code>map</code> are apply over array layers, as indexed with a <code>Symbol</code>.</li> <li><code>getindex</code> or <code>view</code> with <code>Int</code>, <code>Dimension</code>s or <code>Selector</code>s that resolve to <code>Int</code> will   return a <code>NamedTuple</code> of values from each layer in the stack.   This has very good performace, and avoids the need to always use <code>map</code>.</li> <li><code>getindex</code> or <code>view</code> with a <code>Vector</code> or <code>Colon</code> will return another <code>DimStack</code> where   all data layers have been sliced.</li> <li><code>setindex!</code> must pass a <code>Tuple</code> or <code>NamedTuple</code> maching the layers.</li> <li>many base and <code>Statistics</code> methods (<code>sum</code>, <code>mean</code> etc) will work as for a <code>DimArray</code>   again removing the need to use <code>map</code>.</li> </ul> <p>For example, here we take the mean over the time dimension for all layers :</p> <pre><code>mean(mydimstack; dims=Ti)\n</code></pre> <p>And this equivalent to:</p> <pre><code>map(A -&gt; mean(A; dims=Ti), mydimstack)\n</code></pre> <p>This design gives succinct code when working with many-layered, mixed-dimension objects. </p> <p>But it may be jarring initially - the most surprising outcome is that <code>dimstack[1]</code> will return a <code>NamedTuple</code> of values for the first index in all layers, while <code>first(dimstack)</code> will return the first value of the iterator - the <code>DimArray</code> for the first layer.</p> <p><code>DimStack</code> can be constructed from multiple <code>AbstractDimArray</code> or a <code>NamedTuple</code> of <code>AbstractArray</code> and a matching <code>dims</code> tuple.</p> <p>Most <code>Base</code> and <code>Statistics</code> methods that apply to <code>AbstractArray</code> can be used on all layers of the stack simulataneously. The result is a <code>DimStack</code>, or a <code>NamedTuple</code> if methods like <code>mean</code> are used without <code>dims</code> arguments, and return a single non-array value.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData\n\njulia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0];\n\njulia&gt; dimz = (X([:a, :b]), Y(10.0:10.0:30.0))\nX Symbol[:a, :b],\nY 10.0:10.0:30.0\n\njulia&gt; da1 = DimArray(1A, dimz; name=:one);\n\njulia&gt; da2 = DimArray(2A, dimz; name=:two);\n\njulia&gt; da3 = DimArray(3A, dimz; name=:three);\n\njulia&gt; s = DimStack(da1, da2, da3);\n\njulia&gt; s[At(:b), At(10.0)]\n(one = 4.0, two = 8.0, three = 12.0)\n\njulia&gt; s[X(At(:a))] isa DimStack\ntrue\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#dimension-indices-generators","title":"Dimension indices generators","text":"<p># <code>DimensionalData.DimIndices</code> \u2014 Type.</p> <pre><code>DimIndices &lt;: AbstractArray\n\nDimIndices(x)\nDimIndices(dims::Tuple)\nDimIndices(dims::Dimension)\n</code></pre> <p>Like <code>CartesianIndices</code>, but for <code>Dimension</code>s. Behaves as an <code>Array</code> of <code>Tuple</code> of <code>Dimension(i)</code> for all combinations of the axis indices of <code>dims</code>.</p> <p>This can be used to view/index into arbitrary dimensions over an array, and is especially useful when combined with <code>otherdims</code>, to iterate over the indices of unknown dimension.</p> <p>source</p> <p># <code>DimensionalData.DimKeys</code> \u2014 Type.</p> <pre><code>DimKeys &lt;: AbstractArray\n\nDimKeys(x)\nDimKeys(dims::Tuple)\nDimKeys(dims::Dimension)\n</code></pre> <p>Like <code>CartesianIndices</code>, but for the lookup values of Dimensions. Behaves as an <code>Array</code> of <code>Tuple</code> of <code>Dimension(At(lookupvalue))</code> for all combinations of the lookup values of <code>dims</code>.</p> <p>source</p> <p># <code>DimensionalData.DimPoints</code> \u2014 Type.</p> <pre><code>DimPoints &lt;: AbstractArray\n\nDimPoints(x; order)\nDimPoints(dims::Tuple; order)\nDimPoints(dims::Dimension; order)\n</code></pre> <p>Like <code>CartesianIndices</code>, but for the point values of the dimension index.  Behaves as an <code>Array</code> of <code>Tuple</code> lookup values (whatever they are) for all combinations of the lookup values of <code>dims</code>.</p> <p>Either a <code>Dimension</code>, a <code>Tuple</code> of <code>Dimension</code> or an object that defines a <code>dims</code> method can be passed in.</p> <p>Keywords</p> <ul> <li><code>order</code>: determines the order of the points, the same as the order of <code>dims</code> by default.</li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"reference/#tablesjltabletraitsjl-interface","title":"Tables.jl/TableTraits.jl interface","text":"<p># <code>DimensionalData.AbstractDimTable</code> \u2014 Type.</p> <pre><code>AbstractDimTable &lt;: Tables.AbstractColumns\n</code></pre> <p>Abstract supertype for dim tables</p> <p>source</p> <p># <code>DimensionalData.DimTable</code> \u2014 Type.</p> <pre><code>DimTable &lt;: AbstractDimTable\n\nDimTable(s::AbstractDimStack; mergedims=nothing)\nDimTable(x::AbstractDimArray; layersfrom=nothing, mergedims=nothing)\nDimTable(xs::Vararg{AbstractDimArray}; layernames=nothing, mergedims=nothing)\n</code></pre> <p>Construct a Tables.jl/TableTraits.jl compatible object out of an <code>AbstractDimArray</code> or <code>AbstractDimStack</code>.</p> <p>This table will have columns for the array data and columns for each <code>Dimension</code> index, as a [<code>DimColumn</code>]. These are lazy, and generated as required.</p> <p>Column names are converted from the dimension types using <code>DimensionalData.dim2key</code>. This means type <code>Ti</code> becomes the column name <code>:Ti</code>, and <code>Dim{:custom}</code> becomes <code>:custom</code>.</p> <p>To get dimension columns, you can index with <code>Dimension</code> (<code>X()</code>) or <code>Dimension</code> type (<code>X</code>) as well as the regular <code>Int</code> or <code>Symbol</code>.</p> <p>Keywords</p> <ul> <li><code>mergedims</code>: Combine two or more dimensions into a new dimension.</li> <li><code>layersfrom</code>: Treat a dimension of an <code>AbstractDimArray</code> as layers of an <code>AbstractDimStack</code>.</li> </ul> <p>Example</p> <pre><code>julia&gt; a = DimArray(rand(32,32,3), (X,Y,Dim{:band}));\n\njulia&gt; DimTable(a, layersfrom=Dim{:band}, mergedims=(X,Y)=&gt;:geometry)\nDimTable with 1024 rows, 4 columns, and schema:\n :geometry  Tuple{Int64, Int64}\n :band_1    Float64\n :band_2    Float64\n :band_3    Float64\n</code></pre> <p>source</p> <p># <code>DimensionalData.DimColumn</code> \u2014 Type.</p> <pre><code>DimColumn{T,D&lt;:Dimension} &lt;: AbstractVector{T}\n\nDimColumn(dim::Dimension, dims::Tuple{Vararg{DimTuple}})\nDimColumn(dim::DimColumn, length::Int, dimstride::Int)\n</code></pre> <p>A table column based on a <code>Dimension</code> and it's relationship with other <code>Dimension</code>s in <code>dims</code>.</p> <p><code>length</code> is the product of all dim lengths (usually the length of the corresponding array data), while stride is the product of the preceding dimension lengths, which may or may not be the real stride of the corresponding array depending on the data type. For <code>A isa Array</code>, the <code>dimstride</code> will match the <code>stride</code>.</p> <p>When the second argument is a <code>Tuple</code> of <code>Dimension</code>, the <code>length</code> and <code>dimstride</code> fields are calculated from the dimensions, relative to the column dimension <code>dim</code>.</p> <p>This object will be returned as a column of <code>DimTable</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#common-methods","title":"Common methods","text":"<p>Common functions for obtaining information from objects:</p> <p># <code>DimensionalData.Dimensions.dims</code> \u2014 Function.</p> <pre><code>dims(x, [dims::Tuple]) =&gt; Tuple{Vararg{Dimension}}\ndims(x, dim) =&gt; Dimension\n</code></pre> <p>Return a tuple of <code>Dimension</code>s for an object, in the order that matches the axes or columns of the underlying data.</p> <p><code>dims</code> can be <code>Dimension</code>, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>The default is to return <code>nothing</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.refdims</code> \u2014 Function.</p> <pre><code>refdims(x, [dims::Tuple]) =&gt; Tuple{Vararg{Dimension}}\nrefdims(x, dim) =&gt; Dimension\n</code></pre> <p>Reference dimensions for an array that is a slice or view of another array with more dimensions.</p> <p><code>slicedims(a, dims)</code> returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty.</p> <p>The default is to return an empty <code>Tuple</code> <code>()</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.metadata</code> \u2014 Function.</p> <pre><code>metadata(x) =&gt; (object metadata)\nmetadata(x, dims::Tuple)  =&gt; Tuple (Dimension metadata)\nmetadata(xs::Tuple) =&gt; Tuple\n</code></pre> <p>Returns the metadata for an object or for the specified dimension(s)</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.name</code> \u2014 Function.</p> <pre><code>name(x) =&gt; Symbol\nname(xs:Tuple) =&gt; NTuple{N,Symbol}\nname(x, dims::Tuple) =&gt; NTuple{N,Symbol}\nname(x, dim) =&gt; Symbol\n</code></pre> <p>Get the name of an array or Dimension, or a tuple of of either as a Symbol.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p>Utility methods for transforming DimensionalData objects:</p> <p># <code>DimensionalData.Dimensions.LookupArrays.set</code> \u2014 Function.</p> <pre><code>set(x, val)\nset(x, args::Pairs...) =&gt; x with updated field/s\nset(x, args...; kw...) =&gt; x with updated field/s\nset(x, args::Tuple{Vararg{Dimension}}; kw...) =&gt; x with updated field/s\n\nset(dim::Dimension, index::AbstractArray) =&gt; Dimension\nset(dim::Dimension, lookup::LookupArray) =&gt; Dimension\nset(dim::Dimension, lookupcomponent::LookupArrayTrait) =&gt; Dimension\nset(dim::Dimension, metadata::AbstractMetadata) =&gt; Dimension\n</code></pre> <p>Set the properties of an object, its internal data or the traits of its dimensions and lookup index.</p> <p>As DimensionalData is so strongly typed you do not need to specify what field of a <code>LookupArray</code> to <code>set</code> - there is no ambiguity.</p> <p>To set fields of a <code>LookupArray</code> you need to specify the dimension. This can be done using <code>X =&gt; val</code> pairs, <code>X = val</code> keyword arguments, or <code>X(val)</code> wrapped arguments.</p> <p>When a <code>Dimension</code> or <code>LookupArray</code> is passed to <code>set</code> to replace the existing ones, fields that are not set will keep their original values.</p> <p>Notes:</p> <p>Changing a lookup index range/vector will also update the step size and order where applicable.</p> <p>Setting the <code>Order</code> like <code>ForwardOrdered</code> will not reverse the array or dimension to match. Use <code>reverse</code> and <code>reorder</code> to do this.</p> <p>Examples</p> <pre><code>julia&gt; using DimensionalData; const DD = DimensionalData\nDimensionalData\n\njulia&gt; da = DimArray(zeros(3, 4), (custom=10.0:010.0:30.0, Z=-20:010.0:10.0));\n\njulia&gt; set(da, ones(3, 4))\n3\u00d74 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    1.0    1.0  1.0   1.0\n 20.0    1.0    1.0  1.0   1.0\n 30.0    1.0    1.0  1.0   1.0 \n</code></pre> <p>Change the <code>Dimension</code> wrapper type:</p> <pre><code>julia&gt; set(da, :Z =&gt; Ti, :custom =&gt; Z)\n3\u00d74 DimArray{Float64,2} with dimensions:\n  Z Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Ti Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    0.0    0.0  0.0   0.0\n 20.0    0.0    0.0  0.0   0.0\n 30.0    0.0    0.0  0.0   0.0 \n</code></pre> <p>Change the lookup <code>Vector</code>:</p> <pre><code>julia&gt; set(da, Z =&gt; [:a, :b, :c, :d], :custom =&gt; [4, 5, 6])\n3\u00d74 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Int64} Int64[4, 5, 6] ForwardOrdered Regular Points,\n  Z Sampled{Symbol} Symbol[:a, :b, :c, :d] ForwardOrdered Regular Points\n     :a   :b   :c   :d\n 4  0.0  0.0  0.0  0.0\n 5  0.0  0.0  0.0  0.0\n 6  0.0  0.0  0.0  0.0\n</code></pre> <p>Change the <code>LookupArray</code> type:</p> <pre><code>julia&gt; set(da, Z=DD.NoLookup(), custom=DD.Sampled())\n3\u00d74 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,\n  Z\n 10.0  0.0  0.0  0.0  0.0\n 20.0  0.0  0.0  0.0  0.0\n 30.0  0.0  0.0  0.0  0.0\n</code></pre> <p>Change the <code>Sampling</code> trait:</p> <pre><code>julia&gt; set(da, :custom =&gt; DD.Irregular(10, 12), Z =&gt; DD.Regular(9.9))\n3\u00d74 DimArray{Float64,2} with dimensions:\n  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Irregular Points,\n  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points\n       -20.0  -10.0  0.0  10.0\n 10.0    0.0    0.0  0.0   0.0\n 20.0    0.0    0.0  0.0   0.0\n 30.0    0.0    0.0  0.0   0.0\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.rebuild</code> \u2014 Function.</p> <pre><code>rebuild(x, args...)\nrebuild(x; kw...)\n</code></pre> <p>Rebuild an object struct with updated field values.</p> <p><code>x</code> can be a <code>AbstractDimArray</code>, a <code>Dimension</code>, <code>LookupArray</code> or other custom types.</p> <p>This is an abstraction that alows inbuilt and custom types to be rebuilt to update their fields, as most objects in DimensionalData.jl are immutable.</p> <p>The arguments version can be concise but depends on a fixed order defined for some DimensionalData objects. It should be defined based on the object type in DimensionalData, adding the fields specific to your object.</p> <p>The keyword version ignores order, and is mostly automated  using <code>ConstructionBase.setproperties</code>. It should only be defined if your object has  missing fields or fields with different names to DimensionalData objects.</p> <p>The arguments required are defined for the abstract type that has a <code>rebuild</code> method.</p> <p>source</p> <p># <code>DimensionalData.modify</code> \u2014 Function.</p> <pre><code>modify(f, A::AbstractDimArray) =&gt; AbstractDimArray\nmodify(f, s::AbstractDimStack) =&gt; AbstractDimStack\nmodify(f, dim::Dimension) =&gt; Dimension\nmodify(f, x, lookupdim::Dimension) =&gt; typeof(x)\n</code></pre> <p>Modify the parent data, rebuilding the object wrapper without change. <code>f</code> must return a <code>AbstractArray</code> of the same size as the original.</p> <p>This method is mostly useful as a way of swapping the parent array type of an object.</p> <p>Example</p> <p>If we have a previously-defined <code>DimArray</code>, we can copy it to an Nvidia GPU with:</p> <pre><code>A = DimArray(rand(100, 100), (X, Y))\nmodify(CuArray, A)\n</code></pre> <p>This also works for all the data layers in a <code>DimStack</code>.</p> <p>source</p> <p># <code>DimensionalData.broadcast_dims</code> \u2014 Function.</p> <pre><code>broadcast_dims(f, sources::AbstractDimArray...) =&gt; AbstractDimArray\n</code></pre> <p>Broadcast function <code>f</code> over the <code>AbstractDimArray</code>s in <code>sources</code>, permuting and reshaping dimensions to match where required. The result will contain all the dimensions in  all passed in arrays in the order in which they are found.</p> <p>Arguments</p> <ul> <li><code>sources</code>: <code>AbstractDimArrays</code> to broadcast over with <code>f</code>.</li> </ul> <p>This is like broadcasting over every slice of <code>A</code> if it is sliced by the dimensions of <code>B</code>.</p> <p>source</p> <p># <code>DimensionalData.broadcast_dims!</code> \u2014 Function.</p> <pre><code>broadcast_dims!(f, dest::AbstractDimArray, sources::AbstractDimArray...) =&gt; dest\n</code></pre> <p>Broadcast function <code>f</code> over the <code>AbstractDimArray</code>s in <code>sources</code>, writing to <code>dest</code>.  <code>sources</code> are permuting and reshaping dimensions to match where required.</p> <p>The result will contain all the dimensions in all passed in arrays, in the order in which they are found.</p> <p>Arguments</p> <ul> <li><code>dest</code>: <code>AbstractDimArray</code> to update.</li> <li><code>sources</code>: <code>AbstractDimArrays</code> to broadcast over with <code>f</code>.</li> </ul> <p>source</p> <p># <code>DimensionalData.mergedims</code> \u2014 Function.</p> <pre><code>mergedims(old_dims =&gt; new_dim) =&gt; Dimension\n</code></pre> <p>Return a dimension <code>new_dim</code> whose indices are a <code>MergedLookup</code> of the indices of <code>old_dims</code>.</p> <p>source</p> <pre><code>mergedims(dims, old_dims =&gt; new_dim, others::Pair...) =&gt; dims_new\n</code></pre> <p>If dimensions <code>old_dims</code>, <code>new_dim</code>, etc. are found in <code>dims</code>, then return new <code>dims_new</code> where all dims in <code>old_dims</code> have been combined into a single dim <code>new_dim</code>. The returned dimension will keep only the name of <code>new_dim</code>. Its coords will be a <code>MergedLookup</code> of the coords of the dims in <code>old_dims</code>. New dimensions are always placed at the end of <code>dims_new</code>. <code>others</code> contains other dimension pairs to be merged.</p> <p>Example</p> <pre><code>julia&gt; ds = (X(0:0.1:0.4), Y(10:10:100), Ti([0, 3, 4]));\njulia&gt; mergedims(ds, Ti =&gt; :time, (X, Y) =&gt; :space)\nDim{:time} MergedLookup{Tuple{Int64}} Tuple{Int64}[(0,), (3,), (4,)] Ti,\nDim{:space} MergedLookup{Tuple{Float64, Int64}} Tuple{Float64, Int64}[(0.0, 10), (0.1, 10), \u2026, (0.3, 100), (0.4, 100)] X, Y\n</code></pre> <p>source</p> <pre><code>mergedims(A::AbstractDimArray, dim_pairs::Pair...) =&gt; AbstractDimArray\nmergedims(A::AbstractDimStack, dim_pairs::Pair...) =&gt; AbstractDimStack\n</code></pre> <p>Return a new array or stack whose dimensions are the result of <code>mergedims(dims(A), dim_pairs)</code>.</p> <p>source</p> <p># <code>DimensionalData.unmergedims</code> \u2014 Function.</p> <pre><code>unmergedims(merged_dims::Tuple{Vararg{Dimension}}) =&gt; Tuple{Vararg{Dimension}}\n</code></pre> <p>Return the unmerged dimensions from a tuple of merged dimensions. However, the order of the original dimensions are not necessarily preserved.</p> <p>source</p> <pre><code>unmergedims(A::AbstractDimArray, original_dims) =&gt; AbstractDimArray\nunmergedims(A::AbstractDimStack, original_dims) =&gt; AbstractDimStack\n</code></pre> <p>Return a new array or stack whose dimensions are restored to their original prior to calling <code>mergedims(A, dim_pairs)</code>.</p> <p>source</p> <p># <code>DimensionalData.reorder</code> \u2014 Function.</p> <pre><code>reorder(A::AbstractDimArray, order::Pair) =&gt; AbstractDimArray\nreorder(A::Dimension, order::Order) =&gt; AbstractDimArray\n</code></pre> <p>Reorder every dims index/array to <code>order</code>, or reorder index for the the given dimension(s) to the <code>Order</code> they wrap.</p> <p><code>order</code> can be an <code>Order</code>, or <code>Dimeension =&gt; Order</code> pairs.</p> <p>If no axis reversal is required the same objects will be returned, without allocation.</p> <p>source</p> <p># <code>Base.cat</code> \u2014 Function.</p> <pre><code>Base.cat(stacks::AbstractDimStack...; [keys=keys(stacks[1])], dims)\n</code></pre> <p>Concatenate all or a subset of layers for all passed in stacks.</p> <p>Keywords</p> <ul> <li><code>keys</code>: <code>Tuple</code> of <code>Symbol</code> for the stack keys to concatenate.</li> <li><code>dims</code>: Dimension of child array to concatenate on.</li> </ul> <p>Example</p> <p>Concatenate the :seasurfacetemp and :humidity layers in the time dimension:</p> <pre><code>cat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)\n</code></pre> <p>source</p> <p># <code>Base.map</code> \u2014 Function.</p> <pre><code>Base.map(f, stacks::AbstractDimStack...)\n</code></pre> <p>Apply function <code>f</code> to each layer of the <code>stacks</code>.</p> <p>If <code>f</code> returns <code>DimArray</code>s the result will be another <code>DimStack</code>. Other values will be returned in a <code>NamedTuple</code>.</p> <p>source</p> <p># <code>Base.copy!</code> \u2014 Function.</p> <pre><code>Base.copy!(dst::AbstractArray, src::AbstractGimStack, key::Key)\n</code></pre> <p>Copy the stack layer <code>key</code> to <code>dst</code>, which can be any <code>AbstractArray</code>.</p> <p>Example</p> <p>Copy the <code>:humidity</code> layer from <code>stack</code> to <code>array</code>.</p> <pre><code>copy!(array, stack, :humidity)\n</code></pre> <p>source</p> <pre><code>Base.copy!(dst::AbstractDimStack, src::AbstractDimStack, [keys=keys(dst)])\n</code></pre> <p>Copy all or a subset of layers from one stack to another.</p> <p>Example</p> <p>Copy just the <code>:sea_surface_temp</code> and <code>:humidity</code> layers from <code>src</code> to <code>dst</code>.</p> <pre><code>copy!(dst::AbstractDimStack, src::AbstractDimStack, keys=(:sea_surface_temp, :humidity))\n</code></pre> <p>source</p> <p># <code>Base.eachslice</code> \u2014 Function.</p> <pre><code>Base.eachslice(stack::AbstractDimStack; dims)\n</code></pre> <p>Create a generator that iterates over dimensions <code>dims</code> of <code>stack</code>, returning stacks that select all the data from the other dimensions in <code>stack</code> using views.</p> <p>The generator has <code>size</code> and <code>axes</code> equivalent to those of the provided <code>dims</code>.</p> <p>Examples</p> <pre><code>julia&gt; ds = DimStack((\n           x=DimArray(randn(2, 3, 4), (X([:x1, :x2]), Y(1:3), Z)),\n           y=DimArray(randn(2, 3, 5), (X([:x1, :x2]), Y(1:3), Ti))\n       ));\n\njulia&gt; slices = eachslice(ds; dims=(Z, X));\n\njulia&gt; size(slices)\n(4, 2)\n\njulia&gt; map(dims, axes(slices))\nZ,\nX Categorical{Symbol} Symbol[x1, x2] ForwardOrdered\n\njulia&gt; first(slices)\nDimStack with dimensions:\n  Y Sampled{Int64} 1:3 ForwardOrdered Regular Points,\n  Ti\nand 2 layers:\n  :x Float64 dims: Y (3)\n  :y Float64 dims: Y, Ti (3\u00d75)\n</code></pre> <p>source</p> <p>Most base methods work as expected, using <code>Dimension</code> wherever a <code>dims</code> keyword is used. They are not allspecifically documented here.</p> <p>Shorthand constructors:</p> <p># <code>Base.fill</code> \u2014 Function.</p> <pre><code>Base.fill(x, dims::Dimension...; kw...) =&gt; DimArray\nBase.fill(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray\n</code></pre> <p>Create a <code>DimArray</code> with a fill value of <code>x</code>.</p> <p>There are two kinds of <code>Dimension</code> value acepted:</p> <ul> <li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li> <li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <code>NoLookup</code>.</li> </ul> <p>Keywords are the same as for <code>DimArray</code>.</p> <p>Example</p> <p>```@doctest julia&gt; using DimensionalData</p> <p>julia&gt; rand(Bool, X(2), Y(4)) 2\u00d74 DimArray{Bool,2} with dimensions: X, Y  1  0  0  1  1  0  1  1 <pre><code>&lt;a target='_blank' href='https://github.com/rafaqz/DimensionalData.jl/blob/ceecf8b969fc32ce9d284010cce486a07af5f6f5/src/array/array.jl#L409-L432' class='documenter-source'&gt;source&lt;/a&gt;&lt;br&gt;\n\n&lt;a id='Base.rand' href='#Base.rand'&gt;#&lt;/a&gt;\n**`Base.rand`** &amp;mdash; *Function*.\n\n\n\n```julia\nBase.rand(x, dims::Dimension...; kw...) =&gt; DimArray\nBase.rand(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray\nBase.rand(r::AbstractRNG, x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray\nBase.rand(r::AbstractRNG, x, dims::Dimension...; kw...) =&gt; DimArray\n</code></pre></p> <p>Create a <code>DimArray</code> of random values.</p> <p>There are two kinds of <code>Dimension</code> value acepted:</p> <ul> <li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li> <li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <code>NoLookup</code>.</li> </ul> <p>Keywords are the same as for <code>DimArray</code>.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData\n\njulia&gt; rand(Bool, X(2), Y(4))\n2\u00d74 DimArray{Bool,2} with dimensions: X, Y\n 1  0  0  1\n 1  0  1  1\n\njulia&gt; rand(X([:a, :b, :c]), Y(100.0:50:200.0))\n3\u00d73 DimArray{Float64,2} with dimensions:\n  X: Symbol[a, b, c] Categorical: Unordered,\n  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points\n 0.43204   0.835111  0.624231\n 0.752868  0.471638  0.193652\n 0.484558  0.846559  0.455256\n</code></pre> <p>source</p> <p># <code>Base.zeros</code> \u2014 Function.</p> <pre><code>Base.zeros(x, dims::Dimension...; kw...) =&gt; DimArray\nBase.zeros(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray\n</code></pre> <p>Create a <code>DimArray</code> of zeros.</p> <p>There are two kinds of <code>Dimension</code> value acepted:</p> <ul> <li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li> <li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <code>NoLookup</code>.</li> </ul> <p>Keywords are the same as for <code>DimArray</code>.</p> <p>Example</p> <p>```@doctest julia&gt; using DimensionalData</p> <p>julia&gt; zeros(Bool, X(2), Y(4)) 2\u00d74 DimArray{Bool,2} with dimensions: X, Y  0  0  0  0  0  0  0  0</p> <p>julia&gt; zeros(X([:a, :b, :c]), Y(100.0:50:200.0)) 3\u00d73 DimArray{Float64,2} with dimensions:   X: Symbol[a, b, c] Categorical: Unordered,   Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 <pre><code>&lt;a target='_blank' href='https://github.com/rafaqz/DimensionalData.jl/blob/ceecf8b969fc32ce9d284010cce486a07af5f6f5/src/array/array.jl#L471-L502' class='documenter-source'&gt;source&lt;/a&gt;&lt;br&gt;\n\n&lt;a id='Base.ones' href='#Base.ones'&gt;#&lt;/a&gt;\n**`Base.ones`** &amp;mdash; *Function*.\n\n\n\n```julia\nBase.ones(x, dims::Dimension...; kw...) =&gt; DimArray\nBase.ones(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray\n</code></pre></p> <p>Create a <code>DimArray</code> of ones.</p> <p>There are two kinds of <code>Dimension</code> value acepted:</p> <ul> <li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li> <li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <code>NoLookup</code>.</li> </ul> <p>Keywords are the same as for <code>DimArray</code>.</p> <p>Example</p> <p>```@doctest julia&gt; using DimensionalData</p> <p>julia&gt; ones(Bool, X(2), Y(4)) 2\u00d74 DimArray{Bool,2} with dimensions: X, Y  1  1  1  1  1  1  1  1</p> <p>julia&gt; ones(X([:a, :b, :c]), Y(100.0:50:200.0)) 3\u00d73 DimArray{Float64,2} with dimensions:   X: Symbol[a, b, c] Categorical: Unordered,   Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0 <pre><code>&lt;a target='_blank' href='https://github.com/rafaqz/DimensionalData.jl/blob/ceecf8b969fc32ce9d284010cce486a07af5f6f5/src/array/array.jl#L505-L536' class='documenter-source'&gt;source&lt;/a&gt;&lt;br&gt;\n\n\n&lt;a id='Dimensions'&gt;&lt;/a&gt;\n\n&lt;a id='Dimensions-1'&gt;&lt;/a&gt;\n\n# Dimensions\n\n\nHandling of Dimensions is kept in a sub-module `Dimensions`.\n\n&lt;a id='DimensionalData.Dimensions' href='#DimensionalData.Dimensions'&gt;#&lt;/a&gt;\n**`DimensionalData.Dimensions`** &amp;mdash; *Module*.\n\n\n\nDimensions\n\nSub-module for [`Dimension`](reference.md#DimensionalData.Dimensions.Dimension)s wrappers, and operations on them used in DimensionalData.jl.\n\nTo load `Dimensions` types and methods into scope:\n\n```julia\nusing DimensionalData\nusing DimensionalData.Dimensions\n</code></pre></p> <p>source</p> <p>Dimensions have a type-heirarchy that organises plotting and dimension matching.</p> <p># <code>DimensionalData.Dimensions.Dimension</code> \u2014 Type.</p> <pre><code>Dimension\n</code></pre> <p>Abstract supertype of all dimension types.</p> <p>Example concrete implementations are <code>X</code>, <code>Y</code>, <code>Z</code>, <code>Ti</code> (Time), and the custom [<code>Dim</code>]@ref) dimension.</p> <p><code>Dimension</code>s label the axes of an <code>AbstractDimArray</code>, or other dimensional objects, and are used to index into the array.</p> <p>They may also provide an alternate index to lookup for each array axis. This may be any <code>AbstractVector</code> matching the array axis length, or a <code>Val</code> holding a tuple for compile-time index lookups.</p> <p><code>Dimension</code>s also have <code>lookup</code> and <code>metadata</code> fields.</p> <p><code>lookup</code> gives more details about the dimension, such as that it is <code>Categorical</code> or <code>Sampled</code> as <code>Points</code> or <code>Intervals</code> along some transect. DimensionalData will attempt to guess the lookup from the passed-in index value.</p> <p>Example:</p> <pre><code>using DimensionalData, Dates\n\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimArray(zeros(3, 5, 12), (y, x, ti))\n\n# output\n\n3\u00d75\u00d712 DimArray{Float64,3} with dimensions:\n  Y Categorical{Char} Char['a', 'b', 'c'] ForwardOrdered,\n  X Sampled{Int64} 2:2:10 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\n[:, :, 1]\n       2    4    6    8    10\n  'a'  0.0  0.0  0.0  0.0   0.0\n  'b'  0.0  0.0  0.0  0.0   0.0\n  'c'  0.0  0.0  0.0  0.0   0.0\n[and 11 more slices...]\n</code></pre> <p>For simplicity, the same <code>Dimension</code> types are also used as wrappers in <code>getindex</code>, like:</p> <pre><code>x = A[X(2), Y(3)]\n\n# output\n\n12-element DimArray{Float64,1} with dimensions:\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical{Char} Char['c'] ForwardOrdered,\n  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points\n 2021-01-01T00:00:00  0.0\n 2021-02-01T00:00:00  0.0\n 2021-03-01T00:00:00  0.0\n 2021-04-01T00:00:00  0.0\n \u22ee\n 2021-10-01T00:00:00  0.0\n 2021-11-01T00:00:00  0.0\n 2021-12-01T00:00:00  0.0\n</code></pre> <p>A <code>Dimension</code> can also wrap <code>Selector</code>.</p> <pre><code>x = A[X(Between(3, 4)), Y(At('b'))]\n\n# output\n\n1\u00d712 DimArray{Float64,2} with dimensions:\n  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2021-01-01T00:00:00\"):Month(1):DateTime(\"2021-12-01T00:00:00\") ForwardOrdered Regular Points\nand reference dimensions:\n  Y Categorical{Char} Char['b'] ForwardOrdered\n     2021-01-01T00:00:00  \u2026   2021-12-01T00:00:00\n 4  0.0                                  0.0\n</code></pre> <p><code>Dimension</code> objects may have <code>lookup</code> and <code>metadata</code> fields to track additional information about the data and the index, and their relationship.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.DependentDim</code> \u2014 Type.</p> <pre><code>DependentDim &lt;: Dimension\n</code></pre> <p>Abstract supertype for Dependent dimensions. These will plot on the Y axis.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.IndependentDim</code> \u2014 Type.</p> <pre><code>IndependentDim &lt;: Dimension\n</code></pre> <p>Abstract supertype for independent dimensions. Thise will plot on the X axis.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.XDim</code> \u2014 Type.</p> <pre><code>XDim &lt;: IndependentDim\n</code></pre> <p>Abstract supertype for all X dimensions.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.YDim</code> \u2014 Type.</p> <pre><code>YDim &lt;: DependentDim\n</code></pre> <p>Abstract supertype for all Y dimensions.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.ZDim</code> \u2014 Type.</p> <pre><code>ZDim &lt;: DependentDim\n</code></pre> <p>Abstract supertype for all Z dimensions.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.TimeDim</code> \u2014 Type.</p> <pre><code>TimeDim &lt;: IndependentDim\n</code></pre> <p>Abstract supertype for all time dimensions.</p> <p>In a <code>TimeDime</code> with <code>Interval</code> sampling the locus will automatically be set to <code>Start()</code>. Dates and times generally refer to the start of a month, hour, second etc., not the central point as is more common with spatial data. `</p> <p>source</p> <p># <code>DimensionalData.Dimensions.X</code> \u2014 Type.</p> <pre><code>X &lt;: XDim\n\nX(val=:)\n</code></pre> <p>X <code>Dimension</code>. <code>X &lt;: XDim &lt;: IndependentDim</code></p> <p>Example:</p> <pre><code>xdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.Y</code> \u2014 Type.</p> <pre><code>Y &lt;: YDim\n\nY(val=:)\n</code></pre> <p>Y <code>Dimension</code>. <code>Y &lt;: YDim &lt;: DependentDim</code></p> <p>Example:</p> <pre><code>ydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.Z</code> \u2014 Type.</p> <pre><code>Z &lt;: ZDim\n\nZ(val=:)\n</code></pre> <p>Z <code>Dimension</code>. <code>Z &lt;: ZDim &lt;: Dimension</code></p> <p>Example:</p> <pre><code>zdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.Ti</code> \u2014 Type.</p> <p>m     Ti &lt;: TimeDim</p> <pre><code>Ti(val=:)\n</code></pre> <p>Time <code>Dimension</code>. <code>Ti &lt;: TimeDim &lt;: IndependentDim</code></p> <p><code>Time</code> is already used by Dates, and <code>T</code> is a common type parameter, We use <code>Ti</code> to avoid clashes.</p> <p>Example:</p> <pre><code>timedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n# Or\nval = A[Ti(1)]\n# Or\nmean(A; dims=Ti)\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.Dim</code> \u2014 Type.</p> <pre><code>Dim{S}(val=:)\n</code></pre> <p>A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.</p> <p>Dimension types take precedence over same named <code>Dim</code> types when indexing with symbols, or e.g. creating Tables.jl keys.</p> <pre><code>using DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char['a', 'b', 'c']\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.Coord</code> \u2014 Type.</p> <pre><code>Coord &lt;: Dimension\n</code></pre> <p>A coordinate dimension itself holds dimensions.</p> <p>This allows combining point data with other dimensions, such as time.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData\n\njulia&gt; dim = Coord([(1.0,1.0,1.0), (1.0,2.0,2.0), (3.0,4.0,4.0), (1.0,3.0,4.0)], (X(), Y(), Z()))\nCoord ::\n  val: Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0, 3.0,\n4.0)]\n  lookup: MergedLookup\nCoord{Vector{Tuple{Float64, Float64, Float64}}, DimensionalData.MergedLookup{Tuple{X{Colon, AutoLookup{Auto\nOrder}, NoMetadata}, Y{Colon, AutoLookup{AutoOrder}, NoMetadata}, Z{Colon, AutoLookup{AutoOrder}, NoMetada\nta}}}, NoMetadata}\n\njulia&gt; da = DimArray(0.1:0.1:0.4, dim)\n4-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0,\n3.0, 4.0)]\n    MergedLookup\n 0.1\n 0.2\n 0.3\n 0.4\n\njulia&gt; da[Coord(Z(At(1.0)), Y(Between(1, 3)))]\n1-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0)] MergedLookup\n 0.1\n\njulia&gt; da[Coord(4)] == 0.4\ntrue\n\njulia&gt; da[Coord(Between(1, 5), :, At(4.0))]\n2-element DimArray{Float64,1} with dimensions:\n  Coord (): Tuple{Float64, Float64, Float64}[(3.0, 4.0, 4.0), (1.0, 3.0, 4.0)] MergedLookup\n 0.3\n 0.4\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.AnonDim</code> \u2014 Type.</p> <pre><code>AnonDim &lt;: Dimension\n\nAnonDim()\n</code></pre> <p>Anonymous dimension. Used when extra dimensions are created, such as during transpose of a vector.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.@dim</code> \u2014 Macro.</p> <pre><code>@dim typ [supertype=Dimension] [name::String=string(typ)]\n</code></pre> <p>Macro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply <code>YourDim &lt;: Dimension</code>. Making a Dimesion inherit from <code>XDim</code>, <code>YDim</code>, <code>ZDim</code> or <code>TimeDim</code> will affect automatic plot layout and other methods that dispatch on these types. <code>&lt;: YDim</code> are plotted on the Y axis, <code>&lt;: XDim</code> on the X axis, etc.</p> <p>Example:</p> <pre><code>using DimensionalData\nusing DimensionalData: @dim, YDim, XDim\n@dim Lat YDim \"latitude\"\n@dim Lon XDim \"Longitude\"\n# output\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#exported-methods","title":"Exported methods","text":"<p># <code>DimensionalData.Dimensions.hasdim</code> \u2014 Function.</p> <pre><code>hasdim([f], x, query::Tuple) =&gt; NTUple{Bool}\nhasdim([f], x, query...) =&gt; NTUple{Bool}\nhasdim([f], x, query) =&gt; Bool\n</code></pre> <p>Check if an object <code>x</code> has dimensions that match or inherit from the <code>query</code> dimensions.</p> <p>Arguments</p> <ul> <li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li> <li><code>query</code>: Tuple or single <code>Dimension</code> or dimension <code>Type</code>.</li> <li><code>f</code>: <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</li> </ul> <p>Check if an object or tuple contains an <code>Dimension</code>, or a tuple of dimensions.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData\n\njulia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia&gt; hasdim(A, X)\ntrue\n\njulia&gt; hasdim(A, (Z, X, Y))\n(true, true, true)\n\njulia&gt; hasdim(A, Ti)\nfalse\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.dimnum</code> \u2014 Function.</p> <pre><code>dimnum(x, query::Tuple) =&gt; NTuple{Int}\ndimnum(x, query) =&gt; Int\n</code></pre> <p>Get the number(s) of <code>Dimension</code>(s) as ordered in the dimensions of an object.</p> <p>Arguments</p> <ul> <li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li> <li><code>query</code>: Tuple, Array or single <code>Dimension</code> or dimension <code>Type</code>.</li> </ul> <p>The return type will be a Tuple of <code>Int</code> or a single <code>Int</code>, depending on wether <code>query</code> is a <code>Tuple</code> or single <code>Dimension</code>.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData\n\njulia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia&gt; dimnum(A, (Z, X, Y))\n(3, 1, 2)\n\njulia&gt; dimnum(A, Y)\n2\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#non-exported-methods","title":"Non-exported methods","text":"<p># <code>DimensionalData.Dimensions.lookup</code> \u2014 Function.</p> <pre><code>lookup(x::Dimension) =&gt; LookupArray\nlookup(x, [dims::Tuple]) =&gt; Tuple{Vararg{LookupArray}}\nlookup(x::Tuple) =&gt; Tuple{Vararg{LookupArray}}\nlookup(x, dim) =&gt; LookupArray\n</code></pre> <p>Returns the <code>LookupArray</code> of a dimension. This dictates properties of the dimension such as array axis and index order, and sampling properties.</p> <p><code>dims</code> can be a <code>Dimension</code>, a dimension type, or a tuple of either.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.label</code> \u2014 Function.</p> <pre><code>label(x) =&gt; String\nlabel(x, dims::Tuple) =&gt; NTuple{N,String}\nlabel(x, dim) =&gt; String\nlabel(xs::Tuple) =&gt; NTuple{N,String}\n</code></pre> <p>Get a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.dim2key</code> \u2014 Function.</p> <pre><code>dim2key(dim::Dimension) =&gt; Symbol\ndim2key(dims::Type{&lt;:Dimension}) =&gt; Symbol\ndim2key(dims::Tuple) =&gt; Tuple{Symbol,Vararg}\n</code></pre> <p>Convert a dimension object to a simbol. <code>X()</code>, <code>Y()</code>, <code>Ti()</code> etc will be converted. to <code>:X</code>, <code>:Y</code>, <code>:Ti</code>, as with any other dims generated with the <code>@dim</code> macro.</p> <p>All other <code>Dim{S}()</code> dimensions will generate <code>Symbol</code>s <code>S</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.key2dim</code> \u2014 Function.</p> <pre><code>key2dim(s::Symbol) =&gt; Dimension\nkey2dim(dims...) =&gt; Tuple{Dimension,Vararg}\nkey2dim(dims::Tuple) =&gt; Tuple{Dimension,Vararg}\n</code></pre> <p>Convert a symbol to a dimension object. <code>:X</code>, <code>:Y</code>, <code>:Ti</code> etc will be converted. to <code>X()</code>, <code>Y()</code>, <code>Ti()</code>, as with any other dims generated with the <code>@dim</code> macro.</p> <p>All other <code>Symbol</code>s <code>S</code> will generate <code>Dim{S}()</code> dimensions.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.dims2indices</code> \u2014 Function.</p> <pre><code>dims2indices(dim::Dimension, I) =&gt; NTuple{Union{Colon,AbstractArray,Int}}\n</code></pre> <p>Convert a <code>Dimension</code> or <code>Selector</code> <code>I</code> to indices of <code>Int</code>, <code>AbstractArray</code> or <code>Colon</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.selectindices</code> \u2014 Function.</p> <pre><code>selectindices(lookups, selectors)\n</code></pre> <p>Converts <code>Selector</code> to regular indices.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.format</code> \u2014 Function.</p> <pre><code>format(dims, x) =&gt; Tuple{Vararg{Dimension,N}}\n</code></pre> <p>Format the passed-in dimension(s) <code>dims</code> to match the object <code>x</code>.</p> <p>Errors are thrown if dims don't match the array dims or size,  and any fields holding <code>Auto-</code> objects are filled with guessed objects.</p> <p>If a <code>LookupArray</code> hasn't been specified, a lookup is chosen based on the type and element type of the index.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.reducedims</code> \u2014 Function.</p> <pre><code>reducedims(x, dimstoreduce) =&gt; Tuple{Vararg{Dimension}}\n</code></pre> <p>Replace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like <code>mean</code> or <code>reduce</code> to a length of 1, but the number of dimensions has not changed.</p> <p><code>LookupArray</code> traits are also updated to correspond to the change in cell step, sampling type and order.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.swapdims</code> \u2014 Function.</p> <pre><code>swapdims(x::T, newdims) =&gt; T\nswapdims(dims::Tuple, newdims) =&gt; Tuple{Vararg{Dimension}}\n</code></pre> <p>Swap dimensions for the passed in dimensions, in the order passed.</p> <p>Passing in the <code>Dimension</code> types rewraps the dimension index, keeping the index values and metadata, while constructed <code>Dimension</code> objectes replace the original dimension. <code>nothing</code> leaves the original dimension as-is.</p> <p>Arguments</p> <ul> <li><code>x</code>: any object with a <code>dims</code> method or a <code>Tuple</code> of <code>Dimension</code>.</li> <li><code>newdim</code>: Tuple of <code>Dimension</code> or dimension <code>Type</code>.</li> </ul> <p>Example</p> <pre><code>using DimensionalData\nA = ones(X(2), Y(4), Z(2))\nDimensions.swapdims(A, (Dim{:a}, Dim{:b}, Dim{:c}))\n\n# output\n2\u00d74\u00d72 DimArray{Float64,3} with dimensions: Dim{:a}, Dim{:b}, Dim{:c}\n[:, :, 1]\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n[and 1 more slices...]\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.slicedims</code> \u2014 Function.</p> <pre><code>slicedims(x, I) =&gt; Tuple{Tuple,Tuple}\nslicedims(f, x, I) =&gt; Tuple{Tuple,Tuple}\n</code></pre> <p>Slice the dimensions to match the axis values of the new array.</p> <p>All methods return a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.</p> <p>Called at the array level the returned tuple will also include the previous reference dims attached to the array.</p> <p>Arguments</p> <ul> <li><code>f</code>: a function <code>getindex</code>,  <code>view</code> or <code>dotview</code>. This will be used for slicing   <code>getindex</code> is the default if <code>f</code> is not included.</li> <li><code>x</code>: An <code>AbstractDimArray</code>, <code>Tuple</code> of <code>Dimension</code>, or <code>Dimension</code></li> <li><code>I</code>: A tuple of <code>Integer</code>, <code>Colon</code> or <code>AbstractArray</code></li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.comparedims</code> \u2014 Function.</p> <pre><code>comparedims(A::AbstractDimArray...; kw...)\ncomparedims(A::Tuple...; kw...)\ncomparedims(A::Dimension...; kw...)\ncomparedims(::Type{Bool}, args...; kw...)\n</code></pre> <p>Check that dimensions or tuples of dimensions passed as each argument are the same, and return the first valid dimension.  If <code>AbstractDimArray</code>s are passed as arguments their dimensions are compared.</p> <p>Empty tuples and <code>nothing</code> dimension values are ignored, returning the <code>Dimension</code> value if it exists.</p> <p>Passing <code>Bool</code> as the first argument means <code>true</code>/<code>false</code> will be returned, rather than throwing an error.</p> <p>Keywords</p> <p>These are all <code>Bool</code> flags:</p> <ul> <li><code>type</code>: compare dimension type, <code>true</code> by default.</li> <li><code>valtype</code>: compare wrapped value type, <code>false</code> by default.</li> <li><code>val</code>: compare wrapped values, <code>false</code> by default.</li> <li><code>order</code>: compare order, <code>false</code> by default.</li> <li><code>length</code>: compare lengths, <code>true</code> by default.</li> <li><code>ignore_length_one</code>: ignore length <code>1</code> in comparisons, and return whichever   dimension is not length 1, if any. This is useful in e.g. broadcasting comparisons.   <code>false</code> by default.</li> <li><code>warn</code>: a <code>String</code> or <code>nothing</code>. Used only for <code>Bool</code> methods,   to give a warning for <code>false</code> values and include <code>warn</code> in the warning text.</li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.combinedims</code> \u2014 Function.</p> <pre><code>combinedims(xs; check=true)\n</code></pre> <p>Combine the dimensions of each object in <code>xs</code>, in the order they are found.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.otherdims</code> \u2014 Function.</p> <pre><code>otherdims(x, query) =&gt; Tuple{Vararg{Dimension,N}}\n</code></pre> <p>Get the dimensions of an object not in <code>query</code>.</p> <p>Arguments</p> <ul> <li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code>.</li> <li><code>query</code>: Tuple or single <code>Dimension</code> or dimension <code>Type</code>.</li> <li><code>f</code>: <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</li> </ul> <p>A tuple holding the unmatched dimensions is always returned.</p> <p>Example</p> <pre><code>julia&gt; using DimensionalData, DimensionalData.Dimensions\n\njulia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia&gt; otherdims(A, X)\nY, Z\n\njulia&gt; otherdims(A, (Y, Z))\nX\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.commondims</code> \u2014 Function.</p> <pre><code>commondims([f], x, query) =&gt; Tuple{Vararg{Dimension}}\n</code></pre> <p>This is basically <code>dims(x, query)</code> where the order of the original is kept, unlike <code>dims</code> where the query tuple determines the order</p> <p>Also unlike <code>dims</code>,<code>commondims</code> always returns a <code>Tuple</code>, no matter the input. No errors are thrown if dims are absent from either <code>x</code> or <code>query</code>.</p> <p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to sort abstract types by concrete types.</p> <pre><code>julia&gt; using DimensionalData, .Dimensions\n\njulia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));\n\njulia&gt; commondims(A, X)\nX\n\njulia&gt; commondims(A, (X, Z))\nX, Z\n\njulia&gt; commondims(A, Ti)\n()\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.sortdims</code> \u2014 Function.</p> <pre><code>sortdims([f], tosort, order) =&gt; Tuple\n</code></pre> <p>Sort dimensions <code>tosort</code> by <code>order</code>. Dimensions in <code>order</code> but missing from <code>tosort</code> are replaced with <code>nothing</code>.</p> <p><code>tosort</code> and <code>order</code> can be <code>Tuple</code>s or <code>Vector</code>s or Dimension or dimension type. Abstract supertypes like <code>TimeDim</code> can be used in <code>order</code>.</p> <p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to sort abstract types by concrete types.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.basetypeof</code> \u2014 Function.</p> <pre><code>basetypeof(x) =&gt; Type\n</code></pre> <p>Get the \"base\" type of an object - the minimum required to define the object without it's fields. By default this is the full <code>UnionAll</code> for the type. But custom <code>basetypeof</code> methods can be defined for types with free type parameters.</p> <p>In DimensionalData this is primariliy used for comparing <code>Dimension</code>s, where <code>Dim{:x}</code> is different from <code>Dim{:y}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.setdims</code> \u2014 Function.</p> <pre><code>setdims(X, newdims) =&gt; AbstractArray\nsetdims(::Tuple, newdims) =&gt; Tuple{Vararg{Dimension,N}}\n</code></pre> <p>Replaces the first dim matching <code>&lt;: basetypeof(newdim)</code> with newdim, and returns a new object or tuple with the dimension updated.</p> <p>Arguments</p> <ul> <li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li> <li><code>newdim</code>: Tuple or single <code>Dimension</code>, <code>Type</code> or <code>Symbol</code>.</li> </ul> <p>Example</p> <pre><code>using DimensionalData, DimensionalData.Dimensions, DimensionalData.LookupArrays\nA = ones(X(10), Y(10:10:100))\nB = setdims(A, Y(Categorical('a':'j'; order=ForwardOrdered())))\nlookup(B, Y)\n# output\nCategorical{Char} ForwardOrdered\nwrapping: 'a':1:'j'\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.dimsmatch</code> \u2014 Function.</p> <pre><code>dimsmatch([f], dim, query) =&gt; Bool\ndimsmatch([f], dims::Tuple, query::Tuple) =&gt; Bool\n</code></pre> <p>Compare 2 dimensions or <code>Tuple</code> of <code>Dimension</code> are of the same base type, or are at least rotations/transformations of the same type.</p> <p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.dimstride</code> \u2014 Function.</p> <pre><code>dimstride(x, dim) =&gt; Int\n</code></pre> <p>Get the stride of the dimension relative to the other dimensions.</p> <p>This may or may not be equal to the stride of the related array, although it will be for <code>Array</code>.</p> <p>Arguments</p> <ul> <li><code>x</code> is any object with a <code>dims</code> method, or a <code>Tuple</code> of <code>Dimension</code>.</li> <li><code>dim</code> is a <code>Dimension</code>, <code>Dimension</code> type, or and <code>Int</code>. Using an <code>Int</code> is not type-stable.</li> </ul> <p>source</p> <p># <code>DimensionalData.refdims_title</code> \u2014 Function.</p> <pre><code>refdims_title(A::AbstractDimArray)\nrefdims_title(refdims::Tuple)\nrefdims_title(refdim::Dimension)\n</code></pre> <p>Generate a title string based on reference dimension values.</p> <p>source</p> <p># <code>DimensionalData.rebuild_from_arrays</code> \u2014 Function.</p> <pre><code>rebuild_from_arrays(s::AbstractDimStack, das::NamedTuple{&lt;:Any,&lt;:Tuple{Vararg{AbstractDimArray}}}; kw...)\n</code></pre> <p>Rebuild an <code>AbstractDimStack</code> from a <code>Tuple</code> or <code>NamedTuple</code> of <code>AbstractDimArray</code> and an existing stack.</p> <p>Keywords</p> <p>Keywords are simply the fields of the stack object:</p> <ul> <li><code>data</code></li> <li><code>dims</code></li> <li><code>refdims</code></li> <li><code>metadata</code></li> <li><code>layerdims</code></li> <li><code>layermetadata</code></li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"reference/#lookuparrays","title":"LookupArrays","text":"<p># <code>DimensionalData.Dimensions.LookupArrays</code> \u2014 Module.</p> <pre><code>LookupArrays\n</code></pre> <p>Module for <code>LookupArrays</code> and [<code>Selector</code>]s used in DimensionalData.jl</p> <p><code>LookupArrays</code> defines traits and <code>AbstractArray</code> wrappers that give specific behaviours for a lookup index when indexed with <code>Selector</code>.</p> <p>For example, these allow tracking over array order so fast indexing works evne when  the array is reversed.</p> <p>To load LookupArrays types and methods into scope:</p> <pre><code>using DimensionalData\nusing DimensionalData.LookupArrays\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#selectors","title":"Selectors","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.Selector</code> \u2014 Type.</p> <pre><code>Selector\n</code></pre> <p>Abstract supertype for all selectors.</p> <p>Selectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as <code>DateTime</code> objects for a <code>Ti</code> dimension.</p> <p>Selectors provided in DimensionalData are:</p> <ul> <li><code>At</code></li> <li><code>Between</code></li> <li><code>Touches</code></li> <li><code>Near</code></li> <li><code>Where</code></li> <li><code>Contains</code></li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.IntSelector</code> \u2014 Type.</p> <pre><code>IntSelector &lt;: Selector\n</code></pre> <p>Abstract supertype for <code>Selector</code>s that return a single <code>Int</code> index.</p> <p>IntSelectors provided by DimensionalData are:</p> <ul> <li><code>At</code></li> <li><code>Contains</code></li> <li><code>Near</code></li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.ArraySelector</code> \u2014 Type.</p> <pre><code>ArraySelector &lt;: Selector\n</code></pre> <p>Abstract supertype for <code>Selector</code>s that return an <code>AbstractArray</code>.</p> <p>ArraySelectors provided by DimensionalData are:</p> <ul> <li><code>Between</code></li> <li><code>Touches</code></li> <li><code>Where</code></li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.At</code> \u2014 Type.</p> <pre><code>At &lt;: IntSelector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n</code></pre> <p>Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.</p> <p><code>x</code> can be any value or <code>Vector</code> of values.</p> <p><code>atol</code> and <code>rtol</code> are passed to <code>isapprox</code>. For <code>Number</code> <code>rtol</code> will be set to <code>Base.rtoldefault</code>, otherwise <code>nothing</code>, and wont be used.</p> <p>Example</p> <pre><code>using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Near</code> \u2014 Type.</p> <pre><code>Near &lt;: IntSelector\n\nNear(x)\n</code></pre> <p>Selector that selects the nearest index to <code>x</code>.</p> <p>With <code>Points</code> this is simply the index values nearest to the <code>x</code>, however with <code>Intervals</code> it is the interval center nearest to <code>x</code>. This will be offset from the index value for <code>Start</code> and <code>End</code> loci.</p> <p>Example</p> <pre><code>using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Between</code> \u2014 Type.</p> <pre><code>Between &lt;: ArraySelector\n\nBetween(a, b)\n</code></pre> <p>Depreciated: use <code>a..b</code> instead of <code>Between(a, b)</code>. Other <code>Interval</code> objects from IntervalSets.jl, like `OpenInterval(a, b) will also work, giving the correct open/closed boundaries.</p> <p><code>Between</code> will e removed in furture to avoid clashes with <code>DataFrames.Between</code>.</p> <p>Selector that retreive all indices located between 2 values, evaluated with <code>&gt;=</code> for the lower value, and <code>&lt;</code> for the upper value. This means the same value will not be counted twice in 2 adjacent <code>Between</code> selections.</p> <p>For <code>Intervals</code> the whole interval must be lie between the values. For <code>Points</code> the points must fall between the values. Different <code>Sampling</code> types may give different results with the same input - this is the intended behaviour.</p> <p><code>Between</code> for <code>Irregular</code> intervals is a little complicated. The interval is the distance between a value and the next (for <code>Start</code> locus) or previous (for <code>End</code> locus) value.</p> <p>For <code>Center</code>, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use <code>Between</code> with <code>Irregular</code> <code>Intervals(Center())</code> with caution.</p> <p>Example</p> <pre><code>using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Between(15, 25)), Y(Between(4, 6.5))]\n\n# output\n\n1\u00d72 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points\n     5  6\n 20  4  5\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Touches</code> \u2014 Type.</p> <pre><code>Touches &lt;: ArraySelector\n\nTouches(a, b)\n</code></pre> <p>Selector that retreives all indices touching the closed interval 2 values, for the maximum possible area that could interact with the supplied range.</p> <p>This can be better than <code>..</code> when e.g. subsetting an area to rasterize, as you may wish to include pixels that just touch the area, rather than those that fall within it.</p> <p>Touches is different to using closed intervals when the lookups also contain intervals - if any of the intervals touch, they are included. With <code>..</code> they are discarded unless the whole cell interval falls inside the selector interval.</p> <p>Example</p> <pre><code>using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Touches(15, 25)), Y(Touches(4, 6.5))]\n\n# output\n1\u00d72 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points\n     5  6\n 20  4  5\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Contains</code> \u2014 Type.</p> <pre><code>Contains &lt;: IntSelector\n\nContains(x)\n</code></pre> <p>Selector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.</p> <p>Can only be used for <code>Intervals</code> or <code>Categorical</code>. For <code>Categorical</code> it falls back to using <code>At</code>. <code>Contains</code> should not be confused with <code>Base.contains</code> - use <code>Where(contains(x))</code> to check for if values are contain in categorical values like strings.</p> <p>Example</p> <pre><code>using DimensionalData; const DD = DimensionalData\ndims_ = X(10:10:20; sampling=DD.Intervals(DD.Center())),\n        Y(5:7; sampling=DD.Intervals(DD.Center()))\nA = DimArray([1 2 3; 4 5 6], dims_)\nA[X(Contains(8)), Y(Contains(6.8))]\n\n# output\n3\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Where</code> \u2014 Type.</p> <pre><code>Where &lt;: ArraySelector\n\nWhere(f::Function)\n</code></pre> <p>Selector that filters a dimension lookup by any function that accepts a single value and returns a <code>Bool</code>.</p> <p>Example</p> <pre><code>using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))\nA[X(Where(x -&gt; x &gt; 15)), Y(Where(x -&gt; x in (19, 21)))]\n\n# output\n\n1\u00d72 DimArray{Int64,2} with dimensions:\n  X Sampled{Int64} Int64[20] ForwardOrdered Regular Points,\n  Y Sampled{Int64} Int64[19, 21] ForwardOrdered Regular Points\n     19  21\n 20   4   6\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.All</code> \u2014 Type.</p> <pre><code>All &lt;: Selector\n\nAll(selectors::Selector...)\n</code></pre> <p>Selector that combines the results of other selectors.  The indices used will be the union of all result sorted in ascending order.</p> <p>Example</p> <pre><code>using DimensionalData, Unitful\n\ndimz = X(10.0:20:200.0), Ti(1u\"s\":5u\"s\":100u\"s\")\nA = DimArray((1:10) * (1:20)', dimz)\nA[X=All(At(10.0), At(50.0)), Ti=All(1u\"s\"..10u\"s\", 90u\"s\"..100u\"s\")]\n\n# output\n\n2\u00d74 DimArray{Int64,2} with dimensions:\n  X Sampled{Float64} Float64[10.0, 50.0] ForwardOrdered Regular Points,\n  Ti Sampled{Quantity{Int64, \ud835\udc13, Unitful.FreeUnits{(s,), \ud835\udc13, nothing}}} Quantity{Int64, \ud835\udc13, Unitful.FreeUnits{(s,), \ud835\udc13, nothing}}[1 s, 6 s, 91 s, 96 s] ForwardOrdered Regular Points\n       1 s  6 s  91 s  96 s\n 10.0    1    2    19    20\n 50.0    3    6    57    60\n</code></pre> <p>source</p> <p>Lookup properties:</p> <p># <code>DimensionalData.Dimensions.LookupArrays.bounds</code> \u2014 Function.</p> <pre><code>bounds(xs, [dims::Tuple]) =&gt; Tuple{Vararg{Tuple{T,T}}}\nbounds(xs::Tuple) =&gt; Tuple{Vararg{Tuple{T,T}}}\nbounds(x, dim) =&gt; Tuple{T,T}\nbounds(dim::Union{Dimension,LookupArray}) =&gt; Tuple{T,T}\n</code></pre> <p>Return the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.</p> <p>If bounds are not known, one or both values may be <code>nothing</code>.</p> <p><code>dims</code> can be a <code>Dimension</code>, a dimension type, or a tuple of either.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.val</code> \u2014 Function.</p> <pre><code>val(x)\nval(dims::Tuple) =&gt; Tuple\n</code></pre> <p>Return the contained value of a wrapper object.</p> <p><code>dims</code> can be <code>Dimension</code>, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>Objects that don't define a <code>val</code> method are returned unaltered.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.LookupArray</code> \u2014 Type.</p> <pre><code>LookupArray\n</code></pre> <p>Types defining the behaviour of a lookup index, how it is plotted and how <code>Selector</code>s like <code>Between</code> work.</p> <p>A <code>LookupArray</code> may be <code>NoLookup</code> indicating that the index is just the underlying array axis, <code>Categorical</code> for ordered or unordered categories,  or a <code>Sampled</code> index for <code>Points</code> or <code>Intervals</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Aligned</code> \u2014 Type.</p> <pre><code>Aligned &lt;: LookupArray\n</code></pre> <p>Abstract supertype for <code>LookupArray</code>s where the index is aligned with the array axes.</p> <p>This is by far the most common supertype for <code>LookupArray</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AbstractSampled</code> \u2014 Type.</p> <pre><code>AbstractSampled &lt;: Aligned\n</code></pre> <p>Abstract supertype for <code>LookupArray</code>s where the index is aligned with the array, and is independent of other dimensions. <code>Sampled</code> is provided by this package.</p> <p><code>AbstractSampled</code> must have  <code>order</code>, <code>span</code> and <code>sampling</code> fields, or a <code>rebuild</code> method that accpts them as keyword arguments.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Sampled</code> \u2014 Type.</p> <pre><code>Sampled &lt;: AbstractSampled\n\nSampled(data::AbstractVector, order::Order, span::Span, sampling::Sampling, metadata)\nSampled(; data=AutoIndex(), order=AutoOrder(), span=AutoSpan(), sampling=Points(), metadata=NoMetadata())\n</code></pre> <p>A concrete implementation of the <code>LookupArray</code> <code>AbstractSampled</code>. It can be used to represent <code>Points</code> or <code>Intervals</code>.</p> <p><code>Sampled</code> is capable of representing gridded data from a wide range of sources, allowing correct <code>bounds</code> and <code>Selector</code>s for points or intervals of regular, irregular, forward and reverse indexes.</p> <p>On <code>AbstractDimArray</code> construction, <code>Sampled</code> lookup is assigned for all lookups of  <code>AbstractRange</code> not assigned to <code>Categorical</code>.</p> <p>Arguments</p> <ul> <li><code>data</code>: An <code>AbstractVector</code> of index values, matching the length of the curresponding   array axis.</li> <li><code>order</code>: <code>Order</code>) indicating the order of the index,   <code>AutoOrder</code> by default, detected from the order of <code>data</code>   to be <code>ForwardOrdered</code>, <code>ReverseOrdered</code> or <code>Unordered</code>.   These can be provided explicitly if they are known and performance is important.</li> <li><code>span</code>: indicates the size of intervals or distance between points, and will be set to   <code>Regular</code> for <code>AbstractRange</code> and <code>Irregular</code> for <code>AbstractArray</code>,   unless assigned manually.</li> <li><code>sampling</code>: is assigned to <code>Points</code>, unless set to <code>Intervals</code> manually.    Using <code>Intervals</code> will change the behaviour of <code>bounds</code> and <code>Selectors</code>s   to take account for the full size of the interval, rather than the point alone.</li> <li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is <code>NoMetadata()</code>.</li> </ul> <p>Example</p> <p>Create an array with [<code>Interval</code>] sampling, and <code>Regular</code> span for a vector with known spacing.</p> <p>We set the <code>Locus</code> of the <code>Intervals</code> to <code>Start</code> specifying that the index values are for the positions at the start of each interval.</p> <pre><code>using DimensionalData, DimensionalData.LookupArrays\n\nx = X(Sampled(100:-20:10; sampling=Intervals(Start())))\ny = Y(Sampled([1, 4, 7, 10]; span=Regular(3), sampling=Intervals(Start())))\nA = ones(x, y)\n\n# output\n5\u00d74 DimArray{Float64,2} with dimensions:\n  X Sampled{Int64} 100:-20:20 ReverseOrdered Regular Intervals,\n  Y Sampled{Int64} Int64[1, 4, 7, 10] ForwardOrdered Regular Intervals\n      1    4    7    10\n 100  1.0  1.0  1.0   1.0\n  80  1.0  1.0  1.0   1.0\n  60  1.0  1.0  1.0   1.0\n  40  1.0  1.0  1.0   1.0\n  20  1.0  1.0  1.0   1.0\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AbstractCategorical</code> \u2014 Type.</p> <pre><code>AbstractCategorical &lt;: Aligned\n</code></pre> <p><code>LookupArray</code>s where the values are categories.</p> <p><code>Categorical</code> is the provided concrete implementation.  but this can easily be extended - all methods are defined for <code>AbstractCategorical</code>.</p> <p>All <code>AbstractCategorical</code> must provide a <code>rebuild</code> method with <code>data</code>, <code>order</code> and <code>metadata</code> keyword arguments.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Categorical</code> \u2014 Type.</p> <pre><code>Categorical &lt;: AbstractCategorical\n\nCategorical(o::Order)\nCategorical(; order=Unordered())\n</code></pre> <p>An LookupArray where the values are categories.</p> <p>This will be automatically assigned if the index contains <code>AbstractString</code>, <code>Symbol</code> or <code>Char</code>. Otherwise it can be assigned manually.</p> <p><code>Order</code> will be determined automatically where possible.</p> <p>Arguments</p> <ul> <li><code>data</code>: An <code>AbstractVector</code> of index values, matching the length of the curresponding   array axis.</li> <li><code>order</code>: <code>Order</code>) indicating the order of the index,   <code>AutoOrder</code> by default, detected from the order of <code>data</code>   to be <code>ForwardOrdered</code>, <code>ReverseOrdered</code> or <code>Unordered</code>.   Can be provided if this is known and performance is important.</li> <li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is <code>NoMetadata()</code>.</li> </ul> <p>Example</p> <p>Create an array with [<code>Interval</code>] sampling.</p> <pre><code>using DimensionalData\n\nds = X([\"one\", \"two\", \"three\"]), Y([:a, :b, :c, :d])\nA = DimArray(rand(3, 4), ds)\nDimensions.lookup(A)\n\n# output\n\nCategorical{String} String[\"one\", \"two\", \"three\"] Unordered,\nCategorical{Symbol} Symbol[:a, :b, :c, :d] ForwardOrdered\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Unaligned</code> \u2014 Type.</p> <pre><code>Unaligned &lt;: LookupArray\n</code></pre> <p>Abstract supertype for <code>LookupArray</code> where the index is not aligned to the grid.</p> <p>Indexing an <code>Unaligned</code> with <code>Selector</code>s must provide all other <code>Unaligned</code> dimensions.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Transformed</code> \u2014 Type.</p> <pre><code>Transformed &lt;: Unaligned\n\nTransformed(f, dim::Dimension; metadata=NoMetadata())\n</code></pre> <p><code>LookupArray</code> that uses an affine transformation to convert dimensions from <code>dims(lookup)</code> to <code>dims(array)</code>. This can be useful when the dimensions are e.g. rotated from a more commonly used axis.</p> <p>Any function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.</p> <p>Arguments</p> <ul> <li><code>f</code>: transformation function</li> <li><code>dim</code>: a dimension to transform to.</li> </ul> <p>Keyword Arguments</p> <ul> <li><code>metdata</code>:</li> </ul> <p>Example</p> <pre><code>using DimensionalData, DimensionalData.LookupArrays, CoordinateTransformations\n\nm = LinearMap([0.5 0.0; 0.0 0.5])\nA = [1 2  3  4\n     5 6  7  8\n     9 10 11 12];\nda = DimArray(A, (t1=Transformed(m, X), t2=Transformed(m, Y)))\n\nda[X(At(6)), Y(At(2))]\n\n# output\n9\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.MergedLookup</code> \u2014 Type.</p> <pre><code>MergedLookup &lt;: LookupArray\n\nMergedLookup(data, dims; [metadata])\n</code></pre> <p>A <code>LookupArray</code> that holds multiple combined dimensions.</p> <p><code>MergedLookup</code> can be indexed with <code>Selector</code>s like <code>At</code>,  <code>Between</code>, and <code>Where</code> although <code>Near</code> has undefined meaning.</p> <p>Arguments</p> <ul> <li><code>data</code>: A <code>Vector</code> of <code>Tuple</code>.</li> <li><code>dims</code>: A <code>Tuple</code> of <code>Dimension</code> indicating the dimensions in the tuples in <code>data</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> object to attach dimension metadata.</li> </ul> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.NoLookup</code> \u2014 Type.</p> <pre><code>NoLookup &lt;: LookupArray\n\nNoLookup()\n</code></pre> <p>A <code>LookupArray</code> that is identical to the array axis.  <code>Selector</code>s can't be used on this lookup.</p> <p>Example</p> <p>Defining a <code>DimArray</code> without passing an index to the dimensions, it will be assigned <code>NoLookup</code>:</p> <pre><code>using DimensionalData\n\nA = DimArray(rand(3, 3), (X, Y))\nDimensions.lookup(A)\n\n# output\n\nNoLookup, NoLookup\n</code></pre> <p>Which is identical to:</p> <pre><code>using .LookupArrays\nA = DimArray(rand(3, 3), (X(NoLookup()), Y(NoLookup())))\nDimensions.lookup(A)\n\n# output\n\nNoLookup, NoLookup\n</code></pre> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AutoLookup</code> \u2014 Type.</p> <pre><code>AutoLookup &lt;: LookupArray\n\nAutoLookup()\nAutoLookup(index=AutoIndex(); kw...)\n</code></pre> <p>Automatic <code>LookupArray</code>, the default lookup. It will be converted automatically to another <code>LookupArray</code> when it is possible to detect it from the index.</p> <p>Keywords will be used in the detected <code>LookupArray</code> constructor.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AutoIndex</code> \u2014 Type.</p> <pre><code>AutoIndex\n</code></pre> <p>Detect a <code>LookupArray</code> index from the context. This is used in <code>NoLookup</code> to simply use the array axis as the index when the array is constructed, and in <code>set</code> to change the <code>LookupArray</code> type without changing the index values.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#metadata","title":"Metadata","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.AbstractMetadata</code> \u2014 Type.</p> <pre><code>AbstractMetadata{X,T}\n</code></pre> <p>Abstract supertype for all metadata wrappers.</p> <p>Metadata wrappers allow tracking the contents and origin of metadata. This can  facilitate conversion between metadata types (for saving a file to a differenet format) or simply saving data back to the same file type with identical metadata.</p> <p>Using a wrapper instead of <code>Dict</code> or <code>NamedTuple</code> also lets us pass metadata  objects to <code>set</code> without ambiguity about where to put them.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Metadata</code> \u2014 Type.</p> <pre><code>Metadata &lt;: AbstractMetadata\n\nMetadata{X}(val::Union{Dict,NamedTuple})\nMetadata{X}(pairs::Pair...) =&gt; Metadata{Dict}\nMetadata{X}(; kw...) =&gt; Metadata{NamedTuple}\n</code></pre> <p>General <code>Metadata</code> object. The <code>X</code> type parameter categorises the metadata for method dispatch, if required. </p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.NoMetadata</code> \u2014 Type.</p> <pre><code>NoMetadata &lt;: AbstractMetadata\n\nNoMetadata()\n</code></pre> <p>Indicates an object has no metadata. But unlike using <code>nothing</code>,  <code>get</code>, <code>keys</code> and <code>haskey</code> will still work on it, <code>get</code> always returning the fallback argument. <code>keys</code> returns <code>()</code> while <code>haskey</code> always returns <code>false</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#lookuparray-traits","title":"LookupArray traits","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.LookupArrayTrait</code> \u2014 Type.</p> <pre><code>LookupArrayTrait\n</code></pre> <p>Abstract supertype of all traits of a <code>LookupArray</code>.</p> <p>These modify the behaviour of the lookup index.</p> <p>The term \"Trait\" is used loosely - these may be fields of an object of traits hard-coded to specific types.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#order","title":"Order","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.Order</code> \u2014 Type.</p> <pre><code>Order &lt;: LookupArrayTrait\n</code></pre> <p>Traits for the order of a <code>LookupArray</code>. These determine how <code>searchsorted</code> finds values in the index, and how objects are plotted.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Ordered</code> \u2014 Type.</p> <pre><code>Ordered &lt;: Order\n</code></pre> <p>Supertype for the order of an ordered <code>LookupArray</code>, including <code>ForwardOrdered</code> and <code>ReverseOrdered</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.ForwardOrdered</code> \u2014 Type.</p> <pre><code>ForwardOrdered &lt;: Ordered\n\nForwardOrdered()\n</code></pre> <p>Indicates that the <code>LookupArray</code> index is in the normal forward order.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.ReverseOrdered</code> \u2014 Type.</p> <pre><code>ReverseOrdered &lt;: Ordered\n\nReverseOrdered()\n</code></pre> <p>Indicates that the <code>LookupArray</code> index is in the reverse order.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Unordered</code> \u2014 Type.</p> <pre><code>Unordered &lt;: Order\n\nUnordered()\n</code></pre> <p>Indicates that <code>LookupArray</code> is unordered.</p> <p>This means the index cannot be searched with <code>searchsortedfirst</code> or similar optimised methods - instead it will use <code>findfirst</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AutoOrder</code> \u2014 Type.</p> <pre><code>AutoOrder &lt;: Order\n\nAutoOrder()\n</code></pre> <p>Specifies that the <code>Order</code> of a <code>LookupArray</code> will be found automatically where possible.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#span","title":"Span","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.Span</code> \u2014 Type.</p> <pre><code>Span &lt;: LookupArrayTrait\n</code></pre> <p>Defines the type of span used in a <code>Sampling</code> index. These are <code>Regular</code> or <code>Irregular</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Regular</code> \u2014 Type.</p> <pre><code>Regular &lt;: Span\n\nRegular(step=AutoStep())\n</code></pre> <p><code>Points</code> or <code>Intervals</code> that have a fixed, regular step.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Irregular</code> \u2014 Type.</p> <pre><code>Irregular &lt;: Span\n\nIrregular(bounds::Tuple)\nIrregular(lowerbound, upperbound)\n</code></pre> <p><code>Points</code> or <code>Intervals</code> that have an <code>Irrigular</code> step size. To enable bounds tracking and accuract selectors, the starting bounds are provided as a 2 tuple, or 2 arguments. <code>(nothing, nothing)</code> is acceptable input, the bounds will be guessed from the index, but may be innaccurate.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Explicit</code> \u2014 Type.</p> <pre><code>Explicit(bounds::AbstractMatix)\n</code></pre> <p>Intervals where the span is explicitly listed for every interval.</p> <p>This uses a matrix where with length 2 columns for each index value, holding the lower and upper bounds for that specific index.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AutoSpan</code> \u2014 Type.</p> <pre><code>AutoSpan &lt;: Span\n\nAutoSpan()\n</code></pre> <p>The span will be guessed and replaced in <code>format</code> or <code>set</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#sampling","title":"Sampling","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.Sampling</code> \u2014 Type.</p> <pre><code>Sampling &lt;: LookupArrayTrait\n</code></pre> <p>Indicates the sampling method used by the index: <code>Points</code> or <code>Intervals</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Points</code> \u2014 Type.</p> <pre><code>Points &lt;: Sampling\n\nPoints()\n</code></pre> <p><code>Sampling</code> lookup where single samples at exact points.</p> <p>These are always plotted at the center of array cells.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Intervals</code> \u2014 Type.</p> <pre><code>Intervals &lt;: Sampling\n\nIntervals(locus::Locus)\n</code></pre> <p><code>Sampling</code> specifying that sampled values are the mean (or similar) value over an interval, rather than at one specific point.</p> <p>Intervals require a <code>Locus</code> of <code>Start</code>, <code>Center</code> or <code>End</code> to define the location in the interval that the index values refer to.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#loci","title":"Loci","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.Locus</code> \u2014 Type.</p> <p>Locus &lt;: LookupArrayTrait</p> <p>Abstract supertype of types that indicate the position of index values  where they represent <code>Intervals</code>.</p> <p>These allow for values array cells to align with the <code>Start</code>, <code>Center</code>, or <code>End</code> of values in the lookup index.</p> <p>This means they can be plotted with correct axis markers, and allows automatic converrsions to between formats with different standards (such as NetCDF and GeoTiff).</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Center</code> \u2014 Type.</p> <pre><code>Center &lt;: Locus\n\nCenter()\n</code></pre> <p>Indicates a lookup value is for the center of its corresponding array cell.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.Start</code> \u2014 Type.</p> <pre><code>Start &lt;: Locus\n\nStart()\n</code></pre> <p>Indicates a lookup value is for the start of its corresponding array cell, in the direction of the lookup index order.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.End</code> \u2014 Type.</p> <pre><code>End &lt;: Locus\n\nEnd()\n</code></pre> <p>Indicates a lookup value is for the end of its corresponding array cell, in the direction of the lookup index order.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.AutoLocus</code> \u2014 Type.</p> <pre><code>AutoLocus &lt;: Locus\n\nAutoLocus()\n</code></pre> <p>Indicates a interval where the index position is not yet known. This will be filled with a default value on object construction.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#lookuparrays-methods","title":"LookupArrays methods","text":"<p># <code>DimensionalData.Dimensions.LookupArrays.hasselection</code> \u2014 Function.</p> <pre><code>hasselection(x, selector) =&gt; Bool\nhasselection(x, selectors::Tuple) =&gt; Bool\n</code></pre> <p>Check if indexing into x with <code>selectors</code> can be performed, where x is some object with a <code>dims</code> method, and <code>selectors</code> is a <code>Selector</code> or <code>Dimension</code> or a tuple of either.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.shiftlocus</code> \u2014 Function.</p> <pre><code>shiftlocus(locus::Locus, x)\n</code></pre> <p>Shift the index of <code>x</code> from the current locus to the new locus.</p> <p>We only shift <code>Sampled</code>, <code>Regular</code> or <code>Explicit</code>, <code>Intervals</code>. </p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.sampling</code> \u2014 Function.</p> <pre><code>sampling(x, [dims::Tuple]) =&gt; Tuple\nsampling(x, dim) =&gt; Sampling\nsampling(xs::Tuple) =&gt; Tuple{Vararg{Sampling}}\nsampling(x:Union{Dimension,LookupArray}) =&gt; Sampling\n</code></pre> <p>Return the <code>Sampling</code> for each dimension.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.span</code> \u2014 Function.</p> <pre><code>span(x, [dims::Tuple]) =&gt; Tuple\nspan(x, dim) =&gt; Span\nspan(xs::Tuple) =&gt; Tuple{Vararg{Span,N}}\nspan(x::Union{Dimension,LookupArray}) =&gt; Span\n</code></pre> <p>Return the <code>Span</code> for each dimension.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.order</code> \u2014 Function.</p> <pre><code>order(x, [dims::Tuple]) =&gt; Tuple\norder(xs::Tuple) =&gt; Tuple\norder(x::Union{Dimension,LookupArray}) =&gt; Order\n</code></pre> <p>Return the <code>Ordering</code> of the dimension index for each dimension: <code>ForwardOrdered</code>, <code>ReverseOrdered</code>, or <code>Unordered</code> </p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.index</code> \u2014 Function.</p> <pre><code>index(x) =&gt; Tuple{Vararg{AbstractArray}}\nindex(x, dims::Tuple) =&gt; Tuple{Vararg{AbstractArray}}\nindex(dims::Tuple) =&gt; Tuple{Vararg{AbstractArray}}}\nindex(x, dim) =&gt; AbstractArray\nindex(dim::Dimension) =&gt; AbstractArray\n</code></pre> <p>Return the contained index of a <code>Dimension</code>.</p> <p>Only valid when a <code>Dimension</code> contains an <code>AbstractArray</code> or a Val tuple like <code>Val{(:a, :b)}()</code>. The <code>Val</code> is unwrapped to return just the <code>Tuple</code></p> <p><code>dims</code> can be a <code>Dimension</code>, or a tuple of <code>Dimension</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.locus</code> \u2014 Function.</p> <pre><code>locus(x, [dims::Tuple]) =&gt; Tuple\nlocus(x, dim) =&gt; Locus\nlocus(xs::Tuple) =&gt; Tuple{Vararg{Locus,N}}\nlocus(x::Union{Dimension,LookupArray}) =&gt; Locus\n</code></pre> <p>Return the <code>Locus</code> for each dimension.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p># <code>DimensionalData.Dimensions.LookupArrays.units</code> \u2014 Function.</p> <pre><code>units(x) =&gt; Union{Nothing,Any}\nunits(xs:Tuple) =&gt; Tuple\nunit(A::AbstractDimArray, dims::Tuple) =&gt; Tuple\nunit(A::AbstractDimArray, dim) =&gt; Union{Nothing,Any}\n</code></pre> <p>Get the units of an array or <code>Dimension</code>, or a tuple of of either.</p> <p>Units do not have a set field, and may or may not be included in <code>metadata</code>. This method is to facilitate use in labels and plots when units are available, not a guarantee that they will be. If not available, <code>nothing</code> is returned.</p> <p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#name","title":"Name","text":"<p># <code>DimensionalData.AbstractName</code> \u2014 Type.</p> <pre><code>AbstractName\n</code></pre> <p>Abstract supertype for name wrappers.</p> <p>source</p> <p># <code>DimensionalData.Name</code> \u2014 Type.</p> <pre><code>Name &lt;: AbstractName\n\nName(name::Union{Symbol,Name) =&gt; Name\nName(name::NoName) =&gt; NoName\n</code></pre> <p>Name wrapper. This lets arrays keep symbol names when the array wrapper neeeds to be `isbits, like for use on GPUs. It makes the name a property of the type. It's not necessary to use in normal use, a symbol is probably easier.</p> <p>source</p> <p># <code>DimensionalData.NoName</code> \u2014 Type.</p> <pre><code>NoName &lt;: AbstractName\n\nNoName()\n</code></pre> <p>NoName specifies an array is not named, and is the default <code>name</code> value for all <code>AbstractDimArray</code>s.</p> <p>source</p>"},{"location":"crash/generated/course/course/","title":"Crash course","text":"<pre><code>using DimensionalData\n</code></pre>"},{"location":"crash/generated/course/course/#dimensions-and-dimarrays","title":"Dimensions and DimArrays","text":"<p>The core type of DimensionalData.jl is the <code>Dimension</code> and the types that inherit from it, such as <code>Ti</code>, <code>X</code>, <code>Y</code>, <code>Z</code>, the generic <code>Dim{:x}</code>, or others that you define manually using the <code>@dim</code> macro.</p> <p><code>Dimension</code>s are primarily used in <code>DimArray</code>, other <code>AbstractDimArray</code>.</p> <p>We can use dimensions without a value index - these simply label the axis. A <code>DimArray</code> with labelled dimensions is constructed by:</p> <pre><code>using DimensionalData\nA = rand(X(5), Y(5))\n</code></pre> <pre><code>5\u00d75 DimArray{Float64,2} with dimensions: X, Y\n 0.575845  0.503075   0.846088  0.744842    0.0834031\n 0.320559  0.670034   0.364521  0.504848    0.409066\n 0.6739    0.81651    0.38826   0.00656372  0.304979\n 0.764852  0.0414213  0.751945  0.54616     0.712366\n 0.357632  0.576771   0.130437  0.893146    0.0326252\n</code></pre> <p>get value</p> <pre><code>A[Y(1), X(2)]\n</code></pre> <pre><code>0.3205591747768116\n</code></pre> <p>As shown above, <code>Dimension</code>s can be used to construct arrays in <code>rand</code>, <code>ones</code>, <code>zeros</code> and <code>fill</code> with either a range for a lookup index or a number for the dimension length.</p> <p>Or we can use the <code>Dim{X}</code> dims by using <code>Symbol</code>s, and indexing with keywords:</p> <pre><code>A = DimArray(rand(5, 5), (:a, :b))\n</code></pre> <pre><code>5\u00d75 DimArray{Float64,2} with dimensions: Dim{:a}, Dim{:b}\n 0.510138  0.327022   0.183774    0.551202  0.165165\n 0.607462  0.717694   0.00949621  0.643547  0.506799\n 0.695307  0.0625053  0.275305    0.62337   0.952864\n 0.164045  0.289143   0.510902    0.526893  0.188675\n 0.396806  0.386633   0.972746    0.712217  0.209276\n</code></pre> <p>get value</p> <pre><code>A[a=3, b=5]\n</code></pre> <pre><code>0.952864430325203\n</code></pre> <p>Often, we want to provide a lookup index for the dimension:</p> <pre><code>using Dates\nt = DateTime(2001):Month(1):DateTime(2001,12)\nx = 10:10:100\nA = rand(X(x), Ti(t))\n</code></pre> <pre><code>10\u00d712 DimArray{Float64,2} with dimensions: \n  X Sampled{Int64} 10:10:100 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\") ForwardOrdered Regular Points\n       2001-01-01T00:00:00  \u2026   2001-12-01T00:00:00\n  10  0.122791                             0.63477\n  20  0.44312                              0.336359\n  30  0.993757                             0.915154\n  40  0.0460592                            0.18038\n  50  0.623161                          \u2026  0.0922049\n  60  0.107225                             0.727586\n  70  0.605241                             0.785811\n  80  0.667556                             0.275073\n  90  0.383514                             0.527582\n 100  0.695338                          \u2026  0.645872\n</code></pre> <p>Here both <code>X</code> and <code>Ti</code> are dimensions from <code>DimensionalData</code>. The currently exported dimensions are <code>X, Y, Z, Ti</code> (<code>Ti</code> is shortening of <code>Time</code>).</p> <p>The length of each dimension index has to match the size of the corresponding array axis.</p> <p>This can also be done with <code>Symbol</code>, using <code>Dim{X}</code>:</p> <pre><code>A2 = DimArray(rand(12, 10), (time=t, distance=x))\n</code></pre> <pre><code>12\u00d710 DimArray{Float64,2} with dimensions: \n  Dim{:time} Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\") ForwardOrdered Regular Points,\n  Dim{:distance} Sampled{Int64} 10:10:100 ForwardOrdered Regular Points\n                                   \u2026  80         90          100\n  2001-01-01T00:00:00      0.852033   0.776827     0.30781\n  2001-02-01T00:00:00      0.247393   0.346492     0.516344\n  2001-03-01T00:00:00      0.884009   0.409872     0.304084\n  2001-04-01T00:00:00      0.74019    0.840586     0.125215\n  2001-05-01T00:00:00  \u2026   0.199695   0.0484128    0.896765\n  2001-06-01T00:00:00      0.188165   0.687792     0.199987\n  2001-07-01T00:00:00      0.208007   0.493789     0.305995\n  2001-08-01T00:00:00      0.643876   0.261101     0.696159\n  2001-09-01T00:00:00      0.958557   0.592912     0.991241\n  2001-10-01T00:00:00  \u2026   0.969151   0.241549     0.504844\n  2001-11-01T00:00:00      0.68322    0.931645     0.575774\n  2001-12-01T00:00:00      0.114908   0.809101     0.124\n</code></pre> <p>Symbols can be more convenient to use than defining custom dims with <code>@dim</code>, but have some downsides. They don't inherit from a specific <code>Dimension</code> type, so plots will not know what axis to put them on. They also cannot use the basic constructor methods like <code>rand</code> or <code>zeros</code>, as we cannot dispatch on <code>Symbol</code> for Base methods without \"type-piracy\".</p> <p></p> <p></p>"},{"location":"crash/generated/course/course/#indexing-the-array-by-name-and-index","title":"Indexing the array by name and index","text":"<p>Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.</p> <p>The simplest case is to select a dimension by index. Let's say every 2nd point of the <code>Ti</code> dimension and every 3rd point of the <code>X</code> dimension. This is done with the simple <code>Ti(range)</code> syntax like so:</p> <pre><code>A[X(1:3:11), Ti(1:2:11)]\n</code></pre> <pre><code>4\u00d76 DimArray{Float64,2} with dimensions: \n  X Sampled{Int64} 10:30:100 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(2):DateTime(\"2001-11-01T00:00:00\") ForwardOrdered Regular Points\n       2001-01-01T00:00:00  \u2026   2001-11-01T00:00:00\n  10  0.122791                             0.358315\n  40  0.0460592                            0.041568\n  70  0.605241                             0.0260872\n 100  0.695338                             0.934139\n</code></pre> <p>When specifying only one dimension, all elements of the other dimensions are assumed to be included:</p> <pre><code>A[X(1:3:10)]\n</code></pre> <pre><code>4\u00d712 DimArray{Float64,2} with dimensions: \n  X Sampled{Int64} 10:30:100 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\") ForwardOrdered Regular Points\n       2001-01-01T00:00:00  \u2026   2001-12-01T00:00:00\n  10  0.122791                             0.63477\n  40  0.0460592                            0.18038\n  70  0.605241                             0.785811\n 100  0.695338                             0.645872\n</code></pre> <p>Indexing</p> <p>Indexing <code>AbstractDimArray</code>s works with <code>getindex</code>, <code>setindex!</code> and   <code>view</code>. The result is still an <code>AbstracDimArray</code>, unless using all single   <code>Int</code> or <code>Selector</code>s that resolve to <code>Int</code>.</p> <p><code>Dimension</code>s can be used to construct arrays in <code>rand</code>, <code>ones</code>, <code>zeros</code> and <code>fill</code> with either a range for a lookup index or a number for the dimension length.</p> <pre><code>using DimensionalData\nA1 = ones(X(1:40), Y(50))\n</code></pre> <pre><code>40\u00d750 DimArray{Float64,2} with dimensions: \n  X Sampled{Int64} 1:40 ForwardOrdered Regular Points,\n  Y\n  1  1.0  1.0  1.0  1.0  1.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  2  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  3  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  4  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  5  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  6  1.0  1.0  1.0  1.0  1.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n  \u22ee                      \u22ee              \u22f1  \u22ee                        \u22ee    \n 35  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 36  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 37  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 38  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 39  1.0  1.0  1.0  1.0  1.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 40  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n</code></pre> <p>We can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:</p> <pre><code>A1[Y(1), X(1:10)]\n</code></pre> <pre><code>10-element DimArray{Float64,1} with dimensions: \n  X Sampled{Int64} 1:10 ForwardOrdered Regular Points\nand reference dimensions: Y\n  1  1.0\n  2  1.0\n  3  1.0\n  4  1.0\n  5  1.0\n  6  1.0\n  7  1.0\n  8  1.0\n  9  1.0\n 10  1.0\n</code></pre> <p></p> <p></p>"},{"location":"crash/generated/course/course/#indexing-performance","title":"Indexing Performance","text":"<p>Indexing with <code>Dimension</code> has no runtime cost:</p> <pre><code>A2 = ones(X(3), Y(3))\n</code></pre> <pre><code>3\u00d73 DimArray{Float64,2} with dimensions: X, Y\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n</code></pre> <p>time ?</p> <pre><code>using BenchmarkTools\n\nprintln(@btime $A2[X(1), Y(2)])\n</code></pre> <pre><code>  38.872 ns (0 allocations: 0 bytes)\n1.0\n</code></pre> <p>and</p> <pre><code>println(@btime parent($A2)[1, 2])\n</code></pre> <pre><code>  4.000 ns (0 allocations: 0 bytes)\n1.0\n</code></pre> <p></p> <p></p>"},{"location":"crash/generated/course/course/#specifying-dims-keyword-arguments-with-dimension","title":"Specifying <code>dims</code> keyword arguments with <code>Dimension</code>","text":"<p>In many Julia functions like <code>size</code> or <code>sum</code>, you can specify the dimension along which to perform the operation as an <code>Int</code>. It is also possible to do this using <code>Dimension</code> types with <code>AbstractDimArray</code>:</p> <pre><code>A3 = rand(X(3), Y(4), Ti(5));\nsum(A3; dims=Ti)\n</code></pre> <pre><code>3\u00d74\u00d71 DimArray{Float64,3} with dimensions: X, Y, Ti\n[:, :, 1]\n 1.81167  2.89716  2.30465  2.3051\n 1.51508  3.76079  2.9724   3.08343\n 2.63028  1.98546  2.64894  2.36519\n</code></pre> <p>This also works in methods from <code>Statistics</code>:</p> <pre><code>using Statistics\nmean(A3; dims=Ti)\n</code></pre> <pre><code>3\u00d74\u00d71 DimArray{Float64,3} with dimensions: X, Y, Ti\n[:, :, 1]\n 0.362333  0.579432  0.460931  0.461021\n 0.303016  0.752159  0.59448   0.616685\n 0.526055  0.397092  0.529789  0.473038\n</code></pre> <p></p> <p></p>"},{"location":"crash/generated/course/course/#methods-where-dims-dim-types-or-symbols-can-be-used-to-indicate-the-array-dimension","title":"Methods where dims, dim types, or <code>Symbol</code>s can be used to indicate the array dimension:","text":"<ul> <li><code>size</code>, <code>axes</code>, <code>firstindex</code>, <code>lastindex</code></li> <li><code>cat</code>, <code>reverse</code>, <code>dropdims</code></li> <li><code>reduce</code>, <code>mapreduce</code></li> <li><code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>,</li> <li><code>mean</code>, <code>median</code>, <code>extrema</code>, <code>std</code>, <code>var</code>, <code>cor</code>, <code>cov</code></li> <li><code>permutedims</code>, <code>adjoint</code>, <code>transpose</code>, <code>Transpose</code></li> <li><code>mapslices</code>, <code>eachslice</code></li> </ul>"},{"location":"crash/generated/course/course/#lookuparrays-and-selectors","title":"LookupArrays and Selectors","text":"<p>Indexing by value in <code>DimensionalData</code> is done with Selectors. IntervalSets.jl is now used for selecting ranges of values (formerly <code>Between</code>).</p> Selector Description <code>At(x)</code> get the index exactly matching the passed in value(s) <code>Near(x)</code> get the closest index to the passed in value(s) <code>Contains(x)</code> get indices where the value x falls within an interval <code>Where(f)</code> filter the array axis by a function of the dimension index values. [<code>Not(x)</code>] get all indices not selected by <code>x</code>, which can be another selector. [<code>a..b</code>] get all indices between two values, inclusively. [<code>OpenInterval(a, b)</code>] get all indices between <code>a</code> and <code>b</code>, exclusively. [<code>Interval{A,B}(a, b)</code>] get all indices between <code>a</code> and <code>b</code>, as <code>:closed</code> or <code>:open</code>. <p>Selectors find indices in the <code>LookupArray</code>, for each dimension. Here we use an <code>Interval</code> to select a range between integers and <code>DateTime</code>:</p> <pre><code>A[X(12..35), Ti(Date(2001, 5)..Date(2001, 7))]\n</code></pre> <pre><code>2\u00d73 DimArray{Float64,2} with dimensions: \n  X Sampled{Int64} 20:10:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-05-01T00:00:00\"):Month(1):DateTime(\"2001-07-01T00:00:00\") ForwardOrdered Regular Points\n      2001-05-01T00:00:00  \u2026   2001-07-01T00:00:00\n 20  0.327406                             0.677794\n 30  0.183331                             0.187738\n</code></pre> <p>To select intervals in DimArrays (e.g. <code>A2</code>) you need to specify <code>dimname=a .. b</code>:</p> <pre><code>A2[distance=12 .. 35, time=Date(2001, 5) .. Date(2001, 7)]\n</code></pre> <pre><code>3\u00d73 DimArray{Float64,2} with dimensions: X, Y\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n</code></pre> <p>Selectors can be used in <code>getindex</code>, <code>setindex!</code> and <code>view</code> to select indices matching the passed in value(s)</p> <p>We can use selectors inside dim wrappers, here selecting values from <code>DateTime</code> and <code>Int</code>:</p> <pre><code>using Dates\ntimespan = DateTime(2001,1):Month(1):DateTime(2001,12)\nA4 = rand(Ti(timespan), X(10:10:100))\nA4[X(Near(35)), Ti(At(DateTime(2001,5)))]\n</code></pre> <pre><code>0.871061228214121\n</code></pre> <p>Without dim wrappers selectors must be in the right order, and specify all axes:</p> <pre><code>using Unitful\nA5 = rand(Y((1:10:100)u\"m\"), Ti((1:5:100)u\"s\"));\nA5[10.5u\"m\" .. 50.5u\"m\", Near(23u\"s\")]\n</code></pre> <pre><code>4-element DimArray{Float64,1} with dimensions: \n  Y Sampled{Quantity{Int64, \ud835\udc0b, Unitful.FreeUnits{(m,), \ud835\udc0b, nothing}}} (11:10:41) m ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{Quantity{Int64, \ud835\udc13, Unitful.FreeUnits{(s,), \ud835\udc13, nothing}}} (21:5:21) s ForwardOrdered Regular Points\n 11 m  0.617481\n 21 m  0.20888\n 31 m  0.979066\n 41 m  0.246627\n</code></pre> <p>We can also use Linear indices as in standard <code>Array</code>:</p> <pre><code>A5[1:5]\n</code></pre> <pre><code>5-element Vector{Float64}:\n 0.44431603584182167\n 0.9542315595525419\n 0.36639730474887067\n 0.7086216625889914\n 0.03479043095496592\n</code></pre> <p>But unless the <code>DimArray</code> is one dimensional, this will return a regular <code>Array</code>. It is not possible to keep the <code>LookupArray</code> or even <code>Dimension</code>s after linear indexing is used.</p> <p></p> <p></p>"},{"location":"crash/generated/course/course/#lookuparrays-and-traits","title":"LookupArrays and traits","text":"<p>Using a regular range or <code>Vector</code> as a lookup index has a number of downsides. We cannot use <code>searchsorted</code> for fast searches without knowing the order of the array, and this is slow to compute at runtime. It also means <code>reverse</code> or rotations cannot be used while keeping the <code>DimArray</code> wrapper.</p> <p>Step sizes are also a problem. Some ranges like <code>LinRange</code> lose their step size with a length of <code>1</code>. Often, instead of a range, multi-dimensional data formats provide a <code>Vector</code> of evenly spaced values for a lookup, with a step size specified separately. Converting to a range introduces floating point errors that means points may not be selected with <code>At</code> without setting tolerances.</p> <p>This means using a lookup wrapper with traits is more generally robust and versatile than simply using a range or vector. DimensionalData provides types for specifying details about the dimension index, in the <code>LookupArrays</code> sub-module:</p> <pre><code>using DimensionalData\nusing .LookupArrays\n</code></pre> <p>The main <code>LookupArray</code> are :</p> <ul> <li><code>Sampled</code></li> <li><code>Categorical</code>,</li> <li><code>NoLookup</code></li> </ul> <p>Each comes with specific traits that are either fixed or variable, depending on the contained index. These enable optimisations with <code>Selector</code>s, and modified behaviours, such as:</p> <ol> <li>Selection of <code>Intervals</code> or <code>Points</code>, which will give slightly</li> </ol> <p>different results for selectors like <code>..</code> - as whole intervals are   selected, and have different <code>bounds</code> values.</p> <ol> <li>Tracking of lookup order. A reverse order is labelled <code>ReverseOrdered</code> and</li> </ol> <p>will still work with <code>searchsorted</code>, and for plots to always be the right way   up when either the index or the array is backwards. Reversing a <code>DimArray</code>   will reverse the <code>LookupArray</code> for that dimension, swapping <code>ReverseOrdered</code>   to <code>ForwardOrdered</code>.</p> <ol> <li> <p><code>Sampled</code> <code>Intervals</code> can have index located at a <code>Locus</code> of:</p> </li> <li> <p><code>Start</code>,</p> </li> <li><code>Center</code></li> <li><code>End</code></li> </ol> <p>Which specifies the point of the interval represented in the index, to match different data standards, e.g. GeoTIFF (<code>Start</code>) and NetCDF (<code>Center</code>).</p> <ol> <li>A <code>Span</code> specifies the gap between <code>Points</code> or the size of</li> </ol> <p><code>Intervals</code>. This may be:</p> <ul> <li><code>Regular</code>, in the case of a range and equally spaced vector,</li> <li><code>Irregular</code> for unequally spaced vectors</li> <li><code>Explicit</code> for the case where all interval start and end points are specified explicitly - as is common in the NetCDF standard.</li> </ul> <p>These traits all for subtypes of <code>Aligned</code>.</p> <p><code>Unaligned</code> also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as <code>Transformed</code>.</p> <p></p> <p></p>"},{"location":"crash/generated/course/course/#lookuparray-detection","title":"LookupArray detection","text":"<p><code>Aligned</code> types will be detected automatically if not specified - which usually isn't required.</p> <ul> <li>An empty <code>Dimension</code> or a <code>Type</code> or <code>Symbol</code> will be assigned <code>NoLookup</code> - this behaves as a simple named dimension without a lookup index.</li> <li>A <code>Dimension</code> containing and index of <code>String</code>, <code>Char</code>, <code>Symbol</code> or mixed types will be given the <code>Categorical</code> mode,</li> <li>A range will be assigned <code>Sampled</code>, defaulting to <code>Regular</code>, <code>Points</code></li> <li>Other <code>AbstractVector</code> will be assigned <code>Sampled</code> <code>Irregular</code> <code>Points</code>.</li> </ul> <p>In all cases the <code>Order</code> of <code>ForwardOrdered</code> or <code>ReverseOrdered</code> will be be detected, otherwise <code>Unordered</code> for an unsorted <code>Array</code>.</p> <p>See the <code>LookupArray</code> API docs for more detail.</p> <p></p> <p></p>"},{"location":"crash/generated/course/course/#referenced-dimensions","title":"Referenced dimensions","text":"<p>The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes so that <code>cat</code> can reconstruct the lookup array from previous dimensions that have been sliced.</p> <p></p> <p></p>"},{"location":"crash/generated/course/course/#warnings","title":"Warnings","text":"<p>Indexing with unordered or reverse-ordered arrays has undefined behaviour. It will trash the dimension index, break <code>searchsorted</code> and nothing will make sense any more. So do it at you own risk.</p> <p>However, indexing with sorted vectors of <code>Int</code> can be useful, so it's allowed. But it may do strange things to interval sizes for <code>Intervals</code> that are not <code>Explicit</code>.</p> <p>This selects the first 5 entries of the underlying array. In the case that <code>A</code> has only one dimension, it will be retained. Multidimensional <code>AbstracDimArray</code> indexed this way will return a regular array.</p> <p>This page was generated using Literate.jl.</p>"}]}