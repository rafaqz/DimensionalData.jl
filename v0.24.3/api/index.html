<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DimensionalData.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DimensionalData.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../course/">Crash course</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Arrays"><span>Arrays</span></a></li><li><a class="tocitem" href="#Multi-array-datasets"><span>Multi-array datasets</span></a></li><li><a class="tocitem" href="#Dimension-indices-generators"><span>Dimension indices generators</span></a></li><li><a class="tocitem" href="#Tables.jl/TableTraits.jl-interface"><span>Tables.jl/TableTraits.jl interface</span></a></li><li><a class="tocitem" href="#Common-methods"><span>Common methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Dimensions"><span>Dimensions</span></a></li><li class="toplevel"><a class="tocitem" href="#LookupArrays"><span>LookupArrays</span></a></li><li><a class="tocitem" href="#Selectors"><span>Selectors</span></a></li><li><a class="tocitem" href="#Metadata"><span>Metadata</span></a></li><li><a class="tocitem" href="#LookupArray-traits"><span>LookupArray traits</span></a></li><li><a class="tocitem" href="#LookupArrays-methods"><span>LookupArrays methods</span></a></li><li><a class="tocitem" href="#Name"><span>Name</span></a></li></ul></li><li><a class="tocitem" href="../developer/">For Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rafaqz/DimensionalData.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Arrays"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.AbstractDimArray" href="#DimensionalData.AbstractDimArray"><code>DimensionalData.AbstractDimArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDimArray &lt;: AbstractArray</code></pre><p>Abstract supertype for all &quot;dim&quot; arrays.</p><p>These arrays return a <code>Tuple</code> of <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a> from a <a href="#DimensionalData.Dimensions.dims"><code>dims</code></a> method, and can be rebuilt using <a href="#DimensionalData.Dimensions.LookupArrays.rebuild"><code>rebuild</code></a>.</p><p><code>parent</code> must return the source array.</p><p>They should have <a href="#DimensionalData.Dimensions.LookupArrays.metadata"><code>metadata</code></a>, <a href="#DimensionalData.Dimensions.name"><code>name</code></a> and <a href="#DimensionalData.Dimensions.refdims"><code>refdims</code></a> methods, although these are optional.</p><p>A <a href="#DimensionalData.Dimensions.LookupArrays.rebuild"><code>rebuild</code></a> method for <code>AbstractDimArray</code> must accept <code>data</code>, <code>dims</code>, <code>refdims</code>, <code>name</code>, <code>metadata</code> arguments.</p><p>Indexing <code>AbstractDimArray</code> with non-range <code>AbstractArray</code> has undefined effects on the <code>Dimension</code> index. Use forward-ordered arrays only&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimArray" href="#DimensionalData.DimArray"><code>DimensionalData.DimArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimArray &lt;: AbstractDimArray

DimArray(data, dims, refdims, name, metadata)
DimArray(data, dims::Tuple; refdims=(), name=NoName(), metadata=NoMetadata())</code></pre><p>The main concrete subtype of <a href="#DimensionalData.AbstractDimArray"><code>AbstractDimArray</code></a>.</p><p><code>DimArray</code> maintains and updates its <code>Dimension</code>s through transformations and moves dimensions to reference dimension <code>refdims</code> after reducing operations (like e.g. <code>mean</code>).</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: An <code>AbstractArray</code>.</li><li><code>dims</code>: A <code>Tuple</code> of <code>Dimension</code></li><li><code>name</code>: A string name for the array. Shows in plots and tables.</li><li><code>refdims</code>: refence dimensions. Usually set programmatically to track past   slices and reductions of dimension for labelling and reconstruction.</li><li><code>metadata</code>: <code>Dict</code> or <code>Metadata</code> object, or <code>NoMetadata()</code></li></ul><p>Indexing can be done with all regular indices, or with <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>s and/or <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s. </p><p>Indexing <code>AbstractDimArray</code> with non-range <code>AbstractArray</code> has undefined effects on the <code>Dimension</code> index. Use forward-ordered arrays only&quot;</p><p>Example:</p><pre><code class="language-julia hljs">using Dates, DimensionalData

ti = (Ti(DateTime(2001):Month(1):DateTime(2001,12)),
x = X(10:10:100))
A = DimArray(rand(12,10), (ti, x), &quot;example&quot;)

julia&gt; A[X(Near([12, 35])), Ti(At(DateTime(2001,5)))];

julia&gt; A[Near(DateTime(2001, 5, 4)), Between(20, 50)];</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L210-L250">source</a></section></article><h2 id="Multi-array-datasets"><a class="docs-heading-anchor" href="#Multi-array-datasets">Multi-array datasets</a><a id="Multi-array-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-array-datasets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.AbstractDimStack" href="#DimensionalData.AbstractDimStack"><code>DimensionalData.AbstractDimStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDimStack</code></pre><p>Abstract supertype for dimensional stacks.</p><p>These have multiple layers of data, but share dimensions.</p><p>Notably, their behaviour lies somewhere between a <code>DimArray</code> and a <code>NamedTuple</code>:</p><ul><li>indexing with a <code>Symbol</code> as in <code>dimstack[:symbol]</code> returns a <code>DimArray</code> layer.</li><li>iteration amd <code>map</code> are apply over array layers, as indexed with a <code>Symbol</code>.</li><li><code>getindex</code> and many base methods are applied as for <code>DimArray</code> - to avoid the need    to allways use <code>map</code>.</li></ul><p>This design gives very succinct code when working with many-layered, mixed-dimension objects.  But it may be jarring initially - the most surprising outcome is that <code>dimstack[1]</code> will return a <code>NamedTuple</code> of values for the first index in all layers, while <code>first(dimstack)</code> will return the first value of the iterator - the <code>DimArray</code> for the first layer.</p><p>See <a href="#DimensionalData.DimStack"><code>DimStack</code></a> for the concrete implementation. Most methods are defined on the abstract type.</p><p>To extend <code>AbstractDimStack</code>, implement argument and keyword version of  <a href="#DimensionalData.Dimensions.LookupArrays.rebuild"><code>rebuild</code></a> and also <a href="#DimensionalData.rebuild_from_arrays"><code>rebuild_from_arrays</code></a>.</p><p>The constructor of an <code>AbstractDimStack</code> must accept a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/stack.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimStack" href="#DimensionalData.DimStack"><code>DimensionalData.DimStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimStack &lt;: AbstractDimStack

DimStack(data::AbstractDimArray...)
DimStack(data::Tuple{Vararg{&lt;:AbstractDimArray}})
DimStack(data::NamedTuple{Keys,Vararg{&lt;:AbstractDimArray}})
DimStack(data::NamedTuple, dims::DimTuple; metadata=NoMetadata())</code></pre><p>DimStack holds multiple objects sharing some dimensions, in a <code>NamedTuple</code>.</p><p>Notably, their behaviour lies somewhere between a <code>DimArray</code> and a <code>NamedTuple</code>:</p><ul><li>indexing with a <code>Symbol</code> as in <code>dimstack[:symbol]</code> returns a <code>DimArray</code> layer.</li><li>iteration amd <code>map</code> are apply over array layers, as indexed with a <code>Symbol</code>.</li><li><code>getindex</code> or <code>view</code> with <code>Int</code>, <code>Dimension</code>s or <code>Selector</code>s that resolve to <code>Int</code> will   return a <code>NamedTuple</code> of values from each layer in the stack.   This has very good performace, and avoids the need to always use <code>map</code>.</li><li><code>getindex</code> or <code>view</code> with a <code>Vector</code> or <code>Colon</code> will return another <code>DimStack</code> where   all data layers have been sliced.  </li><li><code>setindex!</code> must pass a <code>Tuple</code> or <code>NamedTuple</code> maching the layers.</li><li>many base and <code>Statistics</code> methods (<code>sum</code>, <code>mean</code> etc) will work as for a <code>DimArray</code>   again removing the need to use <code>map</code>.</li></ul><p>For example, here we take the mean over the time dimension for all layers :</p><pre><code class="language-julia hljs">mean(mydimstack; dims=Ti)</code></pre><p>And this equivalent to:</p><pre><code class="language-julia hljs">map(A -&gt; mean(A; dims=Ti), mydimstack)</code></pre><p>This design gives succinct code when working with many-layered, mixed-dimension objects. </p><p>But it may be jarring initially - the most surprising outcome is that <code>dimstack[1]</code> will return a <code>NamedTuple</code> of values for the first index in all layers, while <code>first(dimstack)</code> will return the first value of the iterator - the <code>DimArray</code> for the first layer.</p><p><code>DimStack</code> can be constructed from multiple <code>AbstractDimArray</code> or a <code>NamedTuple</code> of <code>AbstractArray</code> and a matching <code>dims</code> tuple.</p><p>Most <code>Base</code> and <code>Statistics</code> methods that apply to <code>AbstractArray</code> can be used on all layers of the stack simulataneously. The result is a <code>DimStack</code>, or a <code>NamedTuple</code> if methods like <code>mean</code> are used without <code>dims</code> arguments, and return a single non-array value.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData

julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0];

julia&gt; dimz = (X([:a, :b]), Y(10.0:10.0:30.0))
X Symbol[a, b],
Y 10.0:10.0:30.0

julia&gt; da1 = DimArray(1A, dimz; name=:one);

julia&gt; da2 = DimArray(2A, dimz; name=:two);

julia&gt; da3 = DimArray(3A, dimz; name=:three);

julia&gt; s = DimStack(da1, da2, da3);

julia&gt; s[At(:b), At(10.0)]
(one = 4.0, two = 8.0, three = 12.0)

julia&gt; s[X(At(:a))] isa DimStack
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/stack.jl#L152-L227">source</a></section></article><h2 id="Dimension-indices-generators"><a class="docs-heading-anchor" href="#Dimension-indices-generators">Dimension indices generators</a><a id="Dimension-indices-generators-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-indices-generators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimIndices" href="#DimensionalData.DimIndices"><code>DimensionalData.DimIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimIndices &lt;: AbstractArray

DimIndices(x)
DimIndices(dims::Tuple)
DimIndices(dims::Dimension)</code></pre><p>Like <code>CartesianIndices</code>, but for <code>Dimension</code>s. Behaves as an <code>Array</code> of <code>Tuple</code> of <code>Dimension(i)</code> for all combinations of the axis indices of <code>dims</code>.</p><p>This can be used to view/index into arbitrary dimensions over an array, and is especially useful when combined with <code>otherdims</code>, to iterate over the indices of unknown dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/dimindices.jl#L29-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimKeys" href="#DimensionalData.DimKeys"><code>DimensionalData.DimKeys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimKeys &lt;: AbstractArray

DimKeys(x)
DimKeys(dims::Tuple)
DimKeys(dims::Dimension)</code></pre><p>Like <code>CartesianIndices</code>, but for the lookup values of Dimensions. Behaves as an <code>Array</code> of <code>Tuple</code> of <code>Dimension(At(lookupvalue))</code> for all combinations of the lookup values of <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/dimindices.jl#L111-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimPoints" href="#DimensionalData.DimPoints"><code>DimensionalData.DimPoints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimPoints &lt;: AbstractArray

DimPoints(x; order)
DimPoints(dims::Tuple; order)
DimPoints(dims::Dimension; order)</code></pre><p>Like <code>CartesianIndices</code>, but for the point values of the dimension index.  Behaves as an <code>Array</code> of <code>Tuple</code> lookup values (whatever they are) for all combinations of the lookup values of <code>dims</code>.</p><p>Either a <code>Dimension</code>, a <code>Tuple</code> of <code>Dimension</code> or an object that defines a <code>dims</code> method can be passed in.</p><p><strong>Keywords</strong></p><ul><li><code>order</code>: determines the order of the points, the same as the order of <code>dims</code> by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/dimindices.jl#L70-L87">source</a></section></article><h2 id="Tables.jl/TableTraits.jl-interface"><a class="docs-heading-anchor" href="#Tables.jl/TableTraits.jl-interface">Tables.jl/TableTraits.jl interface</a><a id="Tables.jl/TableTraits.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.jl/TableTraits.jl-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.AbstractDimTable" href="#DimensionalData.AbstractDimTable"><code>DimensionalData.AbstractDimTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDimTable &lt;: Tables.AbstractColumns</code></pre><p>Abstract supertype for dim tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/tables.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimTable" href="#DimensionalData.DimTable"><code>DimensionalData.DimTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimTable &lt;: AbstractDimTable

DimTable(A::AbstractDimArray)</code></pre><p>Construct a Tables.jl/TableTraits.jl compatible object out of an <code>AbstractDimArray</code>.</p><p>This table will have a column for the array data and columns for each <code>Dimension</code> index, as a [<code>DimColumn</code>]. These are lazy, and generated as required.</p><p>Column names are converted from the dimension types using <a href="#DimensionalData.Dimensions.dim2key"><code>DimensionalData.dim2key</code></a>. This means type <code>Ti</code> becomes the column name <code>:Ti</code>, and <code>Dim{:custom}</code> becomes <code>:custom</code>.</p><p>To get dimension columns, you can index with <code>Dimension</code> (<code>X()</code>) or <code>Dimension</code> type (<code>X</code>) as well as the regular <code>Int</code> or <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/tables.jl#L117-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.DimColumn" href="#DimensionalData.DimColumn"><code>DimensionalData.DimColumn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimColumn{T,D&lt;:Dimension} &lt;: AbstractVector{T}

DimColumn(dim::Dimension, dims::Tuple{Vararg{&lt;:DimTuple}})
DimColumn(dim::DimColumn, length::Int, dimstride::Int)</code></pre><p>A table column based on a <code>Dimension</code> and it&#39;s relationship with other <code>Dimension</code>s in <code>dims</code>.</p><p><code>length</code> is the product of all dim lengths (usually the length of the corresponding array data), while stride is the product of the preceding dimension lengths, which may or may not be the real stride of the corresponding array depending on the data type. For <code>A isa Array</code>, the <code>dimstride</code> will match the <code>stride</code>.</p><p>When the second argument is a <code>Tuple</code> of <code>Dimension</code>, the <code>length</code> and <code>dimstride</code> fields are calculated from the dimensions, relative to the column dimension <code>dim</code>.</p><p>This object will be returned as a column of <a href="#DimensionalData.DimTable"><code>DimTable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/tables.jl#L23-L42">source</a></section></article><h2 id="Common-methods"><a class="docs-heading-anchor" href="#Common-methods">Common methods</a><a id="Common-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Common-methods" title="Permalink"></a></h2><p>Common functions for obtaining information from objects:</p><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dims" href="#DimensionalData.Dimensions.dims"><code>DimensionalData.Dimensions.dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dims(x, [dims::Tuple]) =&gt; Tuple{Vararg{&lt;:Dimension}}
dims(x, dim) =&gt; Dimension</code></pre><p>Return a tuple of <code>Dimension</code>s for an object, in the order that matches the axes or columns of the underlying data.</p><p><code>dims</code> can be <code>Dimension</code>, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p><p>The default is to return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.refdims" href="#DimensionalData.Dimensions.refdims"><code>DimensionalData.Dimensions.refdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refdims(x, [dims::Tuple]) =&gt; Tuple{Vararg{&lt;:Dimension}}
refdims(x, dim) =&gt; Dimension</code></pre><p>Reference dimensions for an array that is a slice or view of another array with more dimensions.</p><p><code>slicedims(a, dims)</code> returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty.</p><p>The default is to return an empty <code>Tuple</code> <code>()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L39-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.metadata" href="#DimensionalData.Dimensions.LookupArrays.metadata"><code>DimensionalData.Dimensions.LookupArrays.metadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">metadata(x) =&gt; (object metadata)
metadata(x, dims::Tuple)  =&gt; Tuple (Dimension metadata)
metadata(xs::Tuple) =&gt; Tuple</code></pre><p>Returns the metadata for an object or for the specified dimension(s)</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.name" href="#DimensionalData.Dimensions.name"><code>DimensionalData.Dimensions.name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">name(x) =&gt; String
name(xs:Tuple) =&gt; NTuple{N,String}
name(x, dims::Tuple) =&gt; NTuple{N,String}
name(x, dim) =&gt; String</code></pre><p>Get the name of an array or Dimension, or a tuple of of either.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L118-L128">source</a></section></article><p>Utility methods for transforming DimensionalData objects:</p><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.set" href="#DimensionalData.Dimensions.LookupArrays.set"><code>DimensionalData.Dimensions.LookupArrays.set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set(x, val)
set(x, args::Pairs...) =&gt; x with updated field/s
set(x, args...; kw...) =&gt; x with updated field/s
set(x, args::Tuple{Vararg{&lt;:Dimension}}; kw...) =&gt; x with updated field/s

set(dim::Dimension, index::AbstractArray) =&gt; Dimension
set(dim::Dimension, lookup::LookupArray) =&gt; Dimension
set(dim::Dimension, lookupcomponent::LookupArrayTrait) =&gt; Dimension
set(dim::Dimension, metadata::AbstractMetadata) =&gt; Dimension</code></pre><p>Set the properties of an object, its internal data or the traits of its dimensions and lookup index.</p><p>As DimensionalData is so strongly typed you do not need to specify what field of a <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> to <code>set</code> - there is no ambiguity.</p><p>To set fields of a <code>LookupArray</code> you need to specify the dimension. This can be done using <code>X =&gt; val</code> pairs, <code>X = val</code> keyword arguments, or <code>X(val)</code> wrapped arguments.</p><p>When a <code>Dimension</code> or <code>LookupArray</code> is passed to <code>set</code> to replace the existing ones, fields that are not set will keep their original values.</p><p><strong>Notes:</strong></p><p>Changing a lookup index range/vector will also update the step size and order where applicable.</p><p>Setting the <a href="#DimensionalData.Dimensions.LookupArrays.Order"><code>Order</code></a> like <code>ForwardOrdered</code> will <em>not</em> reverse the array or dimension to match. Use <code>reverse</code> and <a href="#DimensionalData.reorder"><code>reorder</code></a> to do this.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData; const DD = DimensionalData
DimensionalData

julia&gt; da = DimArray(zeros(3, 4), (custom=10.0:010.0:30.0, Z=-20:010.0:10.0));

julia&gt; set(da, ones(3, 4))
3×4 DimArray{Float64,2} with dimensions:
  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,
  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points
       -20.0  -10.0  0.0  10.0
 10.0    1.0    1.0  1.0   1.0
 20.0    1.0    1.0  1.0   1.0
 30.0    1.0    1.0  1.0   1.0 </code></pre><p>Change the <code>Dimension</code> wrapper type:</p><pre><code class="language-julia-repl hljs">julia&gt; set(da, :Z =&gt; Ti, :custom =&gt; Z)
3×4 DimArray{Float64,2} with dimensions:
  Z Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,
  Ti Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points
       -20.0  -10.0  0.0  10.0
 10.0    0.0    0.0  0.0   0.0
 20.0    0.0    0.0  0.0   0.0
 30.0    0.0    0.0  0.0   0.0 </code></pre><p>Change the lookup <code>Vector</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; set(da, Z =&gt; [:a, :b, :c, :d], :custom =&gt; [4, 5, 6])
3×4 DimArray{Float64,2} with dimensions:
  Dim{:custom} Sampled{Int64} Int64[4, 5, 6] ForwardOrdered Regular Points,
  Z Sampled{Symbol} Symbol[a, b, c, d] ForwardOrdered Regular Points
     :a   :b   :c   :d
 4  0.0  0.0  0.0  0.0
 5  0.0  0.0  0.0  0.0
 6  0.0  0.0  0.0  0.0</code></pre><p>Change the <code>LookupArray</code> type:</p><pre><code class="language-julia-repl hljs">julia&gt; set(da, Z=DD.NoLookup(), custom=DD.Sampled())
3×4 DimArray{Float64,2} with dimensions:
  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Regular Points,
  Z
 10.0  0.0  0.0  0.0  0.0
 20.0  0.0  0.0  0.0  0.0
 30.0  0.0  0.0  0.0  0.0</code></pre><p>Change the <code>Sampling</code> trait:</p><pre><code class="language-julia-repl hljs">julia&gt; set(da, :custom =&gt; DD.Irregular(10, 12), Z =&gt; DD.Regular(9.9))
3×4 DimArray{Float64,2} with dimensions:
  Dim{:custom} Sampled{Float64} 10.0:10.0:30.0 ForwardOrdered Irregular Points,
  Z Sampled{Float64} -20.0:10.0:10.0 ForwardOrdered Regular Points
       -20.0  -10.0  0.0  10.0
 10.0    0.0    0.0  0.0   0.0
 20.0    0.0    0.0  0.0   0.0
 30.0    0.0    0.0  0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/set.jl#L3-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.rebuild" href="#DimensionalData.Dimensions.LookupArrays.rebuild"><code>DimensionalData.Dimensions.LookupArrays.rebuild</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rebuild(x, args...)
rebuild(x; kw...)</code></pre><p>Rebuild an object struct with updated field values.</p><p><code>x</code> can be a <code>AbstractDimArray</code>, a <code>Dimension</code>, <code>LookupArray</code> or other custom types.</p><p>This is an abstraction that alows inbuilt and custom types to be rebuilt to update their fields, as most objects in DimensionalData.jl are immutable.</p><p>The arguments version can be concise but depends on a fixed order defined for some DimensionalData objects. It should be defined based on the object type in DimensionalData, adding the fields specific to your object.</p><p>The keyword version ignores order, and is mostly automated  using <code>ConstructionBase.setproperties</code>. It should only be defined if your object has  missing fields or fields with different names to DimensionalData objects.</p><p>The arguments required are defined for the abstract type that has a <code>rebuild</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.modify" href="#DimensionalData.modify"><code>DimensionalData.modify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify(f, A::AbstractDimArray) =&gt; AbstractDimArray
modify(f, s::AbstractDimStack) =&gt; AbstractDimStack
modify(f, dim::Dimension) =&gt; Dimension
modify(f, x, lookupdim::Dimension) =&gt; typeof(x)</code></pre><p>Modify the parent data, rebuilding the object wrapper without change. <code>f</code> must return a <code>AbstractArray</code> of the same size as the original.</p><p>This method is mostly useful as a way of swapping the parent array type of an object.</p><p><strong>Example</strong></p><p>If we have a previously-defined <code>DimArray</code>, we can copy it to an Nvidia GPU with:</p><pre><code class="language-julia hljs">A = DimArray(rand(100, 100), (X, Y))
modify(CuArray, A)</code></pre><p>This also works for all the data layers in a <code>DimStack</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/utils.jl#L37-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.broadcast_dims" href="#DimensionalData.broadcast_dims"><code>DimensionalData.broadcast_dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brodadcast_dims(f, sources::AbstractDimArray...) =&gt; AbstractDimArray</code></pre><p>Broadcast function <code>f</code> over the <code>AbstractDimArray</code>s in <code>sources</code>, permuting and reshaping dimensions to match where required. The result will contain all the dimensions in  all passed in arrays in the order in which they are found.</p><p><strong>Arguments</strong></p><ul><li><code>sources</code>: <code>AbstractDimArrays</code> to broadcast over with <code>f</code>.</li></ul><p>This is like broadcasting over every slice of <code>A</code> if it is sliced by the dimensions of <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/utils.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.broadcast_dims!" href="#DimensionalData.broadcast_dims!"><code>DimensionalData.broadcast_dims!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brodadcast_dims!(f, dest::AbstractDimArray, sources::AbstractDimArray...) =&gt; dest</code></pre><p>Broadcast function <code>f</code> over the <code>AbstractDimArray</code>s in <code>sources</code>, writing to <code>dest</code>.  <code>sources</code> are permuting and reshaping dimensions to match where required.</p><p>The result will contain all the dimensions in all passed in arrays, in the order in which they are found.</p><p><strong>Arguments</strong></p><ul><li><code>dest</code>: <code>AbstractDimArray</code> to update.</li><li><code>sources</code>: <code>AbstractDimArrays</code> to broadcast over with <code>f</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/utils.jl#L99-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.reorder" href="#DimensionalData.reorder"><code>DimensionalData.reorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reorder(A::AbstractDimArray, order::Pair) =&gt; AbstractDimArray
reorder(A::Dimension, order::Order) =&gt; AbstractDimArray</code></pre><p>Reorder every dims index/array to <code>order</code>, or reorder index for the the given dimension(s) to the <code>Order</code> they wrap.</p><p><code>order</code> can be an <a href="#DimensionalData.Dimensions.LookupArrays.Order"><code>Order</code></a>, or <code>Dimeension =&gt; Order</code> pairs.</p><p>If no axis reversal is required the same objects will be returned, without allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/utils.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.cat(stacks::AbstractDimStack...; [keys=keys(stacks[1])], dims)</code></pre><p>Concatenate all or a subset of layers for all passed in stacks.</p><p><strong>Keywords</strong></p><ul><li><code>keys</code>: <code>Tuple</code> of <code>Symbol</code> for the stack keys to concatenate.</li><li><code>dims</code>: Dimension of child array to concatenate on.</li></ul><p><strong>Example</strong></p><p>Concatenate the :sea<em>surface</em>temp and :humidity layers in the time dimension:</p><pre><code class="language-julia hljs">cat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/methods.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.map(f, stacks::AbstractDimStack...)</code></pre><p>Apply function <code>f</code> to each layer of the <code>stacks</code>.</p><p>If <code>f</code> returns <code>DimArray</code>s the result will be another <code>DimStack</code>. Other values will be returned in a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/methods.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.copy!(dst::AbstractArray, src::AbstractGimStack, key::Key)</code></pre><p>Copy the stack layer <code>key</code> to <code>dst</code>, which can be any <code>AbstractArray</code>.</p><p><strong>Example</strong></p><p>Copy the <code>:humidity</code> layer from <code>stack</code> to <code>array</code>.</p><pre><code class="language-julia hljs">copy!(array, stack, :humidity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/methods.jl#L3-L15">source</a></section><section><div><pre><code class="nohighlight hljs">Base.copy!(dst::AbstractDimStack, src::AbstractDimStack, [keys=keys(dst)])</code></pre><p>Copy all or a subset of layers from one stack to another.</p><p><strong>Example</strong></p><p>Copy just the <code>:sea_surface_temp</code> and <code>:humidity</code> layers from <code>src</code> to <code>dst</code>.</p><pre><code class="language-julia hljs">copy!(dst::AbstractDimStack, src::AbstractDimStack, keys=(:sea_surface_temp, :humidity))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/methods.jl#L18-L30">source</a></section></article><p>Most base methods work as expected, using <code>Dimension</code> wherever a <code>dims</code> keyword is used. They are not allspecifically documented here.</p><p>Shorthand constructors:</p><article class="docstring"><header><a class="docstring-binding" id="Base.fill" href="#Base.fill"><code>Base.fill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.fill(x, dims::Dimension...; kw...) =&gt; DimArray
Base.fill(x, dims::Tuple{Vararg{&lt;:Dimension}}; kw...) =&gt; DimArray</code></pre><p>Create a <a href="#DimensionalData.DimArray"><code>DimArray</code></a> with a fill value of <code>x</code>.</p><p>There are two kinds of <code>Dimension</code> value acepted:</p><ul><li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li><li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <a href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>NoLookup</code></a>.</li></ul><p>Keywords are the same as for <a href="#DimensionalData.DimArray"><code>DimArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; using DimensionalData

julia&gt; rand(Bool, X(2), Y(4))
2×4 DimArray{Bool,2} with dimensions: X, Y
 1  0  0  1
 1  0  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L300-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.rand(x, dims::Dimension...; kw...) =&gt; DimArray
Base.rand(x, dims::Tuple{Vararg{&lt;:Dimension}}; kw...) =&gt; DimArray
Base.rand(r::AbstractRNG, x, dims::Tuple{Vararg{&lt;:Dimension}}; kw...) =&gt; DimArray
Base.rand(r::AbstractRNG, x, dims::Dimension...; kw...) =&gt; DimArray</code></pre><p>Create a <a href="#DimensionalData.DimArray"><code>DimArray</code></a> of random values.</p><p>There are two kinds of <code>Dimension</code> value acepted:</p><ul><li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li><li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <a href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>NoLookup</code></a>.</li></ul><p>Keywords are the same as for <a href="#DimensionalData.DimArray"><code>DimArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DimensionalData

julia&gt; rand(Bool, X(2), Y(4))
2×4 DimArray{Bool,2} with dimensions: X, Y
 1  0  0  1
 1  0  1  1

julia&gt; rand(X([:a, :b, :c]), Y(100.0:50:200.0))
3×3 DimArray{Float64,2} with dimensions:
  X: Symbol[a, b, c] Categorical: Unordered,
  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points
 0.43204   0.835111  0.624231
 0.752868  0.471638  0.193652
 0.484558  0.846559  0.455256</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L326-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.zeros(x, dims::Dimension...; kw...) =&gt; DimArray
Base.zeros(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray</code></pre><p>Create a <a href="#DimensionalData.DimArray"><code>DimArray</code></a> of zeros.</p><p>There are two kinds of <code>Dimension</code> value acepted:</p><ul><li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li><li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <a href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>NoLookup</code></a>.</li></ul><p>Keywords are the same as for <a href="#DimensionalData.DimArray"><code>DimArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; using DimensionalData

julia&gt; zeros(Bool, X(2), Y(4))
2×4 DimArray{Bool,2} with dimensions: X, Y
 0  0  0  0
 0  0  0  0

julia&gt; zeros(X([:a, :b, :c]), Y(100.0:50:200.0))
3×3 DimArray{Float64,2} with dimensions:
  X: Symbol[a, b, c] Categorical: Unordered,
  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L362-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.ones(x, dims::Dimension...; kw...) =&gt; DimArray
Base.ones(x, dims::Tuple{Vararg{Dimension}}; kw...) =&gt; DimArray</code></pre><p>Create a <a href="#DimensionalData.DimArray"><code>DimArray</code></a> of ones.</p><p>There are two kinds of <code>Dimension</code> value acepted:</p><ul><li>A <code>Dimension</code> holding an <code>AbstractVector</code> will set the dimension index to  that <code>AbstractVector</code>, and detect the dimension lookup.</li><li>A <code>Dimension</code> holding an <code>Integer</code> will set the length of the axis, and set the dimension lookup to <a href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>NoLookup</code></a>.</li></ul><p>Keywords are the same as for <a href="#DimensionalData.DimArray"><code>DimArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; using DimensionalData

julia&gt; ones(Bool, X(2), Y(4))
2×4 DimArray{Bool,2} with dimensions: X, Y
 1  1  1  1
 1  1  1  1

julia&gt; ones(X([:a, :b, :c]), Y(100.0:50:200.0))
3×3 DimArray{Float64,2} with dimensions:
  X: Symbol[a, b, c] Categorical: Unordered,
  Y: 100.0:50.0:200.0 Sampled: Ordered Regular Points
 1.0  1.0  1.0
 1.0  1.0  1.0
 1.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/array/array.jl#L396-L427">source</a></section></article><h1 id="Dimensions"><a class="docs-heading-anchor" href="#Dimensions">Dimensions</a><a id="Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensions" title="Permalink"></a></h1><p>Handling of Dimensions is kept in a sub-module <code>Dimensions</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions" href="#DimensionalData.Dimensions"><code>DimensionalData.Dimensions</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Dimensions</p><p>Sub-module for <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>s wrappers, and operations on them used in DimensionalData.jl.</p><p>To load <code>Dimensions</code> types and methods into scope:</p><pre><code class="language-julia hljs">using DimensionalData
using .LookupArrays</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/Dimensions.jl#L1-L13">source</a></section></article><p>Dimensions have a type-heirarchy that organises plotting and dimension matching.</p><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Dimension" href="#DimensionalData.Dimensions.Dimension"><code>DimensionalData.Dimensions.Dimension</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dimension</code></pre><p>Abstract supertype of all dimension types.</p><p>Example concrete implementations are <a href="#DimensionalData.Dimensions.X"><code>X</code></a>, <a href="#DimensionalData.Dimensions.Y"><code>Y</code></a>, <a href="#DimensionalData.Dimensions.Z"><code>Z</code></a>, <a href="#DimensionalData.Dimensions.Ti"><code>Ti</code></a> (Time), and the custom [<code>Dim</code>]@ref) dimension.</p><p><code>Dimension</code>s label the axes of an <code>AbstractDimArray</code>, or other dimensional objects, and are used to index into the array.</p><p>They may also provide an alternate index to lookup for each array axis. This may be any <code>AbstractVector</code> matching the array axis length, or a <code>Val</code> holding a tuple for compile-time index lookups.</p><p><code>Dimension</code>s also have <code>lookup</code> and <code>metadata</code> fields.</p><p><code>lookup</code> gives more details about the dimension, such as that it is <a href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>Categorical</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Sampled"><code>Sampled</code></a> as <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> along some transect. DimensionalData will attempt to guess the lookup from the passed-in index value.</p><p>Example:</p><pre><code class="language-julia hljs">using DimensionalData, Dates

x = X(2:2:10)
y = Y([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
ti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))

A = DimArray(zeros(3, 5, 12), (y, x, ti))

# output

3×5×12 DimArray{Float64,3} with dimensions:
  Y Categorical{Char} Char[a, b, c] ForwardOrdered,
  X Sampled{Int64} 2:2:10 ForwardOrdered Regular Points,
  Ti Sampled{DateTime} DateTime(&quot;2021-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2021-12-01T00:00:00&quot;) ForwardOrdered Regular Points
[:, :, 1]
       2    4    6    8    10
  &#39;a&#39;  0.0  0.0  0.0  0.0   0.0
  &#39;b&#39;  0.0  0.0  0.0  0.0   0.0
  &#39;c&#39;  0.0  0.0  0.0  0.0   0.0
[and 11 more slices...]</code></pre><p>For simplicity, the same <code>Dimension</code> types are also used as wrappers in <code>getindex</code>, like:</p><pre><code class="language-julia hljs">x = A[X(2), Y(3)]

# output

12-element DimArray{Float64,1} with dimensions:
  Ti Sampled{DateTime} DateTime(&quot;2021-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2021-12-01T00:00:00&quot;) ForwardOrdered Regular Points
and reference dimensions:
  Y Categorical{Char} Char[c] ForwardOrdered,
  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points
 2021-01-01T00:00:00  0.0
 2021-02-01T00:00:00  0.0
 2021-03-01T00:00:00  0.0
 2021-04-01T00:00:00  0.0
 2021-05-01T00:00:00  0.0
 2021-06-01T00:00:00  0.0
 2021-07-01T00:00:00  0.0
 2021-08-01T00:00:00  0.0
 2021-09-01T00:00:00  0.0
 2021-10-01T00:00:00  0.0
 2021-11-01T00:00:00  0.0
 2021-12-01T00:00:00  0.0</code></pre><p>A <code>Dimension</code> can also wrap <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>.</p><pre><code class="language-julia hljs">x = A[X(Between(3, 4)), Y(At(&#39;b&#39;))]

# output

1×12 DimArray{Float64,2} with dimensions:
  X Sampled{Int64} 4:2:4 ForwardOrdered Regular Points,
  Ti Sampled{DateTime} DateTime(&quot;2021-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2021-12-01T00:00:00&quot;) ForwardOrdered Regular Points
and reference dimensions:
  Y Categorical{Char} Char[b] ForwardOrdered
     2021-01-01T00:00:00  …   2021-12-01T00:00:00
 4  0.0                                  0.0</code></pre><p><code>Dimension</code> objects may have <a href="#DimensionalData.Dimensions.lookup"><code>lookup</code></a> and <a href="#DimensionalData.Dimensions.LookupArrays.metadata"><code>metadata</code></a> fields to track additional information about the data and the index, and their relationship.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L1-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.DependentDim" href="#DimensionalData.Dimensions.DependentDim"><code>DimensionalData.Dimensions.DependentDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DependentDim &lt;: Dimension</code></pre><p>Abstract supertype for Dependent dimensions. These will plot on the Y axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.IndependentDim" href="#DimensionalData.Dimensions.IndependentDim"><code>DimensionalData.Dimensions.IndependentDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndependentDim &lt;: Dimension</code></pre><p>Abstract supertype for independent dimensions. Thise will plot on the X axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.XDim" href="#DimensionalData.Dimensions.XDim"><code>DimensionalData.Dimensions.XDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XDim &lt;: IndependentDim</code></pre><p>Abstract supertype for all X dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.YDim" href="#DimensionalData.Dimensions.YDim"><code>DimensionalData.Dimensions.YDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">YDim &lt;: DependentDim</code></pre><p>Abstract supertype for all Y dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.ZDim" href="#DimensionalData.Dimensions.ZDim"><code>DimensionalData.Dimensions.ZDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZDim &lt;: DependentDim</code></pre><p>Abstract supertype for all Z dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.TimeDim" href="#DimensionalData.Dimensions.TimeDim"><code>DimensionalData.Dimensions.TimeDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeDim &lt;: IndependentDim</code></pre><p>Abstract supertype for all time dimensions.</p><p>In a <code>TimeDime</code> with <code>Interval</code> sampling the locus will automatically be set to <code>Start()</code>. Dates and times generally refer to the start of a month, hour, second etc., not the central point as is more common with spatial data. `</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.X" href="#DimensionalData.Dimensions.X"><code>DimensionalData.Dimensions.X</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">X &lt;: XDim

X(val=:)</code></pre><p>X <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>. <code>X &lt;: XDim &lt;: IndependentDim</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">xdim = X(2:2:10)
# Or
val = A[X(1)]
# Or
mean(A; dims=X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L401-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Y" href="#DimensionalData.Dimensions.Y"><code>DimensionalData.Dimensions.Y</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Y &lt;: YDim

Y(val=:)</code></pre><p>Y <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>. <code>Y &lt;: YDim &lt;: DependentDim</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">ydim = Y([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
# Or
val = A[Y(1)]
# Or
mean(A; dims=Y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L419-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Z" href="#DimensionalData.Dimensions.Z"><code>DimensionalData.Dimensions.Z</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Z &lt;: ZDim

Z(val=:)</code></pre><p>Z <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>. <code>Z &lt;: ZDim &lt;: Dimension</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">zdim = Z(10:10:100)
# Or
val = A[Z(1)]
# Or
mean(A; dims=Z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L437-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Ti" href="#DimensionalData.Dimensions.Ti"><code>DimensionalData.Dimensions.Ti</code></a> — <span class="docstring-category">Type</span></header><section><div><p>m     Ti &lt;: TimeDim</p><pre><code class="nohighlight hljs">Ti(val=:)</code></pre><p>Time <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a>. <code>Ti &lt;: TimeDim &lt;: IndependentDim</code></p><p><code>Time</code> is already used by Dates, and <code>T</code> is a common type parameter, We use <code>Ti</code> to avoid clashes.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">timedim = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))
# Or
val = A[Ti(1)]
# Or
mean(A; dims=Ti)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L455-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Dim" href="#DimensionalData.Dimensions.Dim"><code>DimensionalData.Dimensions.Dim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dim{S}(val=:)</code></pre><p>A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.</p><p>Dimension types take precedence over same named <code>Dim</code> types when indexing with symbols, or e.g. creating Tables.jl keys.</p><pre><code class="language-julia hljs">using DimensionalData

dim = Dim{:custom}([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])

# output

Dim{:custom} Char[a, b, c]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L301-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.Coord" href="#DimensionalData.Dimensions.Coord"><code>DimensionalData.Dimensions.Coord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coord &lt;: Dimension</code></pre><p>A coordinate dimension itself holds dimensions.</p><p>This allows combining point data with other dimensions, such as time.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DimensionalData

julia&gt; dim = Coord([(1.0,1.0,1.0), (1.0,2.0,2.0), (3.0,4.0,4.0), (1.0,3.0,4.0)], (X(), Y(), Z()))
Coord ::
  val: Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0, 3.0,
4.0)]
  lookup: MergedLookup
Coord{Vector{Tuple{Float64, Float64, Float64}}, DimensionalData.MergedLookup{Tuple{X{Colon, AutoLookup{Auto
Order}, NoMetadata}, Y{Colon, AutoLookup{AutoOrder}, NoMetadata}, Z{Colon, AutoLookup{AutoOrder}, NoMetada
ta}}}, NoMetadata}

julia&gt; da = DimArray(0.1:0.1:0.4, dim)
4-element DimArray{Float64,1} with dimensions:
  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0), (1.0, 2.0, 2.0), (3.0, 4.0, 4.0), (1.0,
3.0, 4.0)]
    MergedLookup
 0.1
 0.2
 0.3
 0.4

julia&gt; da[Coord(Z(At(1.0)), Y(Between(1, 3)))]
1-element DimArray{Float64,1} with dimensions:
  Coord (): Tuple{Float64, Float64, Float64}[(1.0, 1.0, 1.0)] MergedLookup
 0.1

julia&gt; da[Coord(4)] == 0.4
true

julia&gt; da[Coord(Between(1, 5), :, At(4.0))]
2-element DimArray{Float64,1} with dimensions:
  Coord (): Tuple{Float64, Float64, Float64}[(3.0, 4.0, 4.0), (1.0, 3.0, 4.0)] MergedLookup
 0.3
 0.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/merged.jl#L97-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.AnonDim" href="#DimensionalData.Dimensions.AnonDim"><code>DimensionalData.Dimensions.AnonDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnonDim &lt;: Dimension

AnonDim()</code></pre><p>Anonymous dimension. Used when extra dimensions are created, such as during transpose of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.@dim" href="#DimensionalData.Dimensions.@dim"><code>DimensionalData.Dimensions.@dim</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@dim typ [supertype=Dimension] [name::String=string(typ)]</code></pre><p>Macro to easily define new dimensions. The supertype will be inserted into the type of the dim. The default is simply <code>YourDim &lt;: Dimension</code>. Making a Dimesion inherit from <code>XDim</code>, <code>YDim</code>, <code>ZDim</code> or <code>TimeDim</code> will affect automatic plot layout and other methods that dispatch on these types. <code>&lt;: YDim</code> are plotted on the Y axis, <code>&lt;: XDim</code> on the X axis, etc.</p><p>Example:</p><pre><code class="language-julia hljs">using DimensionalData
using DimensionalData: @dim, YDim, XDim
@dim Lat YDim &quot;latitude&quot;
@dim Lon XDim &quot;Longitude&quot;
# output
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/dimension.jl#L355-L373">source</a></section></article><h3 id="Exported-methopds"><a class="docs-heading-anchor" href="#Exported-methopds">Exported methopds</a><a id="Exported-methopds-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methopds" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.hasdim" href="#DimensionalData.Dimensions.hasdim"><code>DimensionalData.Dimensions.hasdim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasdim([f], x, query::Tuple) =&gt; NTUple{Bool}
hasdim([f], x, query...) =&gt; NTUple{Bool}
hasdim([f], x, query) =&gt; Bool</code></pre><p>Check if an object <code>x</code> has dimensions that match or inherit from the <code>query</code> dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li><li><code>query</code>: Tuple or single <code>Dimension</code> or dimension <code>Type</code>.</li><li><code>f</code>: <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</li></ul><p>Check if an object or tuple contains an <code>Dimension</code>, or a tuple of dimensions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData

julia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));

julia&gt; hasdim(A, X)
true

julia&gt; hasdim(A, (Z, X, Y))
(true, true, true)

julia&gt; hasdim(A, Ti)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L215-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dimnum" href="#DimensionalData.Dimensions.dimnum"><code>DimensionalData.Dimensions.dimnum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimnum(x, query::Tuple) =&gt; NTuple{Int}
dimnum(x, query) =&gt; Int</code></pre><p>Get the number(s) of <code>Dimension</code>(s) as ordered in the dimensions of an object.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li><li><code>query</code>: Tuple, Array or single <code>Dimension</code> or dimension <code>Type</code>.</li></ul><p>The return type will be a Tuple of <code>Int</code> or a single <code>Int</code>, depending on wether <code>query</code> is a <code>Tuple</code> or single <code>Dimension</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData

julia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));

julia&gt; dimnum(A, (Z, X, Y))
(3, 1, 2)

julia&gt; dimnum(A, Y)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L173-L199">source</a></section></article><h3 id="Non-exported-methods"><a class="docs-heading-anchor" href="#Non-exported-methods">Non-exported methods</a><a id="Non-exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Non-exported-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.lookup" href="#DimensionalData.Dimensions.lookup"><code>DimensionalData.Dimensions.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(x::Dimension) =&gt; LookupArray
lookup(x, [dims::Tuple]) =&gt; Tuple{Vararg{&lt;:LookupArray}}
lookup(x::Tuple) =&gt; Tuple{Vararg{&lt;:LookupArray}}
lookup(x, dim) =&gt; LookupArray</code></pre><p>Returns the <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> of a dimension. This dictates properties of the dimension such as array axis and index order, and sampling properties.</p><p><code>dims</code> can be a <code>Dimension</code>, a dimension type, or a tuple of either.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.label" href="#DimensionalData.Dimensions.label"><code>DimensionalData.Dimensions.label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">label(x) =&gt; String
label(x, dims::Tuple) =&gt; NTuple{N,String}
label(x, dim) =&gt; String
label(xs::Tuple) =&gt; NTuple{N,String}</code></pre><p>Get a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dim2key" href="#DimensionalData.Dimensions.dim2key"><code>DimensionalData.Dimensions.dim2key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dim2key(dim::Dimension) =&gt; Symbol
dim2key(dims::Type{&lt;:Dimension}) =&gt; Symbol
dim2key(dims::Tuple) =&gt; Tuple{Symbol,Vararg}</code></pre><p>Convert a dimension object to a simbol. <code>X()</code>, <code>Y()</code>, <code>Ti()</code> etc will be converted. to <code>:X</code>, <code>:Y</code>, <code>:Ti</code>, as with any other dims generated with the <a href="#DimensionalData.Dimensions.@dim"><code>@dim</code></a> macro.</p><p>All other <code>Dim{S}()</code> dimensions will generate <code>Symbol</code>s <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.key2dim" href="#DimensionalData.Dimensions.key2dim"><code>DimensionalData.Dimensions.key2dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key2dim(s::Symbol) =&gt; Dimension
key2dim(dims...) =&gt; Tuple{Dimension,Vararg}
key2dim(dims::Tuple) =&gt; Tuple{Dimension,Vararg}</code></pre><p>Convert a symbol to a dimension object. <code>:X</code>, <code>:Y</code>, <code>:Ti</code> etc will be converted. to <code>X()</code>, <code>Y()</code>, <code>Ti()</code>, as with any other dims generated with the <a href="#DimensionalData.Dimensions.@dim"><code>@dim</code></a> macro.</p><p>All other <code>Symbol</code>s <code>S</code> will generate <code>Dim{S}()</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dims2indices" href="#DimensionalData.Dimensions.dims2indices"><code>DimensionalData.Dimensions.dims2indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dims2indices(dim::Dimension, I) =&gt; NTuple{Union{Colon,AbstractArray,Int}}</code></pre><p>Convert a <code>Dimension</code> or <code>Selector</code> <code>I</code> to indices of <code>Int</code>, <code>AbstractArray</code> or <code>Colon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/indexing.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.selectindices" href="#DimensionalData.Dimensions.LookupArrays.selectindices"><code>DimensionalData.Dimensions.LookupArrays.selectindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selectindices(lookups, selectors)</code></pre><p>Converts <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a> to regular indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L887-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.format" href="#DimensionalData.Dimensions.format"><code>DimensionalData.Dimensions.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">format(dims, x) =&gt; Tuple{Vararg{&lt;:Dimension,N}}</code></pre><p>Format the passed-in dimension(s) <code>dims</code> to match the object <code>x</code>.</p><p>Errors are thrown if dims don&#39;t match the array dims or size,  and any fields holding <code>Auto-</code> objects are filled with guessed objects.</p><p>If a <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> hasn&#39;t been specified, a lookup is chosen based on the type and element type of the index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/format.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.reducedims" href="#DimensionalData.Dimensions.reducedims"><code>DimensionalData.Dimensions.reducedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reducedims(x, dimstoreduce) =&gt; Tuple{Vararg{&lt;:Dimension}}</code></pre><p>Replace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like <code>mean</code> or <code>reduce</code> to a length of 1, but the number of dimensions has not changed.</p><p><code>LookupArray</code> traits are also updated to correspond to the change in cell step, sampling type and order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L440-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.swapdims" href="#DimensionalData.Dimensions.swapdims"><code>DimensionalData.Dimensions.swapdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swapdims(x::T, newdims) =&gt; T
swapdims(dims::Tuple, newdims) =&gt; Tuple{Vararg{&lt;:Dimension}}</code></pre><p>Swap dimensions for the passed in dimensions, in the order passed.</p><p>Passing in the <code>Dimension</code> types rewraps the dimension index, keeping the index values and metadata, while constructed <code>Dimension</code> objectes replace the original dimension. <code>nothing</code> leaves the original dimension as-is.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: any object with a <code>dims</code> method or a <code>Tuple</code> of <code>Dimension</code>.</li><li><code>newdim</code>: Tuple of <code>Dimension</code> or dimension <code>Type</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData
A = ones(X(2), Y(4), Z(2))
Dimensions.swapdims(A, (Dim{:a}, Dim{:b}, Dim{:c}))

# output
2×4×2 DimArray{Float64,3} with dimensions: Dim{:a}, Dim{:b}, Dim{:c}
[:, :, 1]
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
[and 1 more slices...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L323-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.slicedims" href="#DimensionalData.Dimensions.slicedims"><code>DimensionalData.Dimensions.slicedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">slicedims(x, I) =&gt; Tuple{Tuple,Tuple}
slicedims(f, x, I) =&gt; Tuple{Tuple,Tuple}</code></pre><p>Slice the dimensions to match the axis values of the new array.</p><p>All methods return a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.</p><p>Called at the array level the returned tuple will also include the previous reference dims attached to the array.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: a function <code>getindex</code>,  <code>view</code> or <code>dotview</code>. This will be used for slicing   <code>getindex</code> is the default if <code>f</code> is not included.</li><li><code>x</code>: An <code>AbstractDimArray</code>, <code>Tuple</code> of <code>Dimension</code>, or <code>Dimension</code></li><li><code>I</code>: A tuple of <code>Integer</code>, <code>Colon</code> or <code>AbstractArray</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L365-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.comparedims" href="#DimensionalData.Dimensions.comparedims"><code>DimensionalData.Dimensions.comparedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">comparedims(A::AbstractDimArray...; kw...)
comparedims(A::Tuple...; kw...)
comparedims(a, b; kw...)</code></pre><p>Check that dimensions or tuples of dimensions are the same, and return the first valid dimension. If <code>AbstractDimArray</code>s are passed as arguments their dimensions are compared.</p><p>Empty tuples and <code>nothing</code> dimension values are ignored, returning the <code>Dimension</code> value if it exists.</p><p><strong>Keywords</strong></p><p>These are all <code>Bool</code> flags:</p><ul><li><code>type</code>: compare complete type, <code>true</code> by default.</li><li><code>lookuptype</code>: compare wrapped <code>LookupArray</code> type, <code>false</code> by default. </li><li><code>length</code>: compare lengths, <code>true</code> by default.</li><li><code>ignore_length_one</code>: ignore length <code>1</code> in comparisons, and return whichever   dimension is not length 1, if any. This is useful in e.g. broadcasting comparisons.   <code>false</code> by default.</li><li><code>value</code>: compare all values in each <code>LookupArray</code> are identical, <code>false</code> by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L466-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.combinedims" href="#DimensionalData.Dimensions.combinedims"><code>DimensionalData.Dimensions.combinedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combinedims(xs; check=true)</code></pre><p>Combine the dimensions of each object in <code>xs</code>, in the order they are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L521-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.otherdims" href="#DimensionalData.Dimensions.otherdims"><code>DimensionalData.Dimensions.otherdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">otherdims(x, query) =&gt; Tuple{Vararg{&lt;:Dimension,N}}</code></pre><p>Get the dimensions of an object <em>not</em> in <code>query</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code>.</li><li><code>query</code>: Tuple or single <code>Dimension</code> or dimension <code>Type</code>.</li><li><code>f</code>: <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</li></ul><p>A tuple holding the unmatched dimensions is always returned.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData, DimensionalData.Dimensions

julia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));

julia&gt; otherdims(A, X)
Y, Z

julia&gt; otherdims(A, (Y, Z))
X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L253-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.commondims" href="#DimensionalData.Dimensions.commondims"><code>DimensionalData.Dimensions.commondims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commondims([f], x, query) =&gt; Tuple{Vararg{&lt;:Dimension}}</code></pre><p>This is basically <code>dims(x, query)</code> where the order of the original is kept, unlike <a href="#DimensionalData.Dimensions.dims"><code>dims</code></a> where the query tuple determines the order</p><p>Also unlike <code>dims</code>,<code>commondims</code> always returns a <code>Tuple</code>, no matter the input. No errors are thrown if dims are absent from either <code>x</code> or <code>query</code>.</p><p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to sort abstract types by concrete types.</p><pre><code class="language-julia-repl hljs">julia&gt; using DimensionalData, .Dimensions

julia&gt; A = DimArray(ones(10, 10, 10), (X, Y, Z));

julia&gt; commondims(A, X)
X

julia&gt; commondims(A, (X, Z))
X, Z

julia&gt; commondims(A, Ti)
()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L142-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.sortdims" href="#DimensionalData.Dimensions.sortdims"><code>DimensionalData.Dimensions.sortdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortdims([f], tosort, order) =&gt; Tuple</code></pre><p>Sort dimensions <code>tosort</code> by <code>order</code>. Dimensions in <code>order</code> but missing from <code>tosort</code> are replaced with <code>nothing</code>.</p><p><code>tosort</code> and <code>order</code> can be <code>Tuple</code>s or <code>Vector</code>s or Dimension or dimension type. Abstract supertypes like <a href="#DimensionalData.Dimensions.TimeDim"><code>TimeDim</code></a> can be used in <code>order</code>.</p><p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to sort abstract types by concrete types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L68-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.basetypeof" href="#DimensionalData.Dimensions.LookupArrays.basetypeof"><code>DimensionalData.Dimensions.LookupArrays.basetypeof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basetypeof(x) =&gt; Type</code></pre><p>Get the &quot;base&quot; type of an object - the minimum required to define the object without it&#39;s fields. By default this is the full <code>UnionAll</code> for the type. But custom <code>basetypeof</code> methods can be defined for types with free type parameters.</p><p>In DimensionalData this is primariliy used for comparing <code>Dimension</code>s, where <code>Dim{:x}</code> is different from <code>Dim{:y}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/utils.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.setdims" href="#DimensionalData.Dimensions.setdims"><code>DimensionalData.Dimensions.setdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdims(X, newdims) =&gt; AbstractArray
setdims(::Tuple, newdims) =&gt; Tuple{Vararg{&lt;:Dimension,N}}</code></pre><p>Replaces the first dim matching <code>&lt;: basetypeof(newdim)</code> with newdim, and returns a new object or tuple with the dimension updated.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: any object with a <code>dims</code> method, a <code>Tuple</code> of <code>Dimension</code> or a single <code>Dimension</code>.</li><li><code>newdim</code>: Tuple or single <code>Dimension</code>, <code>Type</code> or <code>Symbol</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData, DimensionalData.Dimensions, DimensionalData.LookupArrays
A = ones(X(10), Y(10:10:100))
B = setdims(A, Y(Categorical(&#39;a&#39;:&#39;j&#39;; order=ForwardOrdered())))
lookup(B, Y)
# output
Categorical{Char} ForwardOrdered
wrapping: &#39;a&#39;:1:&#39;j&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L293-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dimsmatch" href="#DimensionalData.Dimensions.dimsmatch"><code>DimensionalData.Dimensions.dimsmatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimsmatch([f], dim, query) =&gt; Bool
dimsmatch([f], dims::Tuple, query::Tuple) =&gt; Bool</code></pre><p>Compare 2 dimensions or <code>Tuple</code> of <code>Dimension</code> are of the same base type, or are at least rotations/transformations of the same type.</p><p><code>f</code> is <code>&lt;:</code> by default, but can be <code>&gt;:</code> to match abstract types to concrete types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.dimstride" href="#DimensionalData.Dimensions.dimstride"><code>DimensionalData.Dimensions.dimstride</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimstride(x, dim) =&gt; Int</code></pre><p>Get the stride of the dimension relative to the other dimensions.</p><p>This may or may not be equal to the stride of the related array, although it will be for <code>Array</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code> is any object with a <code>dims</code> method, or a <code>Tuple</code> of <code>Dimension</code>.</li><li><code>dim</code> is a <code>Dimension</code>, <code>Dimension</code> type, or and <code>Int</code>. Using an <code>Int</code> is not type-stable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/primitives.jl#L544-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.refdims_title" href="#DimensionalData.refdims_title"><code>DimensionalData.refdims_title</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refdims_title(A::AbstractDimArray)
refdims_title(refdims::Tuple)
refdims_title(refdim::Dimension)</code></pre><p>Generate a title string based on reference dimension values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/plotrecipes.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.rebuild_from_arrays" href="#DimensionalData.rebuild_from_arrays"><code>DimensionalData.rebuild_from_arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rebuild_from_arrays(s::AbstractDimStack, das::NamedTuple{&lt;:Any,&lt;:Tuple{Vararg{&lt;:AbstractDimArray}}}; kw...)</code></pre><p>Rebuild an <code>AbstractDimStack</code> from a <code>NamedTuple</code> of <code>AbstractDimArray</code> and an existing stack.</p><p><strong>Keywords</strong></p><p>Keywords are simply the fields of the stack object:</p><ul><li><code>data</code></li><li><code>dims</code></li><li><code>refdims</code></li><li><code>metadata</code></li><li><code>layerdims</code></li><li><code>layermetadata</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/stack/stack.jl#L106-L122">source</a></section></article><h1 id="LookupArrays"><a class="docs-heading-anchor" href="#LookupArrays">LookupArrays</a><a id="LookupArrays-1"></a><a class="docs-heading-anchor-permalink" href="#LookupArrays" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays" href="#DimensionalData.Dimensions.LookupArrays"><code>DimensionalData.Dimensions.LookupArrays</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">LookupArrays</code></pre><p>Module for <a href="#DimensionalData.Dimensions.LookupArrays"><code>LookupArrays</code></a> and [<code>Selector</code>]s used in DimensionalData.jl</p><p><code>LookupArrays</code> defines traits and <code>AbstractArray</code> wrappers that give specific behaviours for a lookup index when indexed with <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>.</p><p>For example, these allow tracking over array order so fast indexing works evne when  the array is reversed.</p><p>To load LookupArrays types and methods into scope:</p><pre><code class="language-julia hljs">using DimensionalData
using .LookupArrays</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/LookupArrays.jl#L1-L18">source</a></section></article><h2 id="Selectors"><a class="docs-heading-anchor" href="#Selectors">Selectors</a><a id="Selectors-1"></a><a class="docs-heading-anchor-permalink" href="#Selectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Selector" href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>DimensionalData.Dimensions.LookupArrays.Selector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Selector</code></pre><p>Abstract supertype for all selectors.</p><p>Selectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as <code>DateTime</code> objects for a <code>Ti</code> dimension.</p><p>Selectors provided in DimensionalData are:</p><ul><li><a href="#DimensionalData.Dimensions.LookupArrays.At"><code>At</code></a></li><li><a href="#DimensionalData.Dimensions.LookupArrays.Between"><code>Between</code></a></li><li><a href="#DimensionalData.Dimensions.LookupArrays.Touches"><code>Touches</code></a></li><li><a href="#DimensionalData.Dimensions.LookupArrays.Near"><code>Near</code></a></li><li><a href="#DimensionalData.Dimensions.LookupArrays.Where"><code>Where</code></a></li><li><a href="#DimensionalData.Dimensions.LookupArrays.Contains"><code>Contains</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.IntSelector" href="#DimensionalData.Dimensions.LookupArrays.IntSelector"><code>DimensionalData.Dimensions.LookupArrays.IntSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntSelector &lt;: Selector</code></pre><p>Abstract supertype for <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s that return a single <code>Int</code> index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.ArraySelector" href="#DimensionalData.Dimensions.LookupArrays.ArraySelector"><code>DimensionalData.Dimensions.LookupArrays.ArraySelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArraySelector &lt;: Selector</code></pre><p>Abstract supertype for <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s that return an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.At" href="#DimensionalData.Dimensions.LookupArrays.At"><code>DimensionalData.Dimensions.LookupArrays.At</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">At &lt;: IntSelector

At(x, atol, rtol)
At(x; atol=nothing, rtol=nothing)</code></pre><p>Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.</p><p><code>x</code> can be any value or <code>Vector</code> of values.</p><p><code>atol</code> and <code>rtol</code> are passed to <code>isapprox</code>. For <code>Number</code> <code>rtol</code> will be set to <code>Base.rtoldefault</code>, otherwise <code>nothing</code>, and wont be used.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))
A[X(At(20)), Y(At(6))]

# output

5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L45-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Near" href="#DimensionalData.Dimensions.LookupArrays.Near"><code>DimensionalData.Dimensions.LookupArrays.Near</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Near &lt;: IntSelector

Near(x)</code></pre><p>Selector that selects the nearest index to <code>x</code>.</p><p>With <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> this is simply the index values nearest to the <code>x</code>, however with <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> it is the interval <em>center</em> nearest to <code>x</code>. This will be offset from the index value for <code>Start</code> and <a href="#DimensionalData.Dimensions.LookupArrays.End"><code>End</code></a> loci.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))
A[X(Near(23)), Y(Near(5.1))]

# output
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L151-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Between" href="#DimensionalData.Dimensions.LookupArrays.Between"><code>DimensionalData.Dimensions.LookupArrays.Between</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Between &lt;: ArraySelector

Between(a, b)</code></pre><p>Depreciated: use <code>a..b</code> instead of <code>Between(a, b)</code>. Other <code>Interval</code> objects from IntervalSets.jl, like `OpenInterval(a, b) will also work, giving the correct open/closed boundaries.</p><p><code>Between</code> will e removed in furture to avoid clashes with <code>DataFrames.Between</code>.</p><p>Selector that retreive all indices located between 2 values, evaluated with <code>&gt;=</code> for the lower value, and <code>&lt;</code> for the upper value. This means the same value will not be counted twice in 2 adjacent <code>Between</code> selections.</p><p>For <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> the whole interval must be lie between the values. For <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> the points must fall between the values. Different <a href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>Sampling</code></a> types may give different results with the same input - this is the intended behaviour.</p><p><code>Between</code> for <a href="#DimensionalData.Dimensions.LookupArrays.Irregular"><code>Irregular</code></a> intervals is a little complicated. The interval is the distance between a value and the next (for <code>Start</code> locus) or previous (for <a href="#DimensionalData.Dimensions.LookupArrays.End"><code>End</code></a> locus) value.</p><p>For <a href="#DimensionalData.Dimensions.LookupArrays.Center"><code>Center</code></a>, we take the mid point between two index values as the start and end of each interval. This may or may not make sense for the values in your indes, so use <code>Between</code> with <code>Irregular</code> <code>Intervals(Center())</code> with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))
A[X(Between(15, 25)), Y(Between(4, 6.5))]

# output

1×2 DimArray{Int64,2} with dimensions:
  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,
  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points
     5  6
 20  4  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L363-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Touches" href="#DimensionalData.Dimensions.LookupArrays.Touches"><code>DimensionalData.Dimensions.LookupArrays.Touches</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Touches &lt;: ArraySelector

Touches(a, b)</code></pre><p>Selector that retreives all indices touching the closed interval 2 values, for the maximum possible area that could interact with the supplied range.</p><p>This can be better than <code>..</code> when e.g. subsetting an area to rasterize, as you may wish to include pixels that just touch the area, rather than those that fall within it.</p><p>Touches is different to using closed intervals when the lookups also contain intervals - if any of the intervals touch, they are included. With <code>..</code> they are discarded unless the whole cell interval falls inside the selector interval.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))
A[X(Touches(15, 25)), Y(Touches(4, 6.5))]

# output
1×2 DimArray{Int64,2} with dimensions:
  X Sampled{Int64} 20:10:20 ForwardOrdered Regular Points,
  Y Sampled{Int64} 5:6 ForwardOrdered Regular Points
     5  6
 20  4  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L630-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Contains" href="#DimensionalData.Dimensions.LookupArrays.Contains"><code>DimensionalData.Dimensions.LookupArrays.Contains</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Contains &lt;: IntSelector

Contains(x)</code></pre><p>Selector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.</p><p>Can only be used for <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>Categorical</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData; const DD = DimensionalData
dims_ = X(10:10:20; sampling=DD.Intervals(DD.Center())),
        Y(5:7; sampling=DD.Intervals(DD.Center()))
A = DimArray([1 2 3; 4 5 6], dims_)
A[X(Contains(8)), Y(Contains(6.8))]

# output
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L229-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Where" href="#DimensionalData.Dimensions.LookupArrays.Where"><code>DimensionalData.Dimensions.LookupArrays.Where</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Where &lt;: ArraySelector

Where(f::Function)</code></pre><p>Selector that filters a dimension lookup by any function that accepts a single value and returns a <code>Bool</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(19:21)))
A[X(Where(x -&gt; x &gt; 15)), Y(Where(x -&gt; x in (19, 21)))]

# output

1×2 DimArray{Int64,2} with dimensions:
  X Sampled{Int64} Int64[20] ForwardOrdered Regular Points,
  Y Sampled{Int64} Int64[19, 21] ForwardOrdered Regular Points
     19  21
 20   4   6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L811-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.All" href="#DimensionalData.Dimensions.LookupArrays.All"><code>DimensionalData.Dimensions.LookupArrays.All</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">All &lt;: Selector

All(selectors::Selector...)</code></pre><p>Selector that combines the results of other selectors.  The indices used will be the union of all result sorted in ascending order.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData, Unitful

dimz = X(10.0:20:200.0), Ti(1u&quot;s&quot;:5u&quot;s&quot;:100u&quot;s&quot;)
A = DimArray((1:10) * (1:20)&#39;, dimz)
A[X=All(At(10.0), At(50.0)), Ti=All(1u&quot;s&quot;..10u&quot;s&quot;, 90u&quot;s&quot;..100u&quot;s&quot;)]

# output

2×4 DimArray{Int64,2} with dimensions:
  X Sampled{Float64} Float64[10.0, 50.0] ForwardOrdered Regular Points,
  Ti Sampled{Quantity{Int64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}} Quantity{Int64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}[1 s, 6 s, 91 s, 96 s] ForwardOrdered Regular Points
       1 s  6 s  91 s  96 s
 10.0    1    2    19    20
 50.0    3    6    57    60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/selector.jl#L847-L873">source</a></section></article><p>Lookup properties:</p><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.bounds" href="#DimensionalData.Dimensions.LookupArrays.bounds"><code>DimensionalData.Dimensions.LookupArrays.bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounds(xs, [dims::Tuple]) =&gt; Tuple{Vararg{&lt;:Tuple{T,T}}}
bounds(xs::Tuple) =&gt; Tuple{Vararg{&lt;:Tuple{T,T}}}
bounds(x, dim) =&gt; Tuple{T,T}
bounds(dim::Union{Dimension,LookupArray}) =&gt; Tuple{T,T}</code></pre><p>Return the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.</p><p><code>dims</code> can be a <code>Dimension</code>, a dimension type, or a tuple of either.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L162-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.val" href="#DimensionalData.Dimensions.LookupArrays.val"><code>DimensionalData.Dimensions.LookupArrays.val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">val(x)
val(dims::Tuple) =&gt; Tuple</code></pre><p>Return the contained value of a wrapper object.</p><p><code>dims</code> can be <code>Dimension</code>, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p><p>Objects that don&#39;t define a <code>val</code> method are returned unaltered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.LookupArray" href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>DimensionalData.Dimensions.LookupArrays.LookupArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LookupArray</code></pre><p>Types defining the behaviour of a lookup index, how it is plotted and how <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s like <a href="#DimensionalData.Dimensions.LookupArrays.Between"><code>Between</code></a> work.</p><p>A <code>LookupArray</code> may be <a href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>NoLookup</code></a> indicating that the index is just the underlying array axis, <a href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>Categorical</code></a> for ordered or unordered categories,  or a <a href="#DimensionalData.Dimensions.LookupArrays.Sampled"><code>Sampled</code></a> index for <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Aligned" href="#DimensionalData.Dimensions.LookupArrays.Aligned"><code>DimensionalData.Dimensions.LookupArrays.Aligned</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Aligned &lt;: LookupArray</code></pre><p>Abstract supertype for <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>s where the index is aligned with the array axes.</p><p>This is by far the most common supertype for <code>LookupArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AbstractSampled" href="#DimensionalData.Dimensions.LookupArrays.AbstractSampled"><code>DimensionalData.Dimensions.LookupArrays.AbstractSampled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSampled &lt;: Aligned</code></pre><p>Abstract supertype for <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>s where the index is aligned with the array, and is independent of other dimensions. <a href="#DimensionalData.Dimensions.LookupArrays.Sampled"><code>Sampled</code></a> is provided by this package.</p><p><code>AbstractSampled</code> must have  <code>order</code>, <code>span</code> and <code>sampling</code> fields, or a <code>rebuild</code> method that accpts them as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L152-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Sampled" href="#DimensionalData.Dimensions.LookupArrays.Sampled"><code>DimensionalData.Dimensions.LookupArrays.Sampled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sampled &lt;: AbstractSampled

Sampled(data::AbstractVector, order::Order, span::Span, sampling::Sampling, metadata)
Sampled(; data=AutoIndex(), order=AutoOrder(), span=AutoSpan(), sampling=Points(), metadata=NoMetadata())</code></pre><p>A concrete implementation of the <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> <a href="#DimensionalData.Dimensions.LookupArrays.AbstractSampled"><code>AbstractSampled</code></a>. It can be used to represent <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a>.</p><p><code>Sampled</code> is capable of representing gridded data from a wide range of sources, allowing correct <code>bounds</code> and <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s for points or intervals of regular, irregular, forward and reverse indexes.</p><p>On <code>AbstractDimArray</code> construction, <code>Sampled</code> lookup is assigned for all lookups of  <code>AbstractRange</code> not assigned to <a href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>Categorical</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: An <code>AbstractVector</code> of index values, matching the length of the curresponding   array axis. </li><li><code>order</code>: <a href="#DimensionalData.Dimensions.LookupArrays.Order"><code>Order</code></a>) indicating the order of the index,   <a href="#DimensionalData.Dimensions.LookupArrays.AutoOrder"><code>AutoOrder</code></a> by default, detected from the order of <code>data</code>   to be <a href="#DimensionalData.Dimensions.LookupArrays.ForwardOrdered"><code>ForwardOrdered</code></a>, <a href="#DimensionalData.Dimensions.LookupArrays.ReverseOrdered"><code>ReverseOrdered</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Unordered"><code>Unordered</code></a>.   These can be provided explicitly if they are known and performance is important.</li><li><code>span</code>: indicates the size of intervals or distance between points, and will be set to   <a href="#DimensionalData.Dimensions.LookupArrays.Regular"><code>Regular</code></a> for <code>AbstractRange</code> and <a href="#DimensionalData.Dimensions.LookupArrays.Irregular"><code>Irregular</code></a> for <code>AbstractArray</code>,   unless assigned manually.</li><li><code>sampling</code>: is assigned to <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a>, unless set to <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> manually.    Using <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a> will change the behaviour of <code>bounds</code> and <code>Selectors</code>s   to take account for the full size of the interval, rather than the point alone.</li><li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is <code>NoMetadata()</code>.</li></ul><p><strong>Example</strong></p><p>Create an array with [<code>Interval</code>] sampling, and <code>Regular</code> span for a vector with known spacing.</p><p>We set the <a href="#DimensionalData.Dimensions.LookupArrays.Locus"><code>Locus</code></a> of the <code>Intervals</code> to <code>Start</code> specifying that the index values are for the positions at the start of each interval.</p><pre><code class="language-julia hljs">using DimensionalData, DimensionalData.LookupArrays

x = X(Sampled(100:-20:10; sampling=Intervals(Start())))
y = Y(Sampled([1, 4, 7, 10]; span=Regular(3), sampling=Intervals(Start())))
A = ones(x, y)

# output
5×4 DimArray{Float64,2} with dimensions:
  X Sampled{Int64} 100:-20:20 ReverseOrdered Regular Intervals,
  Y Sampled{Int64} Int64[1, 4, 7, 10] ForwardOrdered Regular Intervals
      1    4    7    10
 100  1.0  1.0  1.0   1.0
  80  1.0  1.0  1.0   1.0
  60  1.0  1.0  1.0   1.0
  40  1.0  1.0  1.0   1.0
  20  1.0  1.0  1.0   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L212-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AbstractCategorical" href="#DimensionalData.Dimensions.LookupArrays.AbstractCategorical"><code>DimensionalData.Dimensions.LookupArrays.AbstractCategorical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCategorical &lt;: Aligned</code></pre><p><a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>s where the values are categories.</p><p><a href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>Categorical</code></a> is the provided concrete implementation.  but this can easily be extended - all methods are defined for <code>AbstractCategorical</code>.</p><p>All <code>AbstractCategorical</code> must provide a <code>rebuild</code> method with <code>data</code>, <code>order</code> and <code>metadata</code> keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L294-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Categorical" href="#DimensionalData.Dimensions.LookupArrays.Categorical"><code>DimensionalData.Dimensions.LookupArrays.Categorical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Categorical &lt;: AbstractCategorical

Categorical(o::Order)
Categorical(; order=Unordered())</code></pre><p>An LookupArray where the values are categories.</p><p>This will be automatically assigned if the index contains <code>AbstractString</code>, <code>Symbol</code> or <code>Char</code>. Otherwise it can be assigned manually.</p><p><a href="#DimensionalData.Dimensions.LookupArrays.Order"><code>Order</code></a> will be determined automatically where possible.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: An <code>AbstractVector</code> of index values, matching the length of the curresponding   array axis. </li><li><code>order</code>: <a href="#DimensionalData.Dimensions.LookupArrays.Order"><code>Order</code></a>) indicating the order of the index,   <a href="#DimensionalData.Dimensions.LookupArrays.AutoOrder"><code>AutoOrder</code></a> by default, detected from the order of <code>data</code>   to be <code>ForwardOrdered</code>, <code>ReverseOrdered</code> or <code>Unordered</code>.   Can be provided if this is known and performance is important.</li><li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> wrapper that holds any metadata object adding more   information about the array axis - useful for extending DimensionalData for specific   contexts, like geospatial data in GeoData.jl. By default it is <code>NoMetadata()</code>.</li></ul><p><strong>Example</strong></p><p>Create an array with [<code>Interval</code>] sampling.</p><pre><code class="language-julia hljs">using DimensionalData

ds = X([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]), Y([:a, :b, :c, :d])
A = DimArray(rand(3, 4), ds)
Dimensions.lookup(A)

# output

Categorical{String} String[one, two, three] Unordered,
Categorical{Symbol} Symbol[a, b, c, d] ForwardOrdered</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L317-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Unaligned" href="#DimensionalData.Dimensions.LookupArrays.Unaligned"><code>DimensionalData.Dimensions.LookupArrays.Unaligned</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Unaligned &lt;: LookupArray</code></pre><p>Abstract supertype for <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> where the index is not aligned to the grid.</p><p>Indexing an <a href="#DimensionalData.Dimensions.LookupArrays.Unaligned"><code>Unaligned</code></a> with <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s must provide all other <a href="#DimensionalData.Dimensions.LookupArrays.Unaligned"><code>Unaligned</code></a> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L379-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Transformed" href="#DimensionalData.Dimensions.LookupArrays.Transformed"><code>DimensionalData.Dimensions.LookupArrays.Transformed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Transformed &lt;: Unaligned

Transformed(f, dim::Dimension; metadata=NoMetadata())</code></pre><p><a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> that uses an affine transformation to convert dimensions from <code>dims(lookup)</code> to <code>dims(array)</code>. This can be useful when the dimensions are e.g. rotated from a more commonly used axis.</p><p>Any function can be used to do the transformation, but transformations from CoordinateTransformations.jl may be useful.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: transformation function</li><li><code>dim</code>: a dimension to transform to.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>metdata</code>: </li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DimensionalData, DimensionalData.LookupArrays, CoordinateTransformations

m = LinearMap([0.5 0.0; 0.0 0.5])
A = [1 2  3  4
     5 6  7  8
     9 10 11 12];
da = DimArray(A, (t1=Transformed(m, X), t2=Transformed(m, Y)))

da[X(At(6)), Y(At(2))]

# output
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L389-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.MergedLookup" href="#DimensionalData.Dimensions.MergedLookup"><code>DimensionalData.Dimensions.MergedLookup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MergedLookup &lt;: LookupArray

MergedLookup(data, dims; [metadata])</code></pre><p>A <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> that holds multiple combined dimensions.</p><p><code>MergedLookup</code> can be indexed with <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s like <code>At</code>,  <code>Between</code>, and <code>Where</code> although <code>Near</code> has undefined meaning.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: A <code>Vector</code> of <code>Tuple</code>.</li><li><code>dims</code>: A <code>Tuple</code> of <a href="#DimensionalData.Dimensions.Dimension"><code>Dimension</code></a> indicating the dimensions in the tuples in <code>data</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>metadata</code>: a <code>Dict</code> or <code>Metadata</code> object to attach dimension metadata.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/Dimensions/merged.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.NoLookup" href="#DimensionalData.Dimensions.LookupArrays.NoLookup"><code>DimensionalData.Dimensions.LookupArrays.NoLookup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoLookup &lt;: LookupArray

NoLookup()</code></pre><p>A <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> that is identical to the array axis.  <a href="#DimensionalData.Dimensions.LookupArrays.Selector"><code>Selector</code></a>s can&#39;t be used on this lookup.</p><p><strong>Example</strong></p><p>Defining a <code>DimArray</code> without passing an index to the dimensions, it will be assigned <code>NoLookup</code>:</p><pre><code class="language-julia hljs">using DimensionalData

A = DimArray(rand(3, 3), (X, Y))
Dimensions.lookup(A)

# output

NoLookup, NoLookup</code></pre><p>Which is identical to:</p><pre><code class="language-julia hljs">using .LookupArrays
A = DimArray(rand(3, 3), (X(NoLookup()), Y(NoLookup())))
Dimensions.lookup(A)

# output

NoLookup, NoLookup</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L104-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AutoLookup" href="#DimensionalData.Dimensions.LookupArrays.AutoLookup"><code>DimensionalData.Dimensions.LookupArrays.AutoLookup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoLookup &lt;: LookupArray

AutoLookup()
AutoLookup(index=AutoIndex(); kw...)</code></pre><p>Automatic <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>, the default lookup. It will be converted automatically to another <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a> when it is possible to detect it from the index.</p><p>Keywords will be used in the detected <code>LookupArray</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_arrays.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AutoIndex" href="#DimensionalData.Dimensions.LookupArrays.AutoIndex"><code>DimensionalData.Dimensions.LookupArrays.AutoIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoIndex</code></pre><p>Detect a <code>LookupArray</code> index from the context. This is used in <code>NoLookup</code> to simply use the array axis as the index when the array is constructed, and in <code>set</code> to change the <code>LookupArray</code> type without changing the index values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L257-L263">source</a></section></article><h2 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AbstractMetadata" href="#DimensionalData.Dimensions.LookupArrays.AbstractMetadata"><code>DimensionalData.Dimensions.LookupArrays.AbstractMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMetadata{X,T}</code></pre><p>Abstract supertype for all metadata wrappers.</p><p>Metadata wrappers allow tracking the contents and origin of metadata. This can  facilitate conversion between metadata types (for saving a file to a differenet format) or simply saving data back to the same file type with identical metadata.</p><p>Using a wrapper instead of <code>Dict</code> or <code>NamedTuple</code> also lets us pass metadata  objects to <a href="#DimensionalData.Dimensions.LookupArrays.set"><code>set</code></a> without ambiguity about where to put them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/metadata.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Metadata" href="#DimensionalData.Dimensions.LookupArrays.Metadata"><code>DimensionalData.Dimensions.LookupArrays.Metadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Metadata &lt;: AbstractMetadata

Metadata{X}(val::Union{Dict,NamedTuple})
Metadata{X}(pairs::Pair...) =&gt; Metadata{Dict}
Metadata{X}(; kw...) =&gt; Metadata{NamedTuple}</code></pre><p>General <a href="#DimensionalData.Dimensions.LookupArrays.Metadata"><code>Metadata</code></a> object. The <code>X</code> type parameter categorises the metadata for method dispatch, if required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/metadata.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.NoMetadata" href="#DimensionalData.Dimensions.LookupArrays.NoMetadata"><code>DimensionalData.Dimensions.LookupArrays.NoMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoMetadata &lt;: AbstractMetadata

NoMetadata()</code></pre><p>Indicates an object has no metadata. But unlike using <code>nothing</code>,  <code>get</code>, <code>keys</code> and <code>haskey</code> will still work on it, <code>get</code> always returning the fallback argument. <code>keys</code> returns <code>()</code> while <code>haskey</code> always returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/metadata.jl#L67-L76">source</a></section></article><h2 id="LookupArray-traits"><a class="docs-heading-anchor" href="#LookupArray-traits">LookupArray traits</a><a id="LookupArray-traits-1"></a><a class="docs-heading-anchor-permalink" href="#LookupArray-traits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.LookupArrayTrait" href="#DimensionalData.Dimensions.LookupArrays.LookupArrayTrait"><code>DimensionalData.Dimensions.LookupArrays.LookupArrayTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LookupArrayTrait</code></pre><p>Abstract supertype of all traits of a <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>.</p><p>These modify the behaviour of the lookup index.</p><p>The term &quot;Trait&quot; is used loosely - these may be fields of an object of traits hard-coded to specific types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L2-L11">source</a></section></article><h3 id="Order"><a class="docs-heading-anchor" href="#Order">Order</a><a id="Order-1"></a><a class="docs-heading-anchor-permalink" href="#Order" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Order" href="#DimensionalData.Dimensions.LookupArrays.Order"><code>DimensionalData.Dimensions.LookupArrays.Order</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Order &lt;: LookupArrayTrait</code></pre><p>Traits for the order of a <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>. These determine how <code>searchsorted</code> finds values in the index, and how objects are plotted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Ordered" href="#DimensionalData.Dimensions.LookupArrays.Ordered"><code>DimensionalData.Dimensions.LookupArrays.Ordered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ordered &lt;: Order</code></pre><p>Supertype for the order of an ordered <a href="#DimensionalData.Dimensions.LookupArrays.LookupArray"><code>LookupArray</code></a>, including <a href="#DimensionalData.Dimensions.LookupArrays.ForwardOrdered"><code>ForwardOrdered</code></a> and <a href="#DimensionalData.Dimensions.LookupArrays.ReverseOrdered"><code>ReverseOrdered</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.ForwardOrdered" href="#DimensionalData.Dimensions.LookupArrays.ForwardOrdered"><code>DimensionalData.Dimensions.LookupArrays.ForwardOrdered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardOrdered &lt;: Ordered

ForwardOrdered()</code></pre><p>Indicates that the <code>LookupArray</code> index is in the normal forward order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.ReverseOrdered" href="#DimensionalData.Dimensions.LookupArrays.ReverseOrdered"><code>DimensionalData.Dimensions.LookupArrays.ReverseOrdered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReverseOrdered &lt;: Ordered

ReverseOrdered()</code></pre><p>Indicates that the <code>LookupArray</code> index is in the reverse order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Unordered" href="#DimensionalData.Dimensions.LookupArrays.Unordered"><code>DimensionalData.Dimensions.LookupArrays.Unordered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Unordered &lt;: Order

Unordered()</code></pre><p>Indicates that <code>LookupArray</code> is unordered.</p><p>This means the index cannot be searched with <code>searchsortedfirst</code> or similar optimised methods - instead it will use <code>findfirst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AutoOrder" href="#DimensionalData.Dimensions.LookupArrays.AutoOrder"><code>DimensionalData.Dimensions.LookupArrays.AutoOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoOrder &lt;: Order

AutoOrder()</code></pre><p>Specifies that the <code>Order</code> of a <code>LookupArray</code> will be found automatically where possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L30-L37">source</a></section></article><h3 id="Span"><a class="docs-heading-anchor" href="#Span">Span</a><a id="Span-1"></a><a class="docs-heading-anchor-permalink" href="#Span" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Span" href="#DimensionalData.Dimensions.LookupArrays.Span"><code>DimensionalData.Dimensions.LookupArrays.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Span &lt;: LookupArrayTrait</code></pre><p>Defines the type of span used in a <a href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>Sampling</code></a> index. These are <a href="#DimensionalData.Dimensions.LookupArrays.Regular"><code>Regular</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Irregular"><code>Irregular</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Regular" href="#DimensionalData.Dimensions.LookupArrays.Regular"><code>DimensionalData.Dimensions.LookupArrays.Regular</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Regular &lt;: Span

Regular(step=AutoStep())</code></pre><p><code>Points</code> or <code>Intervals</code> that have a fixed, regular step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Irregular" href="#DimensionalData.Dimensions.LookupArrays.Irregular"><code>DimensionalData.Dimensions.LookupArrays.Irregular</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Irregular &lt;: Span

Irregular(bounds::Tuple)
Irregular(lowerbound, upperbound)</code></pre><p><code>Points</code> or <code>Intervals</code> that have an <code>Irrigular</code> step size. To enable bounds tracking and accuract selectors, the starting bounds are provided as a 2 tuple, or 2 arguments. <code>(nothing, nothing)</code> is acceptable input, the bounds will be guessed from the index, but may be innaccurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L219-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Explicit" href="#DimensionalData.Dimensions.LookupArrays.Explicit"><code>DimensionalData.Dimensions.LookupArrays.Explicit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Explicit(bounds::AbstractMatix)</code></pre><p>Intervals where the span is explicitly listed for every interval.</p><p>This uses a matrix where with length 2 columns for each index value, holding the lower and upper bounds for that specific index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L241-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AutoSpan" href="#DimensionalData.Dimensions.LookupArrays.AutoSpan"><code>DimensionalData.Dimensions.LookupArrays.AutoSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoSpan &lt;: Span

AutoSpan()</code></pre><p>The span will be guessed and replaced in <code>format</code> or <code>set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L189-L195">source</a></section></article><h3 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Sampling" href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>DimensionalData.Dimensions.LookupArrays.Sampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sampling &lt;: LookupArrayTrait</code></pre><p>Indicates the sampling method used by the index: <a href="#DimensionalData.Dimensions.LookupArrays.Points"><code>Points</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Points" href="#DimensionalData.Dimensions.LookupArrays.Points"><code>DimensionalData.Dimensions.LookupArrays.Points</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Points &lt;: Sampling

Points()</code></pre><p><a href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>Sampling</code></a> lookup where single samples at exact points.</p><p>These are always plotted at the center of array cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L141-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Intervals" href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>DimensionalData.Dimensions.LookupArrays.Intervals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Intervals &lt;: Sampling

Intervals(locus::Locus)</code></pre><p><a href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>Sampling</code></a> specifying that sampled values are the mean (or similar) value over an <em>interval</em>, rather than at one specific point.</p><p>Intervals require a <a href="#DimensionalData.Dimensions.LookupArrays.Locus"><code>Locus</code></a> of <a href="#DimensionalData.Dimensions.LookupArrays.Start"><code>Start</code></a>, <a href="#DimensionalData.Dimensions.LookupArrays.Center"><code>Center</code></a> or <a href="#DimensionalData.Dimensions.LookupArrays.End"><code>End</code></a> to define the location in the interval that the index values refer to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L154-L164">source</a></section></article><h3 id="Loci"><a class="docs-heading-anchor" href="#Loci">Loci</a><a id="Loci-1"></a><a class="docs-heading-anchor-permalink" href="#Loci" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Locus" href="#DimensionalData.Dimensions.LookupArrays.Locus"><code>DimensionalData.Dimensions.LookupArrays.Locus</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Locus &lt;: LookupArrayTrait</p><p>Abstract supertype of types that indicate the position of index values  where they represent <a href="#DimensionalData.Dimensions.LookupArrays.Intervals"><code>Intervals</code></a>.</p><p>These allow for values array cells to align with the <a href="#DimensionalData.Dimensions.LookupArrays.Start"><code>Start</code></a>, <a href="#DimensionalData.Dimensions.LookupArrays.Center"><code>Center</code></a>, or <a href="#DimensionalData.Dimensions.LookupArrays.End"><code>End</code></a> of values in the lookup index.</p><p>This means they can be plotted with correct axis markers, and allows automatic converrsions to between formats with different standards (such as NetCDF and GeoTiff).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Center" href="#DimensionalData.Dimensions.LookupArrays.Center"><code>DimensionalData.Dimensions.LookupArrays.Center</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Center &lt;: Locus

Center()</code></pre><p>Indicates a lookup value is for the center of its corresponding array cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.Start" href="#DimensionalData.Dimensions.LookupArrays.Start"><code>DimensionalData.Dimensions.LookupArrays.Start</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Start &lt;: Locus

Start()</code></pre><p>Indicates a lookup value is for the start of its corresponding array cell, in the direction of the lookup index order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.End" href="#DimensionalData.Dimensions.LookupArrays.End"><code>DimensionalData.Dimensions.LookupArrays.End</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">End &lt;: Locus

End()</code></pre><p>Indicates a lookup value is for the end of its corresponding array cell, in the direction of the lookup index order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.AutoLocus" href="#DimensionalData.Dimensions.LookupArrays.AutoLocus"><code>DimensionalData.Dimensions.LookupArrays.AutoLocus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoLocus &lt;: Locus

AutoLocus()</code></pre><p>Indicates a interval where the index position is not yet known. This will be filled with a default value on object construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/lookup_traits.jl#L117-L124">source</a></section></article><h2 id="LookupArrays-methods"><a class="docs-heading-anchor" href="#LookupArrays-methods">LookupArrays methods</a><a id="LookupArrays-methods-1"></a><a class="docs-heading-anchor-permalink" href="#LookupArrays-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.hasselection" href="#DimensionalData.Dimensions.LookupArrays.hasselection"><code>DimensionalData.Dimensions.LookupArrays.hasselection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasselection(x, selector) =&gt; Bool
hasselection(x, selectors::Tuple) =&gt; Bool</code></pre><p>Check if indexing into x with <code>selectors</code> can be performed, where x is some object with a <code>dims</code> method, and <code>selectors</code> is a <code>Selector</code> or <code>Dimension</code> or a tuple of either.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.shiftlocus" href="#DimensionalData.Dimensions.LookupArrays.shiftlocus"><code>DimensionalData.Dimensions.LookupArrays.shiftlocus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shiftlocus(locus::Locus, x)</code></pre><p>Shift the index of <code>x</code> from the current locus to the new locus.</p><p>We only shift <code>Samped</code>, <code>Regular</code> or <code>Explicit</code>, <code>Intervals</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/LookupArrays/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.sampling" href="#DimensionalData.Dimensions.LookupArrays.sampling"><code>DimensionalData.Dimensions.LookupArrays.sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sampling(x, [dims::Tuple]) =&gt; Tuple
sampling(x, dim) =&gt; Sampling
sampling(xs::Tuple) =&gt; Tuple{Vararg{&lt;:Sampling}}
sampling(x:Union{Dimension,LookupArray}) =&gt; Sampling</code></pre><p>Return the <a href="#DimensionalData.Dimensions.LookupArrays.Sampling"><code>Sampling</code></a> for each dimension.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L188-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.span" href="#DimensionalData.Dimensions.LookupArrays.span"><code>DimensionalData.Dimensions.LookupArrays.span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">span(x, [dims::Tuple]) =&gt; Tuple
span(x, dim) =&gt; Span
span(xs::Tuple) =&gt; Tuple{Vararg{&lt;:Span,N}}
span(x::Union{Dimension,LookupArray}) =&gt; Span</code></pre><p>Return the <a href="#DimensionalData.Dimensions.LookupArrays.Span"><code>Span</code></a> for each dimension.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L201-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.order" href="#DimensionalData.Dimensions.LookupArrays.order"><code>DimensionalData.Dimensions.LookupArrays.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order(x, [dims::Tuple]) =&gt; Tuple
order(xs::Tuple) =&gt; Tuple
order(x::Union{Dimension,LookupArray}) =&gt; Order</code></pre><p>Return the <code>Ordering</code> of the dimension index for each dimension: <code>ForwardOrdered</code>, <code>ReverseOrdered</code>, or <a href="#DimensionalData.Dimensions.LookupArrays.Unordered"><code>Unordered</code></a> </p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L175-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.index" href="#DimensionalData.Dimensions.LookupArrays.index"><code>DimensionalData.Dimensions.LookupArrays.index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">index(x) =&gt; Tuple{Vararg{&lt;:AbstractArray}}
index(x, dims::Tuple) =&gt; Tuple{Vararg{&lt;:AbstractArray}}
index(dims::Tuple) =&gt; Tuple{Vararg{&lt;:AbstractArray}}}
index(x, dim) =&gt; AbstractArray
index(dim::Dimension) =&gt; AbstractArray</code></pre><p>Return the contained index of a <code>Dimension</code>.</p><p>Only valid when a <code>Dimension</code> contains an <code>AbstractArray</code> or a Val tuple like <code>Val{(:a, :b)}()</code>. The <code>Val</code> is unwrapped to return just the <code>Tuple</code></p><p><code>dims</code> can be a <code>Dimension</code>, or a tuple of <code>Dimension</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.locus" href="#DimensionalData.Dimensions.LookupArrays.locus"><code>DimensionalData.Dimensions.LookupArrays.locus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">locus(x, [dims::Tuple]) =&gt; Tuple
locus(x, dim) =&gt; Locus
locus(xs::Tuple) =&gt; Tuple{Vararg{&lt;:Locus,N}}
locus(x::Union{Dimension,LookupArray}) =&gt; Locus</code></pre><p>Return the <a href="#DimensionalData.Dimensions.LookupArrays.Locus"><code>Locus</code></a> for each dimension.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L214-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Dimensions.LookupArrays.units" href="#DimensionalData.Dimensions.LookupArrays.units"><code>DimensionalData.Dimensions.LookupArrays.units</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">units(x) =&gt; Union{Nothing,Any}
units(xs:Tuple) =&gt; Tuple
unit(A::AbstractDimArray, dims::Tuple) =&gt; Tuple
unit(A::AbstractDimArray, dim) =&gt; Union{Nothing,Any}</code></pre><p>Get the units of an array or <code>Dimension</code>, or a tuple of of either.</p><p>Units do not have a set field, and may or may not be included in <code>metadata</code>. This method is to facilitate use in labels and plots when units are available, not a guarantee that they will be. If not available, <code>nothing</code> is returned.</p><p>Second argument <code>dims</code> can be <code>Dimension</code>s, <code>Dimension</code> types, or <code>Symbols</code> for <code>Dim{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/interface.jl#L131-L145">source</a></section></article><h2 id="Name"><a class="docs-heading-anchor" href="#Name">Name</a><a id="Name-1"></a><a class="docs-heading-anchor-permalink" href="#Name" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.AbstractName" href="#DimensionalData.AbstractName"><code>DimensionalData.AbstractName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractName</code></pre><p>Abstract supertype for name wrappers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/name.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.Name" href="#DimensionalData.Name"><code>DimensionalData.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Name &lt;: AbstractName

Name(name::Union{Symbol,Name) =&gt; Name
Name(name::NoName) =&gt; NoName</code></pre><p>Name wrapper. This lets arrays keep symbol names when the array wrapper neeeds to be `isbits, like for use on GPUs. It makes the name a property of the type. It&#39;s not necessary to use in normal use, a symbol is probably easier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/name.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.NoName" href="#DimensionalData.NoName"><code>DimensionalData.NoName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoName &lt;: AbstractName

NoName()</code></pre><p>NoName specifies an array is not named, and is the default <code>name</code> value for all <code>AAbstractDimArray</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/DimensionalData.jl/blob/11be8da01d0c23ef82d6d4b4e7ae5f7d2edab232/src/name.jl#L10-L17">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../course/">« Crash course</a><a class="docs-footer-nextpage" href="../developer/">For Developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 19 February 2023 13:19">Sunday 19 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
