var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"To use the functionality of DimensionalData in your module, dispatch on AbstractDimensionalArray and AbstractDimension.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Arrays:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"AbstractDimensionalArray\r\nDimensionalArray","category":"page"},{"location":"api/#DimensionalData.AbstractDimensionalArray","page":"API","title":"DimensionalData.AbstractDimensionalArray","text":"Parent type for all dimensional arrays.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DimensionalArray","page":"API","title":"DimensionalData.DimensionalArray","text":"DimensionalArray(data, dims, refdims, name)\n\nThe main subtype of AbstractDimensionalArray. Maintains and updates its dimensions through transformations and moves dimensions to refdims after reducing operations (like e.g. mean).\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-types-1","page":"API","title":"Core types","text":"","category":"section"},{"location":"api/#Dimensions:-1","page":"API","title":"Dimensions:","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Dimension\r\nDependentDim\r\nIndependentDim\r\nXDim\r\nYDim\r\nZDim\r\nTimeDim\r\nX\r\nY\r\nZ\r\nTi\r\nParametricDimension\r\nDim\r\nAnonDim\r\n@dim","category":"page"},{"location":"api/#DimensionalData.Dimension","page":"API","title":"DimensionalData.Dimension","text":"Dimension is the abstract supertype of all dimension types.\n\nExample concrete implementations are X, Y, Z,  Ti (Time), and the arbirary Dim{:custom} dimension.\n\nDimensions label the axes of an AbstractDimesnionalArray,  or other dimensional data. They may also provide an alternate index  to lookup for each array axis.\n\nExample:\n\nusing Dates\nx = X(2:2:10)\ny = Y(['a', 'b', 'c'])\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\nA = DimensionalArray(rand(3, 5, 12), (y, x, ti));\n\nFor simplicity, the same Dimension types are also used as wrappers  in getindex, like:\n\nx = A[X(2), Y(3)]\n\nDimension can also wrap Selectors.\n\nx = A[X(Between(3, 4)), Y(At('b'))]\n\nDimension objects may have mode and metadata fields to track additional information about the data and the index, and their relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.DependentDim","page":"API","title":"DimensionalData.DependentDim","text":"Abstract supertype for Dependent dimensions. These will plot on the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.IndependentDim","page":"API","title":"DimensionalData.IndependentDim","text":"Abstract supertype for independent dimensions. Thise will plot on the X axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.XDim","page":"API","title":"DimensionalData.XDim","text":"Abstract parent type for all X dimensions. \n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.YDim","page":"API","title":"DimensionalData.YDim","text":"Abstract parent type for all Y dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ZDim","page":"API","title":"DimensionalData.ZDim","text":"Abstract parent type for all Z dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.TimeDim","page":"API","title":"DimensionalData.TimeDim","text":"Abstract parent type for all time dimensions.\n\nFor an index with Interval sampling the locus will automatically be set to Start(), as a date/time index generally defines the start of a  month, second etc, not the central point as is more common with spatial data. `\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.X","page":"API","title":"DimensionalData.X","text":"X Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nx = X(2:2:10)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Y","page":"API","title":"DimensionalData.Y","text":"Y Dimension. Y <: YDim <: DependentDim\n\nExample:\n\ny = Y(['a', 'b', 'c'])\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Z","page":"API","title":"DimensionalData.Z","text":"Z Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nz = Z(10:10:100)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ti","page":"API","title":"DimensionalData.Ti","text":"Time Dimension. Ti <: TimeDim <: IndependentDim\n\nTime is already used by Dates, so we use Ti to avoid clashing.\n\nExample:\n\nti = Ti(DateTime(2021, 1):Month(1):DateTime(2021, 12))\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.ParametricDimension","page":"API","title":"DimensionalData.ParametricDimension","text":"Dimensions with user-set type paremeters\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Dim","page":"API","title":"DimensionalData.Dim","text":"Dim{X}(val, mode, metadata)\nDim{X}(val=:; [mode=Auto()], [metadata=nothing])\n\nA generic dimension. For use when custom dims are required when loading data from a file. The sintax is ugly and verbose to use for indexing, ie Dim{:lat}(1:9) rather than Lat(1:9). This is the main reason they are not the only type of dimension availabile.\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AnonDim","page":"API","title":"DimensionalData.AnonDim","text":"AnonDim()\n\nAnonymous dimension. Used when extra dimensions are created,  such as during transpose of a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.@dim","page":"API","title":"DimensionalData.@dim","text":"@dim typ [supertype=Dimension] [name=string(typ)] [shortname=string(typ)]\n\nMacro to easily define specific dimensions.\n\nExample:\n\n@dim Lat \"Lattitude\" \"lat\"\n@dim Lon XDim \"Longitude\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#Selectors-1","page":"API","title":"Selectors","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Selector\r\nAt\r\nNear\r\nBetween\r\nContains","category":"page"},{"location":"api/#DimensionalData.Selector","page":"API","title":"DimensionalData.Selector","text":"Selectors are wrappers that indicate that passed values are not the array indices, but values to be selected from the dimension index, such as DateTime objects for a Ti dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.At","page":"API","title":"DimensionalData.At","text":"At(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Near","page":"API","title":"DimensionalData.Near","text":"Near(x)\n\nSelector that selects the nearest index. With Points this is simply the index nearest to the contained value, however with Intervals it is the interval center nearest to the contained value. This will be offset from the index value for Start and End loci.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Between","page":"API","title":"DimensionalData.Between","text":"Between(a, b)\n\nSelector that retreive all indices located between 2 values.\n\nFor Intervals the whole interval must be lie between the values. For Points the points must fall between the 2 values. These different sampling traits will often give different results with the same index and values - this is the intended behaviour.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Contains","page":"API","title":"DimensionalData.Contains","text":"Contains(x)\n\nSelector that selects the interval the value is contained by. If the interval is not present in the index, an error will be thrown.\n\nCan only be used for Intervals or Categorical.\n\n\n\n\n\n","category":"type"},{"location":"api/#Index-Modes-1","page":"API","title":"Index Modes","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"IndexMode\r\nAligned\r\nAbstractSampled\r\nSampled\r\nAbstractCategorical\r\nCategorical\r\nUnaligned\r\nTransformed\r\nNoIndex\r\nAuto","category":"page"},{"location":"api/#DimensionalData.IndexMode","page":"API","title":"DimensionalData.IndexMode","text":"Traits describing the mode of a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Aligned","page":"API","title":"DimensionalData.Aligned","text":"Supertype for IndexMode where the index is aligned with the array axes. This is by far the most common case.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractSampled","page":"API","title":"DimensionalData.AbstractSampled","text":"An IndexMode whos index is aligned with the array, and is independent of other dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Sampled","page":"API","title":"DimensionalData.Sampled","text":"A concrete implementation of AbstractSampled. Can be used to represent points or intervals, with sampling of Points or Intervals.\n\nFields\n\norder: Order indicating array and index order\nspan::Span: Span indicating Regular or Irregular size of intervals or distance between points\nsampling::Sampling: Sampling of Intervals or Points (the default)\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AbstractCategorical","page":"API","title":"DimensionalData.AbstractCategorical","text":"IndexModes for dimensions where the values are categories.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Categorical","page":"API","title":"DimensionalData.Categorical","text":"An IndexMode where the values are categories.\n\nFields\n\norder: Order indicating array and index order.\n\nOrder will not be determined automatically for Categorical, it instead defaults to Unordered()\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unaligned","page":"API","title":"DimensionalData.Unaligned","text":"Supertype for IndexMode where the Dimension index is not aligned to the grid.\n\nIndexing with an Unaligned dimension must provide all other Unaligned dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Transformed","page":"API","title":"DimensionalData.Transformed","text":"IndexMode that uses an affine transformation to convert dimensions from dims(mode) to dims(array).\n\nFields\n\ndims: a tuple containing dimenension types or symbols matching the order needed by the transform function.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.NoIndex","page":"API","title":"DimensionalData.NoIndex","text":"IndexMode that is identical to the array axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Auto","page":"API","title":"DimensionalData.Auto","text":"Automatic IndexMode. Will be converted automatically to another IndexMode when possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Order of arrays and indices:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Order\r\nUnordered\r\nOrdered\r\nAutoOrder\r\nUnknownOrder\r\nDimensionalData.Forward\r\nDimensionalData.Reverse","category":"page"},{"location":"api/#DimensionalData.Order","page":"API","title":"DimensionalData.Order","text":"Traits for the order of the array, index and the relation between them.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Unordered","page":"API","title":"DimensionalData.Unordered","text":"Trait indicating that the array or dimension has no order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Ordered","page":"API","title":"DimensionalData.Ordered","text":"Container object for dimension and array ordering.\n\nThe default is Ordered(Forward(), Forward(), Forward())\n\nAll combinations of forward and reverse order for data and indices seem to occurr in real datasets, as strange as that seems. We cover these possibilities by specifying the order of both explicitly.\n\nKnowing the order of indices is important for using methods like searchsortedfirst() to find indices in sorted lists of values. Knowing the order of the data is then required to map to the actual indices. It's also used to plot the data later - which always happens in smallest to largest order.\n\nBase also defines Forward and Reverse, but they seem overly complicated for our purposes.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoOrder","page":"API","title":"DimensionalData.AutoOrder","text":"Order will be found automatically where possible.\n\nThis will fail for all types without isless methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.UnknownOrder","page":"API","title":"DimensionalData.UnknownOrder","text":"Order is not known and can't be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Forward","page":"API","title":"DimensionalData.Forward","text":"Indicates that the array or dimension is in the normal forward order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Reverse","page":"API","title":"DimensionalData.Reverse","text":"Indicates that the array or dimension is in the reverse order. Selector lookup or plotting will be reversed.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Index modes for Sampled","category":"page"},{"location":"api/#Loci-1","page":"API","title":"Loci","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Locus\r\nCenter\r\nStart\r\nEnd\r\nAutoLocus","category":"page"},{"location":"api/#DimensionalData.Locus","page":"API","title":"DimensionalData.Locus","text":"Locii indicate the position of index values in cells.\n\nLocii are often Start for time series, but often Center for spatial data.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Center","page":"API","title":"DimensionalData.Center","text":"Indicates dimension index that matches the center coordinates/time/position.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Start","page":"API","title":"DimensionalData.Start","text":"Indicates dimension index that matches the start coordinates/time/position.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.End","page":"API","title":"DimensionalData.End","text":"Indicates dimension index that matches the end coordinates/time/position.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoLocus","page":"API","title":"DimensionalData.AutoLocus","text":"Indicates dimension where the index position is not known.\n\n\n\n\n\n","category":"type"},{"location":"api/#Span-1","page":"API","title":"Span","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Span\r\nRegular\r\nIrregular\r\nAutoSpan","category":"page"},{"location":"api/#DimensionalData.Span","page":"API","title":"DimensionalData.Span","text":"Mode defining the type of interval used in a InervalSampling index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Regular","page":"API","title":"DimensionalData.Regular","text":"Intervalss have regular size. This is passed to the constructor, although these are normally build automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Irregular","page":"API","title":"DimensionalData.Irregular","text":"Irregular have irrigular size. To enable bounds tracking and accuract selectors, the starting bounds must be provided as a 2 tuple, or 2 arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.AutoSpan","page":"API","title":"DimensionalData.AutoSpan","text":"Span will be guessed and replaced by a constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sampling-1","page":"API","title":"Sampling","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Sampling\r\nPoints\r\nIntervals","category":"page"},{"location":"api/#DimensionalData.Sampling","page":"API","title":"DimensionalData.Sampling","text":"Indicates the sampling method used by the index.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Points","page":"API","title":"DimensionalData.Points","text":"Sampling mode where single samples at exact points.\n\n\n\n\n\n","category":"type"},{"location":"api/#DimensionalData.Intervals","page":"API","title":"DimensionalData.Intervals","text":"Sampling mode where samples are the mean (or similar) value over an interval.\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods-1","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#Getting-basic-info-1","page":"API","title":"Getting basic info","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"These useful functions for obtaining information from your dimensional data:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"bounds\r\ndata\r\ndimnum\r\ndims\r\nhasdim\r\nlabel\r\nmetadata\r\nname\r\nrebuild\r\nrefdims\r\nshortname\r\nunits\r\nval","category":"page"},{"location":"api/#DimensionalData.bounds","page":"API","title":"DimensionalData.bounds","text":"bounds(x, [dims])\n\nReturn the bounds of all dimensions of an object, of a specific dimension, or of a tuple of dimensions.\n\nReturns a length 2 Tuple in ascending order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.data","page":"API","title":"DimensionalData.data","text":"data(x)\n\nReturn the data wrapped by the dimentional array. This may not be the same as Base.parent, as it should never include data outside the bounds of the dimensions.\n\nIn a disk based AbstractDimensionalArray, data may need to load data from disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dimnum","page":"API","title":"DimensionalData.dimnum","text":"dimnum(x, lookup)\n\nGet the number(s) of Dimension(s) as ordered in the dimensions of an object.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nThe return type will be a Tuple of Int or a single Int, depending on wether lookup is a Tuple or single Dimension.\n\nExample\n\njulia> A = DimensionalArray(rand(10, 10, 10), (X, Y, Z));\n\njulia> dimnum(A, Z)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.dims","page":"API","title":"DimensionalData.dims","text":"dims(x)\n\nReturn a tuple of Dimensions for an object, in the order that matches  the axes or columns etc. of the underlying data.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.hasdim","page":"API","title":"DimensionalData.hasdim","text":"hasdim(x, lookup)\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nlookup: Tuple or single Dimension or dimension Type.\n\nCheck if an object or tuple contains an Dimension, or a tuple of dimensions.\n\nExample\n\njulia> A = DimensionalArray(rand(10, 10, 10), (X, Y, Z));\n\njulia> hasdim(A, X)\ntrue\n\njulia> hasdim(A, Ti)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.label","page":"API","title":"DimensionalData.label","text":"label(x)\n\nGet a plot label for data or a dimension. This will include the name and units if they exist, and anything else that should be shown on a plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.metadata","page":"API","title":"DimensionalData.metadata","text":"metadata(x)\n\nReturn the metadata of a dimension or data object.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.name","page":"API","title":"DimensionalData.name","text":"name(x)\n\nGet the name of data or a dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.rebuild","page":"API","title":"DimensionalData.rebuild","text":"rebuild(x, args...)\nrebuild(x; kwargs...)\n\nRebuild an object struct with updated values.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.refdims","page":"API","title":"DimensionalData.refdims","text":"refdims(x)\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some  captions empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.shortname","page":"API","title":"DimensionalData.shortname","text":"shortname(x)\n\nGet the short name of array data or a dimension.\n\nThis may be a shorter version more suitable for small labels than  name, but it may also be identical to name.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.units","page":"API","title":"DimensionalData.units","text":"units(x)\n\nReturn the units of a dimension. This could be a string, a unitful unit, or nothing.\n\nUnits do not have a field, and may or may not be included in metadata. This method is to facilitate use in labels and plots when units are available,  not a guarantee that they will be.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.val","page":"API","title":"DimensionalData.val","text":"val(x)\n\nReturn the contained value of a wrapper object, otherwise just returns the object.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"And some utility methods:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"setdim\r\nswapdims","category":"page"},{"location":"api/#DimensionalData.swapdims","page":"API","title":"DimensionalData.swapdims","text":"swapdims(x, newdims)\n\nSwap the dimension for the passed in dimensions. Dimension wrapper types rewrap the original dimension, keeping the values and metadata. Dimension instances replace the original dimension, and nothing leaves the original dimension as-is.\n\nArguments\n\nx: any object with a dims method, a Tuple of Dimension or a single Dimension.\nnewdim: Tuple or single Dimension or dimension Type.\n\nExample\n\njulia> A = DimensionalArray(rand(10, 10, 10), (X, Y, Z));\n\njulia> B = swapdims(A, (Z, Dim{:custom}, Ti));\n\njulia> dimnum(B, Ti)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/#Low-level-methods-1","page":"API","title":"Low-level methods","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"DimensionalData.dims2indices\r\nDimensionalData.formatdims\r\nDimensionalData.reducedims\r\nDimensionalData.slicedims\r\nDimensionalData.comparedims\r\nDimensionalData.identify\r\nDimensionalData.DimensionalStyle","category":"page"},{"location":"api/#DimensionalData.dims2indices","page":"API","title":"DimensionalData.dims2indices","text":"dims2indices(dim::Dimension, lookup, [emptyval=Colon()])\n\nConvert a Dimension or Selector lookup to indices, ranges or Colon.\n\n\n\n\n\ndims2indices(A, lookup, [emptyval=Colon()])\n\nConvert Dimension or Selector to regular indices for any object with a dims method, usually an array.\n\n\n\n\n\ndims2indices(dims, lookup, [emptyval=Colon()])\n\nConvert Dimension or Selector to regular indices for dims - a Tuple of Dimension. lookup can be a Tuple or a single object.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.formatdims","page":"API","title":"DimensionalData.formatdims","text":"formatdims(A, dims)\n\nFormat the passed-in dimension(s).\n\nMostily this means converting indexes of tuples and UnitRanges to LinRange, which is easier to handle internally. Errors are also thrown if dims don't match the array dims or size.\n\nIf a IndexMode hasn't been specified, an mode is chosen based on the type and element type of the index:\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.reducedims","page":"API","title":"DimensionalData.reducedims","text":"reducedims(x, dimstoreduce)\n\nReplace the specified dimensions with an index of length 1. This is usually to match a new array size where an axis has been reduced with a method like mean or reduce to a length of 1, but the number of dimensions has not changed.\n\nIndexMode traits are also updated to correspond to the change in cell step, sampling type and order.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.slicedims","page":"API","title":"DimensionalData.slicedims","text":"Slice the dimensions to match the axis values of the new array\n\nAll methods returns a tuple conatining two tuples: the new dimensions, and the reference dimensions. The ref dimensions are no longer used in the new struct but are useful to give context to plots.\n\nCalled at the array level the returned tuple will also include the previous reference dims attached to the array.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.comparedims","page":"API","title":"DimensionalData.comparedims","text":"comparedims(a, b)\n\nCheck that dimensions or tuples of dimensions are the same. Empty tuples are allowed\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.identify","page":"API","title":"DimensionalData.identify","text":"identify(indexmode, index)\n\nIdentify an IndexMode or its fields from index content and existing IndexMode.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.DimensionalStyle","page":"API","title":"DimensionalData.DimensionalStyle","text":"DimensionalStyle{S}\n\nThis is a BroadcastStyle for AbstractAbstractDimensionalArray's It preserves the dimension names. S should be the BroadcastStyle of the wrapped type.\n\nCopied from NamedDims.jl (thanks @oxinabox).\n\n\n\n\n\n","category":"type"},{"location":"developer/#For-package-developers-1","page":"For Developers","title":"For package developers","text":"","category":"section"},{"location":"developer/#Goals:-1","page":"For Developers","title":"Goals:","text":"","category":"section"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Maximum extensibility: always use method dispatch. Regular types over special syntax. Recursion over @generated.\nFlexibility: dims and selectors are parametric types with multiple uses\nAbstraction: never dispatch on concrete types, maximum re-usability of methods\nClean, readable syntax. Minimise required parentheses, minimise of exported methods, and instead extend Base methods whenever possible.\nMinimal interface: implementing a dimension-aware type should be easy.\nFunctional style: structs are always rebuilt, and other than the array data, fields are not mutated in place.\nLeast surprise: everything works the same as in Base, but with named dims. If a method accepts numeric indices or dims=X in base, you should be able to use DimensionalData.jl dims.\nType stability: dimensional methods should be type stable more often than Base methods\nZero cost dimensional indexing a[Y(4), X(5)] of a single value.\nLow cost indexing for range getindex and views: these cant be zero cost as dim ranges have to be updated.\nPlotting is easy: data should plot sensibly and correctly with useful labels - after all transformations using dims or indices\nPrioritise spatial data: other use cases are a free bonus of the modular approach.","category":"page"},{"location":"developer/#Why-this-package-1","page":"For Developers","title":"Why this package","text":"","category":"section"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Why not AxisArrays.jl or NamedDims.jl?","category":"page"},{"location":"developer/#Structure-1","page":"For Developers","title":"Structure","text":"","category":"section"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Both AxisArrays and NamedDims use concrete types for dispatch on arrays, and for dimension type Axis in AxisArrays. This makes them hard to extend.","category":"page"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Its a little easier with DimensionalData.jl. You can inherit from AbstractDimensionalArray, or just implement dims and rebuild methods. Dims and selectors in DimensionalData.jl are also extensible. Recursive primitive methods allow inserting whatever methods you want to add extra types. @generated is only used to match and permute arbitrary tuples of types, and contain no type-specific details. The @generated functions in AxisArrays internalise axis/index conversion behaviour preventing extension in external packages and scripts.","category":"page"},{"location":"developer/#Syntax-1","page":"For Developers","title":"Syntax","text":"","category":"section"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"AxisArrays.jl is verbose by default: a[Axis{:y}(1)] vs a[Y(1)] used here. NamedDims.jl has concise syntax, but the dimensions are no longer types.","category":"page"},{"location":"developer/#Data-types-and-the-interface-1","page":"For Developers","title":"Data types and the interface","text":"","category":"section"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"DimensionalData.jl provides the concrete DimenstionalArray type. But it's core purpose is to be easily used with other array types.","category":"page"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Some of the functionality in DimensionalData.jl will work without inheriting from AbstractDimensionalArray. The main requirement define a dims method that returns a Tuple of AbstractDimension that matches the dimension order and axis values of your data. Define rebuild, and base methods for similar and parent if you want the metadata to persist through transformations (see the DimensionalArray and AbstractDimensionalArray types). A refdims method returns the lost dimensions of a previous transformation, passed in to the rebuild method. refdims can be discarded, the main loss being plot labels.","category":"page"},{"location":"developer/#","page":"For Developers","title":"For Developers","text":"Inheriting from AbstractDimensionalArray will give all the functionality of using DimensionalArray.","category":"page"},{"location":"course/#Crash-course-1","page":"Crash course","title":"Crash course","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"This is brief a tutorial for DimensionalData.jl.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The main functionality is explained here, but the full list of features is listed at the API page.","category":"page"},{"location":"course/#Dimensions-and-DimensionalArrays-1","page":"Crash course","title":"Dimensions and DimensionalArrays","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The core type of DimensionalData.jl is the Dimension and the types that inherit from it, such as Ti, X, Y, Z, the generic Dim{:x}, or others that you define manually using the @dim macro.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Dimensions are primarily used in DimensionalArray, other AbstractDimensionalArray.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"We can use dimensions without a value index - these simply label the axis. A DimensionalArray with labelled dimensions is constructed by:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"using DimensionalData\r\nA = DimensionalArray(rand(5, 5), (X, Y))","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"But often we want to provide values for the dimension.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"using Dates\r\nt = Ti(DateTime(2001):Month(1):DateTime(2001,12))\r\nx = X(10:10:100)","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Here both X and Ti are dimensions from DimensionalData. The currently exported dimensions are X, Y, Z, Ti. Ti is shortening of Time - to avoid the conflict with Dates.Time.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"We pass a Tuple of the dimensions to the constructor of DimensionalArray, after the array:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A = DimensionalArray(rand(12, 10), (t, x))","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The length of each dimension index has to match the size of the corresponding array axis. ","category":"page"},{"location":"course/#Indexing-the-array-by-name-and-index-1","page":"Crash course","title":"Indexing the array by name and index","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Dimensions can be used to index the array by name, without having to worry about the order of the dimensions.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The simplest case is to select a dimension by index. Let's say every 2nd point of the Ti dimension and every 3rd point of the X dimension. This is done with the simple Ti(range) syntax like so:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A[X(1:3:end), Ti(1:2:end)]","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Of course, when specifying only one dimension, all elements of the other dimensions are assumed to be included:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A[X(1:3:10)]","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"info: Indexing\nIndexing AbstractDimensionalArrays works with getindex, setindex! and view. The result is still an AbstracDimensionalArray.","category":"page"},{"location":"course/#Selecting-by-name-and-value-1","page":"Crash course","title":"Selecting by name and value","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The above example is useful because one does not have to care about the ordering of the dimensions. But arguably more useful is to be able to select a dimension by its values. For example, we would like to get all values of A where the X dimension is between two values.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Selecting by value in DimensionalData is done with the selectors, which are listed in the Selectors page. This avoids the ambiguity of what happens when the index values of the dimension are also integers (like the case here for the dimension X).","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"For simplicity, here we use the Between selector, but  others also exist, like At, Contains, or Near.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A[X(Between(12, 35)), Ti(Between(Date(2001, 5), Date(2001, 7)))]","category":"page"},{"location":"course/#Selecting-by-position-1","page":"Crash course","title":"Selecting by position","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"So far, the selection protocols we have mentioned work by specifying the name of the dimension, without worry about the order.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"However normal indexing also works by specifying dimensions by position. This functionality also covers Selectors.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Continuing to use A we defined above, you can see how this works by comparing the statements without and with names:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A[:, Between(12, 35)] == A[X(Between(12, 35))]\r\nA[:, 1:5] == A[X(1:5)]\r\nA[1:5, :] == A[Ti(1:5)]","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Using this approach it is necessary to specify all dimensions by position. ","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"In addition, to support as base Julia functionality single index access like in standard Array:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"A[1:5]","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"selects the first 5 entries of the underlying array. In the case that A has only one dimension, it will be retained. Multidimensional AbstracDimensionalArray indexed this way will return a regular array.","category":"page"},{"location":"course/#Specifying-dims-keyword-arguments-with-Dimension-1","page":"Crash course","title":"Specifying dims keyword arguments with Dimension","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"In many Julia functions like size, sum, you can specify the dimension along which to perform the operation, as an Int. It is also possible to do this using Dimension types with AbstractDimensionalArray:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"sum(A; dims=X)","category":"page"},{"location":"course/#Numeric-operations-on-dimension-arrays-and-dimensions-1","page":"Crash course","title":"Numeric operations on dimension arrays and dimensions","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"Numeric operations on a AbstractDimensionalArray match base Julia as much as possible. Standard broadcasting and other type of operations across dimensional arrays typically perform as expected while still returning an AbstractDimensionalArray type with correct dimensions.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"In cases where you would like to do some operation on the dimension index, e.g. take the cosines of the values of the dimension X while still keeping the dimensional information of X, you can use the syntax:","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"DimensionalArray(cos, x)","category":"page"},{"location":"course/#Referenced-dimensions-1","page":"Crash course","title":"Referenced dimensions","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The reference dimensions record the previous dimensions that an array was selected from. These can be use for plot labelling, and tracking array changes.","category":"page"},{"location":"course/#IndexMode-1","page":"Crash course","title":"IndexMode","text":"","category":"section"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"DimensionalData provides types for specifying details about the dimension index. This enables optimisations with Selectors, and modified behaviours such as selection of intervals or points, which will give slightly different results for selectors like Between.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"The major categories are Categorical, Sampled and NoIndex, which are all types of Aligned. Unaligned also exists to handle dimensions with an index that is rotated or otherwise transformed in relation to the underlying array, such as Transformed. These are a work in progress.","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"[Aligned] types will be detected automatically if not specified. A Dimension containing and index of String, Char or Symbol will be labelled with Categorical. A range will be Sampled, defaulting to Points and Regular. ","category":"page"},{"location":"course/#","page":"Crash course","title":"Crash course","text":"See the api docs for specifics about these IndexModes.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions. It's a pluggable, generalised version of AxisArrays.jl with a cleaner syntax, and additional functionality found in NamedDimensions.jl. It has similar goals to pythons xarray, and is primarily written for use with spatial data in GeoData.jl.\n\ninfo: Status\nThis is a work in progress under active development, it may be a while before the interface stabilises and things are fully documented.\n\nDimensions\n\nDimensions are just wrapper types. They store the dimension index and define details about the grid and other metadata, and are also used to index into the array, wrapping a value or a Selector. X, Y, Z and Ti are the exported defaults.\n\nA generalised Dim type is available to use arbitrary symbols to name dimensions. Custom dimensions can be defined using the @dim macro.\n\nWe can use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:\n\na[X(1:10), Y(1:4)]\n\nThe core component is the AbstractDimension, and types that inherit from it, such as Time, X, Y, Z, the generic Dim{:x} or others you define manually using the @dim macro.\n\nDims can be used for indexing and views without knowing dimension order: a[X(20)], view(a, X(1:20), Y(30:40)) and for indicating dimesions to reduce mean(a, dims=Time), or permute permutedims(a, [X, Y, Z, Time]) in julia Base and Statistics functions that have dims arguments.\n\nSelectors\n\nSelectors find indices in the dimension based on values At, Near, or Between the index value(s). They can be used in getindex, setindex! and view to select indices matching the passed in value(s)\n\nAt(x) : get indices exactly matching the passed in value(s)\nNear(x) : get the closest indices to the passed in value(s)\nBetween(a, b) : get all indices between two values (inclusive)\n\nWe can use selectors with dim wrappers:\n\na[X(Between(1, 10)), Y(At(25.7))]\n\nWithout dim wrappers selectors must be in the right order:\n\nusin Unitful\na[Near(23u\"s\"), Between(10.5u\"m\", 50.5u\"m\")]\n\nIt's easy to write your own custom Selector if your need a different behaviour.\n\nExample usage:\n\nusing Dates, DimensionalData\ntimespan = DateTime(2001,1):Month(1):DateTime(2001,12)\nA = DimensionalArray(rand(12,10), (Ti(timespan), X(10:10:100)))\n\njulia> A[X(Near(35)), Ti(At(DateTime(2001,5)))]\n0.658404535807791\n\njulia> A[Near(DateTime(2001, 5, 4)), Between(20, 50)]\nDimensionalArray with dimensions:\n X: 20:10:50\nand referenced dimensions:\n Time (type Ti): 2001-05-01T00:00:00\nand data: 4-element Array{Float64,1}\n[0.456175, 0.737336, 0.658405, 0.520152]\n\nDim types or objects can be used instead of a dimension number in many Base and Statistics methods:\n\nMethods where dims can be used containing indices or Selectors\n\ngetindex, setindex! view\n\nMethods where dims can be used\n\nsize, axes, firstindex, lastindex\ncat\nreverse\ndropdims\nreduce, mapreduce\nsum, prod, maximum, minimum, \nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice\n\nExample usage:\n\nA = DimensionalArray(rand(20,10), (X, Y))\nsize(A, Y)\nmean(A, dims=X)\nstd(A; dims=Y())\n\nAlternate Packages\n\nThere are a lot of similar julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate any of their functionality, although with slightly more verbose syntax and less polish in some cases. If there is anything it doesn't do that these packages can do, put in an issue with the feature requrest.\n\nAbstractIndices.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread\n\n\n\n\n\n","category":"module"},{"location":"#","page":"Introduction","title":"Introduction","text":"To learn how to use this package, see the Crash course.","category":"page"}]
}
